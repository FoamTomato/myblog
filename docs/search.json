[{"title":"初探xxljob","url":"/2022/02/13/0.0.1%E5%88%9D%E6%8E%A2xxljob/","content":"下载地址\n搭建xxljob需要提前准备好\nmaven3+jdk8+mysql5.7+\n\n1.首先初始化SQL脚本建立必须的库和表\n2.对于解压的文件分为三个模块xxl-job-admin：调度中心xxl-job-core：公共依赖xxl-job-executor-samples：执行器Sample示例（选择合适的版本执行器，可直接使用，也可以参考其并将现有项目改造成执行器）    ：xxl-job-executor-sample-springboot：Springboot版本，通过Springboot管理执行器，推荐这种方式；    ：xxl-job-executor-sample-frameless：无框架版本；\n\n其中：xxl-job-core是需要引入的源码包后续我们可以用以下形式引入\n&lt;dependency&gt;    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;\n\nxxl-job-admin是我们的调度中心，我们只需要把这个项目单独拿出来运行就行了，下面是运行结果\n\nxxl-job-executor-sample-springboot是我们后续用boot可以参照的模板，当然也可以直接用来使用\n3.xxl-job-admin配置先修改数据库的地址，也就是上面初始化的地址\n注意在数据库地址哪里加上时区属性，否则乱码\n\n然后修改警报邮箱配置\n\n4.警报邮箱配置\n去自己对应邮箱的设置里面找到smtp并开启\n注意：spring.mail.password的密码是QQ邮箱开启SMTP的授权码而非QQ密码\n\n这里需要注意不同邮箱有不同的收发件host\n比如新浪\n发件:POP3服务器为：pop3.sina.com.cn收件:SMTP服务器为：smtp.sina.com.cn\nqq\n发件:POP3服务器为：pop.qq.com收件:SMTP服务器为：smtp.qq.com\n注意 不能自己邮箱发自己邮箱，否则收不到\n\n上面就是收件的内容\n5.boot整合xxljob引入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;\n\n配置文件整合\npackage com.example.demo.config;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class xxlConfig &#123;    private Logger logger = LoggerFactory.getLogger(xxlConfig.class);    @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)    private String adminAddresses;    @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)    private String accessToken;    @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)    private String appname;    @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)    private String address;    @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)    private String ip;    @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)    private int port;    @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)    private String logPath;    @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)    private int logRetentionDays;    @Bean    public XxlJobSpringExecutor xxlJobExecutor() &#123;        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);        xxlJobSpringExecutor.setAppname(appname);        xxlJobSpringExecutor.setAddress(address);        xxlJobSpringExecutor.setIp(ip);        xxlJobSpringExecutor.setPort(port);        xxlJobSpringExecutor.setAccessToken(accessToken);        xxlJobSpringExecutor.setLogPath(logPath);        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);        return xxlJobSpringExecutor;    &#125;&#125;\n\napplication.properties\n# 启动端口和访问路径server.port=8089server.servlet.context-path=/todo# 调度中心（xxl-job-admin）的部署地址，如调度中心集群部署存在多个地址则用逗号分隔。执行器将会使用该地址进行&quot;执行器心跳注册&quot;和&quot;任务结果回调&quot;；# 为空则关闭自动注册；则需要手动注册xxl.job.admin.addresses=http://127.0.0.1:8080/xxl-job-admin### 执行器通讯TOKEN [选填]：非空时启用；xxl.job.accessToken=### 执行器AppName [选填]：执行器心跳注册分组依据；为空则关闭自动注册xxl.job.executor.appname=job-to-do### 执行器注册 [选填]：优先使用该配置作为注册地址，为空时使用内嵌服务 ”IP:PORT“ 作为注册地址。从而更灵活的支持容器类型执行器动态IP和动态映射端口问题。xxl.job.executor.address=### 执行器IP [选填]：默认为空表示自动获取IP，多网卡时可手动设置指定IP，该IP不会绑定Host仅作为通讯实用；地址信息用于 &quot;执行器注册&quot; 和 &quot;调度中心请求并触发任务&quot;；xxl.job.executor.ip=xxl.job.executor.port=9998### 执行器运行日志文件存储磁盘路径 [选填] ：需要对该路径拥有读写权限；为空则使用默认路径；xxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### 执行器日志文件保存天数 [选填] ： 过期日志自动清理, 限制值大于等于3时生效; 否则, 如-1, 关闭自动清理功能；xxl.job.executor.logretentiondays=30\n\n6.定时任务的创建方式\n@XxlJob注解是新版本提供的方式，不需要继承\n旧版方式是继承IJobHander然后重写execute方法\n7.界面介绍\n\n 注意  当删除任务时，任务日志也会跟着删除 \n","tags":["java","中间件"]},{"title":"分段执行","url":"/2022/05/01/0.0.3%E5%88%86%E6%AE%B5%E6%89%A7%E8%A1%8C/","content":"int batchSize = 1000;if(dataList.size() &lt;= batchSize)&#123;    insertByStocks(dataList,type);&#125;else &#123;    for(int i = 0;i &lt; dataList.size();i+=batchSize)&#123;        if((i + batchSize)&gt; dataList.size())&#123;            batchSize = dataList.size()-i;        &#125;        insertByStocks(dataList.subList(i,i+batchSize),type);    &#125;&#125;\nbatchSize: 每次执行多少条\ndataList:  数据列表\ninsertByStocks：需要执行的方法\n","tags":["工具类","算法公式"]},{"title":"分库分表思想","url":"/2022/04/10/0.0.4%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%80%9D%E6%83%B3/","content":"\n随着单库中的数据量越来越大、数据库的查询QPS越来越高，相应的，对数据库的读写所需要的时间也越来越多。数据库的读写性能可能会成为业务发展的瓶颈。对应的，就需要做数据库性能方面的优化。\n\n场景一：如果数据库的查询QPS【连接数】过高，就需要考虑拆库，通过分库来分担单个数据库的连接压力。比如，如果查询QPS为3500，假设单库可以支撑1000个QPS的话，那么就可以考虑拆分成4个库，来分散查询连接压力。\n场景二：如果单表数据量过大，就需要考虑分表，当数据量超过一定量级后，无论是对于数据查询还是数据更新，在经过索引优化等纯数据库层面的传统优化手段之后，还是可能存在性能问题。这是量变产生了质变，这时候就需要去换个思路来解决问题，比如：从数据生产源头、数据处理源头来解决问题，既然数据量很大，那我们就来个分而治之，化整为零。这就产生了分表，把数据按照一定的规则拆分成多张表，来解决单表环境下无法解决的存取性能问题。\n场景三：如果单数据库宕机，可能所有数据都会丢失，就需要考虑数据拆分\n\n单库部署情况下，如果数据库宕机，那么故障影响就是100%，而且恢复可能耗时很长。\n如果我们拆分成2个库，分别部署在不同的机器上，此时其中1个库宕机，那么故障影响就是50%，还有50%的数据可以继续服务。\n如果我们拆分成4个库，分别部署在不同的机器上，此时其中1个库宕机，那么故障影响就是25%，还有75%的数据可以继续服务，恢复耗时也会很短。\n\n当然，我们也不能无限制的拆库，这也是牺牲存储资源来提升性能、可用性的方式，毕竟资源总是有限的。\n分库分表是什么分库分表就是为了解决由于数据量过大而导致数据库性能降低的问题，将原来独立的数据库拆分成若干数据库组成 ，将数据大表拆分成若干数据表组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。\n分库分表有哪些分库分表包括分库和分表两个部分，在生产中通常包括：垂直分表、垂直分库、水平分库、水平分表四种方式\n垂直分表在电商的场景中，商品往往只会在用户感兴趣的时候才会查看该商品的详细描述，因此，商品信息中商品详情访问的频率没有那么高，而且一般占用的内存空间会较大，访问单个数据IO时间较长\n反之，商品名称，图片和价格等这些关键性字段的访问频率较高。\n针对这两种数据的特性，我们可以考虑进行垂直分表，访问频率低的商品详情单独拆分为一张表，访问频率高的字段放在一张表，通过商品的id进行关联\n\n垂直分表定义：将一个表按照字段分成多表，每个表存储其中一部分字段\n优点：\n\n为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响 \n充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累\n\n一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。\n垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。\n通常我们按以下原则进行垂直拆分：\n\n把不常用的字段单独放在一张表\n把text，blob等大字段拆分出来放在附表中\n经常组合查询的列放在一张表中\n\n垂直分库通过垂直分表性能得到了一定程度的提升，但是还没有达到要求，并且磁盘空间也快不够了，因为数据还是始终限制在一台服务器，库内垂直分表只解决了单一表数据量过大的问题，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。 \n\n垂直分库定义：按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用\n优点：\n\n解决业务层面的耦合，业务清晰\n能对不同业务的数据进行分级管理、维护、监控、扩展等\n高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈 \n\n垂直分库通过将表按业务分类，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题\n水平分库经过垂直分库后，数据库性能问题得到一定程度的解决，但是随着业务量的增长，PRODUCT_DB(商品库)单库存储数据已经超出预估。粗略估计，目前有8w店铺，每个店铺平均150个不同规格的商品，再算上增长，那商品数量得往1500w+上预估，并且PRODUCT_DB(商品库)属于访问非常频繁的资源，单台服务器已经无法支撑。此时该如何优化？\n这时候我们需要考虑使用水平分库，通过分库规则将商品信息分别放在两个库中\n\n也就是说，要操作某条数据，先分析这条数据所属的店铺ID。如果店铺ID为双数，将此操作映射至RRODUCT_DB1(商品库1)；如果店铺ID为单数，将操作映射至RRODUCT_DB2(商品库2)。此操作要访问数据库名称的表达式为RRODUCT_DB[店铺ID%2 + 1] 。\n 水平分库定义：是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上\n优点：\n\n解决了单库大数据，高并发的性能瓶颈\n提高了系统的稳定性及可用性\n\n当一个应用难以再细粒度的垂直切分，或切分后数据量行数巨大，存在单库读写、存储性能瓶颈，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但由于同一个表被分配在不同的数据库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度\n水平分表按照水平分库的思路对他把PRODUCT_DB_X(商品库)内的表也可以进行水平拆分，其目的也是为解决单表数据量大的问题\n\n与水平分库的思路类似，不过这次操作的目标是表，商品信息及商品描述被分成了两套表。\n如果商品ID为双数，将此操作映射至商品信息1表；如果商品ID为单数，将操作映射至商品信息2表。此操作要访问表名称的表达式为商品信息[商品ID%2 + 1] \n 水平分表定义：在同一个数据库内，把同一个表的数据按一定规则拆到多个表中\n优点：\n\n优化单一表数据量过大而产生的性能问题 \n避免IO争抢并减少锁表的几率\n\n库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能\n小结一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表方案，在数据量及访问压力不是特别大的情况，首先考虑缓存、读写分离、索引技术等方案。若数据量极大，且持续增长，再考虑水平分库水平分表方案，因为它也会带来一些问题：\n\n事务一致性问题\n\n由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来分布式事务问题\n\n\n跨节点关联查询\n\n在没有分库前，我们检索商品时可以通过以下SQL对店铺信息进行关联查询： \nSELECT p.*,r.[地理区域名称],s.[店铺名称],s.[信誉] FROM [商品信息] p LEFT JOIN [地理区域] r ON p.[产地] = r.[地理区域编码] LEFT JOIN [店铺信息] s ON p.id = s.[所属店铺] WHERE...ORDER BY...LIMIT...\n\n但垂直分库后**[商品信息]和[店铺信息]**不在一个数据库，甚至不在一台服务器，无法进行关联查询。 \n可将原关联查询分为两次查询，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据，最后将获得到的数据进行拼装（归并）\n\n\n跨节点分页，排序函数\n\n跨节点多库进行查询时limit分页、order by排序等问题，就变得比较复杂了。需要先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序\n所以请求页数越大，系统的性能也会越差\n在使用Max、Min、Sum、Count之类的函数进行计算的时候，与排序分页同理，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回\n\n\n主键避重\n\n在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的ID无法保证全局唯一。因此需要单独设计全局主键，以避免跨库主键重复问题\n\n\n公共表\n\n实际的应用场景中，参数表、数据字典表等都是数据量较小，变动少，而且属于高频联合查询的依赖表\n可以将这类表在每个数据库都保存一份，所有对公共表的更新操作都同时发送到所有分库执行\n\n\n\n由于分库分表之后，数据被分散在不同的数据库、服务器。因此，对数据的操作也就无法通过常规方式完成，并且它还带来了一系列的问题。所以使用之前需要把以上会带来的问题仔细考虑进去\n","tags":["分库分表","数据库"]},{"title":"定时任务使用总结","url":"/2022/04/04/0.0.2%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","content":"相信定时任务大家都不陌生，可能在个人项目中使用定时任务会比较少，但是在业务复杂的公司中，定时任务是不可或缺的一部分，有时候也可以贯穿整个项目的流程运转。\n什么是定时任务crond类似于我们平时生活中的闹钟，可以定时叫你起床，而在项目中就是定时执行一段指定的代码\n为什么要使用crond呢\n1.如果对于一些数据实时性要求没那么高，我们可以把数据提前丢到缓存中，这个时候就需要使用定时任务去跑了，比如每天凌晨3点定时把数据同步到缓存，错峰同步避开白天人流量大的时候消耗资源\n2.比如凌晨2点有抢购接口/或者业务开关需要进行变更开启，我们可以使用定时任务去进行变更，不用人为去守着变更，而且执行时间更准确（可以滚去睡大觉.jpg）\n3.还可以进行数据的定时备份，比如备份配置文件，防止宕机的时候配置文件的恢复等等\n定时任务实现方式1.Thread各位亲爱的朋友，没错，Thread真的可以做定时任务.\n如果你去看过一些定时任务框架的源码，它们的底层也会使用Thread类（需要注意用try……catch捕获异常，否则出现异常，就直接退出循环）\npublic static void init() &#123;    new Thread(() -&gt; &#123;        while (true) &#123;            try &#123;                System.out.println(&quot;doSameThing&quot;);                Thread.sleep(1000 * 60 * 5);            &#125; catch (Exception e) &#123;                log.error(e);            &#125;        &#125;    &#125;).start();&#125;\n\n使用场景：比如项目中有时需要每隔10分钟去下载某个文件，或者每隔5分钟去读取模板文件生成静态html页面等等，一些简单的周期性任务场景。\n优缺点：\n\n优点：这种定时任务非常简单，学习成本低，容易入手，对于那些简单的周期性任务，是个不错的选择。\n缺点：不支持指定某个时间点执行任务，不支持延迟执行等操作，功能过于单一，无法应对一些较为复杂的场景。\n\n2.TimerTimer 类是jdk专门提供的定时器工具，用来在后台线程计划执行指定任务，在 java.util 包下，要跟 TimerTask 一起配合使用。\n@Testpublic void Timer()&#123;    Timer timer = new Timer();    // 1.需要执行的内容    // 2.延时多久执行    // 3.执行周期    timer.schedule(new TimerTask() &#123;        @Override        public void run() &#123;            System.out.println(123);        &#125;    &#125;,200,1000);&#125;\n\n优缺点：\n\n优点：非常方便实现多个周期性的定时任务，并且支持延迟执行，还支持在指定时间之后支持，功能还算强大。\n缺点：如果其中一个任务耗时非常长，会影响其他任务的执行。并且如果 TimerTask 抛出 RuntimeException ， Timer 会停止所有任务的运行，所以阿里巴巴开发者规范中不建议使用它\n\n3.Scheduled 注解（常用）由于xml方式太古老了，我们以springboot项目中注解方式为例\n1.引入依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&lt;/dependency&gt;\n\n2.在springboot启动类上加上 @EnableScheduling 注解\n@EnableScheduling@SpringBootApplicationpublic class Application &#123;    ……&#125;\n\n3.使用 @Scheduled 注解定义定时规则\nimport org.springframework.stereotype.Component;import java.text.SimpleDateFormat;import java.util.Date;@Componentpublic class CronJob &#123;    @Scheduled(cron = &quot;0/5 * * * * ?&quot;)    public void autoGetMessage()&#123;        System.out.println(&quot;当期执行时间：&quot; + new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;).format(new Date()));    &#125;&#125;\n\n优缺点：\n\n优点：采用cron表达式，比较方便，spring框架自带的定时功能，springboot做了非常好的封装，开启和定义定时任务非常容易，可以满足绝大多数单机版的业务场景。单个任务时，当前次的调度完成后，再执行下一次任务调度。\n默认单线程，如果前面的任务执行时间太长，对后面任务的执行有影响。不支持集群方式部署，不能做数据存储型定时任务。\n\n5.spring quartz（常用）quartz 是 OpenSymphony 开源组织在 Job scheduling 领域的开源项目，是由java开发的一个开源的任务日程管理系统。\nquartz能做什么？\n\n作业调度：调用各种框架的作业脚本，例如shell,hive等。\n定时任务：在某一预定的时刻，执行你想要执行的任务\n\n1.引入相关依赖\n&lt;dependency&gt;    &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt;    &lt;artifactId&gt;quartz&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;\n\n2.定时任务执行类继承QuartzJobBean\npublic class DateTimeJob extends QuartzJobBean &#123;    @Override    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123;        //获取JobDetail中关联的数据        String msg = (String) jobExecutionContext.getJobDetail().getJobDataMap().get(&quot;msg&quot;);        System.out.println(&quot;current time :&quot;+new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).format(new Date()) + &quot;---&quot; + msg);    &#125;&#125;\n\n3.调度配置\n@Configurationpublic class QuartzConfig &#123;    @Bean    public JobDetail printTimeJobDetail()&#123;        return JobBuilder.newJob(DateTimeJob.class)//PrintTimeJob我们的业务类                .withIdentity(&quot;DateTimeJob&quot;)//可以给该JobDetail起一个id                //每个JobDetail内都有一个Map，包含了关联到这个Job的数据，在Job类中可以通过context获取                .usingJobData(&quot;msg&quot;, &quot;Hello Quartz&quot;)//关联键值对                .storeDurably()//即使没有Trigger关联时，也不需要删除该JobDetail                .build();    &#125;    @Bean    public Trigger printTimeJobTrigger() &#123;        CronScheduleBuilder cronScheduleBuilder = CronScheduleBuilder.cronSchedule(&quot;0/1 * * * * ?&quot;);        return TriggerBuilder.newTrigger()                .forJob(printTimeJobDetail())//关联上述的JobDetail                .withIdentity(&quot;quartzTaskService&quot;)//给Trigger起个名字                .withSchedule(cronScheduleBuilder)                .build();    &#125;&#125;\n\n优缺点：\n\n优点：默认是多线程异步执行，单个任务时，在上一个调度未完成时，下一个调度时间到时，会另起一个线程开始新的调度，多个任务之间互不影响。支持复杂的 cron 表达式，它能被集群实例化，支持分布式部署\n缺点：相对于spring task实现定时任务成本更高，需要手动配置 QuartzJobBean 、 JobDetail和 Trigger 等。需要引入了第三方的 quartz 包，有一定的学习成本。不支持并行调度，不支持失败处理策略和动态分片的策略等。\n\n以下两种配置参考方式\nspringXML配置方式\nSpringBoot配置方式\n6.xxl-job（常用：分布式定时任务主流）xxl-job 是大众点评（许雪里）开发的一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。\nxxl-job 框架对 quartz 进行了扩展，使用 mysql 数据库存储数据，并且内置jetty作为 RPC服务调用。\n具体配置可以参考之前本人写的【初探xxljob】\n优缺点：\n\n优点：有界面管理定时任务，支持弹性扩容缩容、动态分片、故障转移、失败报警等功能。它的功能非常强大，很多大厂在用，可以满足绝大多数业务场景。\n缺点：和 quartz 一样，通过数据库分布式锁，来控制任务不能重复执行。在任务非常多的情况下，有一些性能问题。\n\n分布式定时任务在前面提到Timer/ScheduledExecutorService/SpringTask(@Schedule)都是单机的，但我们一旦上了生产环境，应用部署往往都是集群模式的。\n在集群下，我们一般是希望某个定时任务只在某台机器上执行，那这时候，单机实现的定时任务就不太好处理了。\nQuartz是有集群部署方案的，所以有的人会利用数据库行锁或者使用Redis分布式锁来自己实现定时任务跑在某一台应用机器上；做肯定是能做的，包括有些挺出名的分布式定时任务框架也是这样做的，能解决问题。\n但我们遇到的问题不单单只有这些，比如我想要支持容错功能（失败重试）、分片功能、手动触发一次任务、有一个比较好的管理定时任务的后台界面、路由负载均衡等等。这些功能，就是作为「分布式定时任务框架」所具备的。\n分布式定时任务框架又可以分成了两个流派：中心化和去中心化\n\n所谓的「中心化」指的是：调度器和执行器分离，调度器统一进行调度，通知执行器去执行定时任务\n所谓的「去中心化」指的是：调度器和执行器耦合，自己调度自己执行\n\n对于「中心化」流派来说，存储相关的信息很可能是在数据库（DataBase），而我们引入的client包实际上就是执行器相关的代码。调度器实现了任务调度的逻辑，远程调用执行器触发对应的逻辑。\n\n谈谈定时任务使用场景我现在公司对于定时任务的主要使用场景是更新缓存，清洗数据，定时推送，定时拉单等等\n先说说更新缓存：就是每隔一段时间去执行操作，可能一天只需要更新一次当天的缓存数据，一般会选择放在凌晨人流量少的时候执行。\n清洗数据和定时拉单就比较像，会比如每间隔15分钟去进行一次扫表，看看有没有需要进行执行的流程\n定时推送就是你想的那样，定时推送消息或者定时执行代码的开关\n对于以上的操作，我们可以分为两种，全量更新和增量更新\n全量更新：这个比较常用，就是一次性全部查询出来，然后一次性更新到缓存里面去\npublic void zxMachineBuild()&#123;\t// 1.查询需要缓存的数据    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax();    // 2.拼接存储格式    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    for(Tax tax:taxs)&#123;        ……        map.put(tax.getPindex(),tax);\t&#125;    // 3.更新到redis    redisService.batchPutInPipelined(map,60*60*24);&#125;\n\n注意：因为以上使用的是有过期时间的，如果正常跑的话一般会先删后增，如果是redis的话可以直接全部覆盖（使用场景一般是初始化的时候或者数据重跑）\n增量更新：增量的基础就是全量，先全量更新后，再用增量方式同步更新，一般利用节点或者状态去进行更新\n我们常用的更新方式\n根据状态更新\npublic void zxMachineBuild(String type)&#123;\t// 1.查询需要增量的数据    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax(type);    // 2.拼接存储格式    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    for(Tax tax:taxs)&#123;        ……        map.put(tax.getPindex(),tax);\t&#125;    // 3.更新到redis，根据数据判断使用过期还是精准删除    redisService.batchPutInPipelined(map,60*60*24);    // 4.更新状态    tConfigPolicyMapper.updateTConfigType(taxs);&#125;\n\n根据节点更新:假设我使用redis来存储我的节点（一般会使用id作为节点，以下例子使用时间节点）\npublic void zxMachineBuild()&#123;    // 获取上次更新的时间节点    long nodeTime = redisService.getNodeTime();\t// 获取在该时间节点之后的数据（根据时间排序）    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax(nodeTime);    // 拼接存储格式    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    for(Tax tax:taxs)&#123;        ……        map.put(tax.getPindex(),tax);        // 如果不根据时间排序就比较获取        if(tax.getCreateTime() != null &amp;&amp; tax.getCreateTime() &gt; nodeTime)&#123;\t\t\tnodeTime = tax.getCreateTime();        &#125;\t&#125;    // 3.更新到redis，根据数据判断使用过期还是精准删除    redisService.batchPutInPipelined(map,60*60*24);    // 4.更新时间节点到redis（获取最后一个的时间节点）    redisService.updateNodeTime(nodeTime);&#125;\n\n进阶（推荐）\npublic void zxMachineBuild()&#123;    // 随机一个uuid    String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;,&quot;&quot;);    // 锁定    tConfigPolicyMapper.Lock(uuid);\t// 查询提前锁定好的数据    List&lt;Tax&gt; taxs = tConfigPolicyMapper.getTConfigTax(uuid);    // 拼接存储格式    Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();    for(Tax tax:taxs)&#123;        ……        map.put(tax.getPindex(),tax);        // 如果不根据时间排序就比较获取        if(tax.getCreateTime() != null &amp;&amp; tax.getCreateTime() &gt; nodeTime)&#123;\t\t\tnodeTime = tax.getCreateTime();        &#125;\t&#125;    // 更新到redis，根据数据判断使用过期还是精准删除    redisService.batchPutInPipelined(map,60*60*24);    // 更新锁定状态为已跑    tConfigPolicyMapper.updateNodeTime(taxs);&#125;\n\n使用以上方式的好处就是可以直接先锁定自己需要跑的部分，防止其他的定时任务抢占\n## 取t_pao_lowprice_taobao数据出来，设置state=‘L’ 锁住update [t_pao_lowprice_taobao] set lockname=&#x27;guid&#x27;,locktime=GETDATE(),state=&#x27;L&#x27; from [t_pao_lowprice_taobao] a join (select top 2 id from [t_pao_lowprice_taobao] where lockname is null and state=&#x27;N&#x27; order by createtime asc) b on a.id=b.id\n\n## lockname【对应代码的uuid】 状态为state=‘L’ 获取需要跑的数据，开线程去跑select * from [t_pao_lowprice_taobao] where lockname=&#x27;guid&#x27; and state=&#x27;L&#x27;\n\n总结可能在个人项目中，对于定时任务的需求没有那么多，不会去重视这一块，但是在实际工作中，定时任务往往扮演着重要的角色\n不同的定时任务有不同的优缺点，往往我们去选择适合自己的那种方式，就需要对于其种类有一定的了解，怎样才能更高效的去进行开发，尽量避免使用到一半因为其底层设计的原因导致BUG。\n现在基本也使用E-Job(ElasticJob)或者X-Job(XXLJob)这种分布式定时任务，它们都有广泛的用户基础和完整的技术文档\n\nX-Job 侧重的业务实现的简单和管理的方便，学习成本简单，失败策略和路由策略丰富。推荐使用在“用户基数相对少，服务器数量在一定范围内”的情景下使用\nE-Job 关注的是数据，增加了弹性扩容和数据分片的思路，以便于更大限度的利用分布式服务器的资源。但是学习成本相对高些，推荐在“数据量庞大，且部署服务器数量较多”时使用\n\n单机的定时任务现在基本不推荐使用了，维护起来比较麻烦\n对于定时任务，个人理解程度有限，使用的场景往往更加复杂不能每点都考虑到，欢迎大家能提出自己的想法\n比如分布式定时任务下如何去保证事务的一致性，单机定时任务又如何去保证数据不重复等等场景都需要去挖掘……\n参考指南：\n\n什么是定时任务\n十种常用定时任务\nSpringboot定时任务以及优缺点\nSpring集成Quartz定时器\n为什么要用分布式定时任务\n分布式定时任务框架选型\n\n"},{"title":"缓存双写不一致","url":"/2022/03/07/0.0.5%E7%BC%93%E5%AD%98%E5%8F%8C%E5%86%99%E4%B8%8D%E4%B8%80%E8%87%B4/","content":"缓存数据库双写不一致\n高并发下缓存与数据库双写不一致解决方案\n\n正常的缓存数据库更新的时候应该是先执行线程1，然后执行线程2\n\n如果线程1卡顿了一下，这时就会造成数据库和缓存不一致的情况线程1把线程2更新的缓存数据给覆盖了\n\n最开始的缓存不一致问题以及解决方案\n问题：先修改数据库，再删除缓存，如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据出现不一致。\n\n解决思路：　　先删除缓存，再修改数据库，如果删除缓存成功了修改数据库失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致，因为读的时候缓存没有，则读数据库中旧数据，然后更新到缓存中。\n\n2、并发下数据缓存不一致问题分析问题：　　第一个请求数据发生变更，先删除了缓存，然后要去修改数据库，此时还没来得及去修改；　　第二个请求过来去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中；　　第三个请求读取缓存中的数据 (此时第一个请求已经完成了数据库修改的操作)。　　完了，数据库和缓存中的数据不一样了。。。。\n\n分析原因：\n只有在对同一条数据并发读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就1万次，那么很少的情况下，会出现刚才描述的那种不一致的场景;但如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。\n内存队列数据库的缓存更新与读取操作进行串行化，一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。\n  　　1. 首先我们的项目里维护一组线程池和内存队列。  　　2. 更新数据的时候，根据数据的唯一标识将请求路由到一个jvm队列中，去更新数据库,然后请求结束。  　　3. 读取数据的时候，先查缓存，如果发现数据不在缓存中，那么将根据唯一标识路由之后，也发送同一个jvm内部的队列中，重新读取数据库后更新缓存,最后请求结束。\n\n缺点：\n1.实现起来麻烦，不同的key可能需要搞不同的队列\n2.如果系统挂了，还得还原这些数据，如果出现了异常，还会造成脏数据\n延时双删\n延时双删方案执行步骤1.删除redis2.更新数据库3.延时50毫秒4.删除redis\n\n问题一：为何要延时50毫秒？这是为了我们在第二次删除redis之前能完成数据库的更新操作。假象一下，如果没有第三步操作时，有很大概率，在两次删除redis操作执行完毕之后，数据库的数据还没有更新，此时若有请求访问数据，便会出现我们一开始提到的那个问题。\n问题二: 为何要两次删除redis?如果我们没有第二次删除操作，此时有请求访问数据，有可能是访问的之前未做修改的redis数据，删除操作执行后，redis为空，有请求进来时，便会去访问数据库，此时数据库中的数据已是更新后的数据，保证了数据的一致性。\n\n缺点：\n1.没有从根本上面去解决问题，如果更新缓存时间超过50ms，那么还是失败的，如果要一直保证休眠时间大于更新时间，这样会不会造成阻塞\n2.如果一个接口请求有限制时间，这休眠时间会影响用户体验，影响接口的响应速度\n分布式锁如果加分布式锁可以直接保证每个线程的执行顺序，也是一种串行操作\n这个还是比较推荐使用的，比内存串行实现简单，而且稳定\n\n缺点：\n1.分布式锁会有性能问题，会导致并发量很低（加锁永远不是最优的方案）\n读写锁redisson中间里面实现了读写锁，读锁与读锁之间是不会互斥的和没加锁一样，写锁与写锁会互斥\n一般都是读多写少\n\n总结一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，那最好不要上述的串行化的这个方案，因为读请求和写请求串行化，串到一个内存队列里去，这样是可以保证一定不会出现不一致的情况。但是，串行化之后，就会导致系统的吞吐量会大幅度的降低，你就需要用比正常情况下多几倍的机器去支撑线上的一个请求。\n以上是本人对缓存数据库不一致情况的了解，本人能力有限，如有问题还望包含，也欢迎指正。谢谢！\n","tags":["数据库","redis","缓存"]},{"title":"简单吐槽一下xml","url":"/2022/01/08/0.0.6%E7%AE%80%E5%8D%95%E5%90%90%E6%A7%BD%E4%B8%80%E4%B8%8Bxml/","content":"\n描述\n\n近期与供应商对接的时候，对方的接口还是比较稳定的xml接口，与当下流行的json的便捷性相比还是不太方便，中间我也使用了几种工具类，很难有完全适配的，下文我将讲述我解析xml的历程\n\n初次接触\n\n第一次接触xml接口是在对接物流渠道商的时候，当时他们使用的对接方式为soap格式，刚接触解析起来简直要了老命，什么是soap呢？是基于xml的简易协议，常用于webservie，它有自己的一套编码规则，如下\n\n这种请求网上解析方式就很少，很多只有解析没有构造，文本也不太全，目前见过写的比较好的解析如下：https://blog.csdn.net/RUANJIAOXIAOZI/article/details/90770534\n当然还有xsd模式的xml\n因为这次讲的是xml解析，上面只是举个栗子，让你们体会一下xml的变种有多难😭\n这种接口不过分的说，至少十年往上的架构了\n\n使用dom4j/jsoup解析\n\ndom4j应该是最经典解析xml的api了，性能优异，功能强大。但是使用起来还是略为麻烦，有点像用java的jsoup去爬取网页，需要一个一个节点的去找\nDom4j获取xml的三种方式1.读取xml文件，获得document对象    SAXReader reader = new SAXReader();    Document document = reader.read(new File(&quot;test.xml&quot;));2.直接解析xml形式的文本    String text = &quot;&lt;tag&gt;&lt;/tag&gt;&quot;;\tDocument document = DocumentHelper.parseText(text);3.主动创建document对象    Document document = DocumentHelper.createDocument();\tElement root = document.addElement(&quot;tag&quot;);\n\njsoup解析html方式Document document = Jsoup.parse(html);Element postList = document.getElementById(&quot;post_list&quot;);Elements titleEle = postItem.select(&quot;.post_item_body a[class=&#x27;titlelnk&#x27;]&quot;);\n\n以上这种解析方式，属于所见即所得随时可取，但是往往可读性比较差，如图\n当然如果你不嫌麻烦，jsoup也可以解析xml的😎\npublic class JosupTest &#123;    public static void main(String[] args) throws IOException &#123;        //1. 获取Document对象，根据xml文档获取        //2. 获取user.xml的path        String path = Objects.requireNonNull(JosupTest.class.getClassLoader().getResource(&quot;User.xml&quot;)).getPath();        //3. 解析xml文档，加载文档进内存，获取dom树-----&gt;Document        Document document = Jsoup.parse(new File(path),&quot;UTF-8&quot;);        //4. 获取元素对象Elements(类型为ArrayList)        Elements elements = document.getElementsByTag(&quot;name&quot;);        //5. 测试获取元素的个数是否符合，xml文件中的个数        System.out.println(elements.size());        //5. 测试获取第一个元素        Element element = elements.get(0);        //5. 测试获取第一个元素的文本内容        String name = element.text();        //5. 测试获取第一个元素的名字是否正确        System.out.println(name);    &#125;&#125;\n\n\n利用fastjson进行转换\n\nfastjson和gson这两种解析方式是我使用最多的两种解析方式\ngson：快速，高效，代码量少，面向对象，但是相对fastjson和jackjson，它的各方面性能都被碾压\nfastjson：性能最高，支持多种类型解析，由于fastjson太侧重性能，对于部分高级特性支持不够，有一部分自定义特性完全偏离了json和js规范，可能导致与其他框架不兼容的bug，并且文档缺失较多，而且代码缺少注释较为晦涩，近几年也出现过一些高危漏洞\n如果要使用fastjson解析xml为json格式就需要使用工具类的形式进行转换\npackage com.service.zl.model;import java.util.List;import org.dom4j.Attribute;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.DocumentHelper;import org.dom4j.Element;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;/** * xml工具类 * @author sleep * @date 2016-09-13 */public class XmlTools &#123;    /**     * String 转 org.dom4j.Document     * @param xml     * @return     * @throws DocumentException     */    public static Document strToDocument(String xml) throws DocumentException &#123;        return DocumentHelper.parseText(xml);    &#125;    /**     * org.dom4j.Document 转  com.alibaba.fastjson.JSONObject     * @param xml     * @return     * @throws DocumentException     */    public static JSONObject documentToJSONObject(String xml) throws DocumentException &#123;        return elementToJSONObject(strToDocument(xml).getRootElement());    &#125;    /**     * org.dom4j.Element 转  com.alibaba.fastjson.JSONObject     * @param node     * @return     */    public static JSONObject elementToJSONObject(Element node) &#123;        JSONObject result = new JSONObject();        // 当前节点的名称、文本内容和属性        List&lt;Attribute&gt; listAttr = node.attributes();// 当前节点的所有属性的list        for (Attribute attr : listAttr) &#123;// 遍历当前节点的所有属性            result.put(attr.getName(), attr.getValue());        &#125;        // 递归遍历当前节点所有的子节点        List&lt;Element&gt; listElement = node.elements();// 所有一级子节点的list        if (!listElement.isEmpty()) &#123;            for (Element e : listElement) &#123;// 遍历所有一级子节点                if (e.attributes().isEmpty() &amp;&amp; e.elements().isEmpty()) // 判断一级节点是否有属性和子节点                    result.put(e.getName(), e.getTextTrim());// 沒有则将当前节点作为上级节点的属性对待                else &#123;                    if (!result.containsKey(e.getName())) // 判断父节点是否存在该一级节点名称的属性                        result.put(e.getName(), new JSONArray());// 没有则创建                    ((JSONArray) result.get(e.getName())).add(elementToJSONObject(e));// 将该一级节点放入该节点名称的属性对应的值中                &#125;            &#125;        &#125;        return result;    &#125;&#125;\n\n上面工具类可以直接把xml转为json格式，非常方便，但是局限性太大   只能单向解析，所以最好的方式还是建立实体类的方式\n\njaxb和jackson\n\njaxb：它是一个业界的标准，是一项可以根据xml生成java类的技术。也可以根据xml实例文档反向生成java对象树的方法，与sax和dom不同，不需要了解xml解析技术，就两种操作java对象转xml和xml转java对象\njackson：它性能介于fastjson和gson之间，但是它是目前最流行的api，规范性高，漏洞也没有fastjson多，还支持json和xml转换，目前市场上最好用的api之一\n先来看看jaxb的解析xml方式\n@XmlRootElement(name = &quot;ServicesError&quot;)public class TaoBaoBaseRequest implements Serializable &#123;    private String errorCode;    private String errorMessage;    @XmlElement(name = &quot;ErrorCode&quot;)    public String getErrorCode() &#123;        return errorCode;    &#125;    public void setErrorCode(String errorCode) &#123;        this.errorCode = errorCode;    &#125;    @XmlElement(name = &quot;ErrorMessage&quot;)    public String getErrorMessage() &#123;        return errorMessage;    &#125;    public void setErrorMessage(String errorMessage) &#123;        this.errorMessage = errorMessage;    &#125;&#125;\n\njaxb的解析可以参考这篇文章：https://blog.csdn.net/wn084/article/details/80853587\n以下是jackjson的解析\npackage com.model.taobao;import com.alibaba.fastjson.JSON;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.databind.MapperFeature;import com.fasterxml.jackson.dataformat.xml.XmlMapper;import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlProperty;import com.fasterxml.jackson.dataformat.xml.annotation.JacksonXmlRootElement;import javax.xml.bind.annotation.XmlRootElement;import javax.xml.stream.XMLStreamException;import java.io.IOException;/** * ClassName: test &lt;br/&gt; * Description: &lt;br/&gt; * date: 2022/1/30 9:08&lt;br/&gt; * * @author Administrator&lt;br /&gt; */public class test &#123;    public static void main(String[] args) throws IOException, XMLStreamException &#123;        String xml = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot; standalone=\\&quot;no\\&quot; ?&gt;&lt;DataList Airlines=\\&quot;ALL\\&quot; Dpt=\\&quot;KMG\\&quot; Arr=\\&quot;JJN\\&quot; Date=\\&quot;20220301\\&quot; Carrier=\\&quot;SC\\&quot; Cabin = \\&quot;U\\&quot; Code=\\&quot;SC9260\\&quot;&gt;&lt;/DataList&gt;&quot;;        DataList dataList1 = xmlToObject(xml, DataList.class);        System.out.println(JSON.toJSONString(dataList1));    &#125;    public static String objectToXml(Object object) throws IOException &#123;        XmlMapper xmlMapper= new XmlMapper();        xmlMapper.setDefaultUseWrapper(false);        /* 字段为null，自动忽略，不再序列化 */        xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);        /* 设置转换模式 */        xmlMapper.enable(MapperFeature.USE_STD_BEAN_NAMING);        String resultXml = xmlMapper.writeValueAsString(object);        return resultXml;    &#125;    public static &lt;T&gt; T xmlToObject(String xml,Class&lt;T&gt; clazz) throws IOException, XMLStreamException &#123;        XmlMapper xmlMapper= new XmlMapper();        xmlMapper.setDefaultUseWrapper(false);        /* 字段为null，自动忽略，不再序列化 */        xmlMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);        /* 设置转换模式 */        xmlMapper.enable(MapperFeature.USE_STD_BEAN_NAMING);        return xmlMapper.readValue(xml, clazz);    &#125;&#125;@JacksonXmlRootElementclass DataList&#123;    @JacksonXmlProperty(isAttribute = true)    private String Airlines;    @JacksonXmlProperty(isAttribute = true)    private String Dpt;    @JacksonXmlProperty(isAttribute = true)    private String Arr;    @JacksonXmlProperty(isAttribute = true)    private String Date;    @JacksonXmlProperty(isAttribute = true)    private String Carrier;    @JacksonXmlProperty(isAttribute = true)    private String Cabin;    @JacksonXmlProperty(isAttribute = true)    private String Code;    public String getAirlines() &#123;        return Airlines;    &#125;    public void setAirlines(String airlines) &#123;        Airlines = airlines;    &#125;    public String getDpt() &#123;        return Dpt;    &#125;    public void setDpt(String dpt) &#123;        Dpt = dpt;    &#125;    public String getArr() &#123;        return Arr;    &#125;    public void setArr(String arr) &#123;        Arr = arr;    &#125;    public String getDate() &#123;        return Date;    &#125;    public void setDate(String date) &#123;        Date = date;    &#125;    public String getCarrier() &#123;        return Carrier;    &#125;    public void setCarrier(String carrier) &#123;        Carrier = carrier;    &#125;    public String getCabin() &#123;        return Cabin;    &#125;    public void setCabin(String cabin) &#123;        Cabin = cabin;    &#125;    public String getCode() &#123;        return Code;    &#125;    public void setCode(String code) &#123;        Code = code;    &#125;    public DataList() &#123;    &#125;&#125;\n\n里面写了一个工具类：objectToXml和xmlToObject可以转换xml和实体类==注意踩坑==\n坑一：大小写问题@JacksonXmlProperty(localName = &quot;Apid&quot;)private Integer Apid;private Integer getApid()&#123;    return this.Apid&#125;把注解放在成员变量上面，会解析出两个apid字段，一个是&lt;Apid&gt;&lt;/Apid&gt;,另一个是&lt;apid&gt;&lt;apid&gt;这是因为Jackson的处理机制会自动从属性方法上获取成员变量名，然而在java中，要么以驼峰命名，要么前两个字母都大写，才能用get方法正确地获取属性，所以使用getApid获取的成员名称就是apid，被jackson解析了出来。又因为成员变量上也加了注解，所以也会被解析。这就造成了xml文件生成了两个apid标签。正确的做法是把注解写到get方法上面正确写法：private Integer Apid;@JacksonXmlProperty(localName = &quot;Apid&quot;)private Integer getApid()&#123;    return this.Apid&#125; 坑二：Jackson封装list问题这个问题排查的时候异常困难……开始以为是封装的问题…………(吐槽一下，这个外包项目使用大量xml交互，但是又用不了webservice就得按照固定格式解析封装xml.....改动也贼困难。。。)……最后还是确定了是jackson的问题private List&lt;Integer&gt; APID;@JacksonXmlProperty(localName = &quot;APID&quot;)@JacksonXmlElementWrapper(useWrapping = false)public List&lt;Integer&gt; getAPID() &#123;return APID;&#125;开始APID这个list一直被包装了两层！正确结果应该是&lt;APID&gt;111&lt;/APID&gt;但是得到的是&lt;APID&gt;&lt;APID&gt;111&lt;/APID&gt;&lt;/APID&gt;问题出在JacksonXmlElementWrapper如果不指定的话这个值默认是true\n\n\n总结\n\n目前感觉解析xml的api还是比较多的，针对xml的各种奇奇怪怪的格式，并不是都能兼容到，目前感觉最好用的还是jackson+Lombok能比较好的快速解决问题，当然要注意lombok的侵入性和jdk的版本选择最好的方式去解决，有些方式虽然不方便，但是它就是能解决问题……\n","tags":["java","xml"]},{"title":"解决微信小程序键盘上移","url":"/2022/02/16/0.0.7%E8%A7%A3%E5%86%B3%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E9%94%AE%E7%9B%98%E4%B8%8A%E7%A7%BB/","content":"在微信开发者工具没有出现上移的情况，但是一到真机调试就出现了，把页面设置固定布局也不管用然后查询微信官方文档，是这样解释的小程序在input框输入时，默认会开启自动上推的功能，但是有的时候会出现卡顿的现象，想关闭自动上推，把adjust-position设置为false就可以了\n&lt;van-row  gutter=&quot;20&quot;&gt;    &lt;van-col span=&quot;24&quot;&gt;       &lt;van-field          left-icon=&quot;eye-o&quot;          adjust-position=&quot;false&quot;           placeholder=&quot;请输入密码&quot;          name=&quot;input&quot;  type=&quot;password&quot;  model:value=&quot;&#123;&#123;password&#125;&#125;&quot;       /&gt;    &lt;/van-col&gt; &lt;/van-row&gt;\n\n按道理应该就不会出现了，结果就是不生效，经过几轮瞎搞后才发现需要加&#123;&#123;&#125;&#125;\n&lt;van-row  gutter=&quot;20&quot;&gt;   &lt;van-col span=&quot;24&quot;&gt;      &lt;van-field         left-icon=&quot;eye-o&quot;         adjust-position=&quot;&#123;&#123; false &#125;&#125;&quot;          placeholder=&quot;请输入密码&quot;         name=&quot;input&quot;  type=&quot;password&quot;  model:value=&quot;&#123;&#123;password&#125;&#125;&quot;      /&gt;   &lt;/van-col&gt;&lt;/van-row&gt;\n请大家谨慎踩坑\n","tags":["小程序"]},{"title":"使用redis实现分布式锁","url":"/2022/03/02/0.0.8%E4%BD%BF%E7%94%A8redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","content":"\nJava中提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下合理选择能展现非常高的效率\n\n分布式锁一般有三种实现方式：数据库乐观锁，Redis分布式锁，Zookeeper分布式锁\n本篇博客主要详细介绍redis分布式锁的进化，进化所解决的场景问题\n可靠性首先，为了确保分布式锁的可用性，我们需要确保锁能同时满足以下四个条件\n\n互斥性:在任意时刻，只有一个客户端能持有锁。\n不会发生死锁:即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。\n具有容错性:只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。\n解铃还须系铃人:加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。\n\n实现原理在单机下可以用synchronized同步代码块加锁\n@Autowiredprivate StringRedisTemplate redisTemplate;@Testpublic void deductStock()&#123;    synchronized (this)&#123;        int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));        if(stock &gt; 0)&#123;            int realStock = stock - 1;            redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);            System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);        &#125;else&#123;            System.out.println(&quot;扣减失败，库存不足&quot;);        &#125;    &#125;&#125;\n\n但是在真实的场景下，往往是多台服务器做负载，而synchronized是进程级别的，只在当前进程有效\n如果是做了负载的服务器，往往控制不住请求，依然会有并发问题，在并发低的情况下可能不会出现问题\n这种情况下就得用分布式锁\n在redis中，利用setnx命令的特性可以轻松实现分布式锁\n\n只在键 key 不存在的情况下，将键 key 的值设置为 value 。若键 key 已经存在， 则 SETNX 命令不做任何动作。\n返回值：命令在设置成功时返回 1 ，设置失败时返回 0 。\n\n\n@Autowiredprivate StringRedisTemplate redisTemplate;@Testpublic void deductStock()&#123;    String locKey = &quot;lockey&quot;;    // 如果存在则true,成功则新增返回false    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, &quot;lock&quot;);    // 如果存在，直接返回失败    if(!result)&#123;        System.out.println(&quot;error_code&quot;);        return    &#125;    int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));    if(stock &gt; 0)&#123;        int realStock = stock - 1;        redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);        System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);    &#125;else&#123;        System.out.println(&quot;扣减失败，库存不足&quot;);    &#125;    // 删除key，表示已经解锁    redisTemplate.delete(locKey);  &#125;\n\n以上代码是简单的redis锁，如果在加锁和解锁中间，出现了异常，则redis里面会一直加上这把锁\n\n所以升级一下，让我们的代码更健壮，使用try catch finally  保证一定会释放锁\n@Autowiredprivate StringRedisTemplate redisTemplate;@Testpublic void deductStock()&#123;    String locKey = &quot;lockey&quot;;    // 如果存在则true,成功则新增返回false    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, &quot;lock&quot;);    // 如果存在，直接返回失败    if(!result)&#123;        System.out.println(&quot;error_code&quot;);    &#125;    try &#123;        int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));        if(stock &gt; 0)&#123;            int realStock = stock - 1;            redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);            System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);        &#125;else&#123;            System.out.println(&quot;扣减失败，库存不足&quot;);        &#125;    &#125;finally &#123;    \t// 删除key，表示已经解锁        redisTemplate.delete(locKey);    &#125;&#125;\n\n如果在这个时候，redis宕机了，依然会出现一直锁死的情况\n\n这个时候我们可以给锁设置一个超时时间，这样可以保证锁自动释放，不会一直锁死\n@Testpublic void deductStock()&#123;    String locKey = &quot;lockey&quot;;    // 如果存在则true,成功则新增返回false    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, &quot;lock&quot;);    // 设置超时时间，防止锁一直不释放    redisTemplate.expire(locKey,10, TimeUnit.SECONDS);    // 如果存在，直接返回失败    if(!result)&#123;        System.out.println(&quot;error_code&quot;);    &#125;    try &#123;        int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));        if(stock &gt; 0)&#123;            int realStock = stock - 1;            redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);            System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);        &#125;else&#123;            System.out.println(&quot;扣减失败，库存不足&quot;);        &#125;    &#125;finally &#123;        // 删除key，表示已经解锁        redisTemplate.delete(locKey);    &#125;&#125;\n\n上面代码看起来没有问题，但是实际会存在原子性问题\n\n这时候我们可以把\nredisTemplate.opsForValue().setIfAbsent(locKey, &quot;lock&quot;);\n\n替换为\nredisTemplate.opsForValue().setIfAbsent(locKey, &quot;lock&quot;,10,TimeUnit.SECONDS);\n\npublic void deductStock()&#123;    String locKey = &quot;lockey&quot;;    // 如果存在则true,成功则新增返回false,设置超时时间，防止锁一直不释放    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, &quot;lock&quot;,10,TimeUnit.SECONDS);    // 如果存在，直接返回失败    if(!result)&#123;        System.out.println(&quot;error_code&quot;);    &#125;    try &#123;        int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));        if(stock &gt; 0)&#123;            int realStock = stock - 1;            redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);            System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);        &#125;else&#123;            System.out.println(&quot;扣减失败，库存不足&quot;);        &#125;    &#125;finally &#123;        // 删除key，表示已经解锁        redisTemplate.delete(locKey);    &#125;&#125;\n\n上面的代码在高并发场景会存在问题\n\n如果存在上面这种情况，则永远加不上锁，前面的用户，会一直释放后面用户的锁，会存在超卖的问题\n这时我们就需要用到uuid来进行加锁解铃还须系铃人\npublic void deductStock()&#123;    String locKey = &quot;lockey&quot;;    // 增加uuid防止被其他用户释放锁    String clientId = UUID.randomUUID().toString();    // 如果存在则true,成功则新增返回false,设置超时时间，防止锁一直不释放    Boolean result = redisTemplate.opsForValue().setIfAbsent(locKey, clientId,10,TimeUnit.SECONDS);    // 如果存在，直接返回失败    if(!result)&#123;        System.out.println(&quot;error_code&quot;);    &#125;    try &#123;        int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));        if(stock &gt; 0)&#123;            int realStock = stock - 1;            redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);            System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);        &#125;else&#123;            System.out.println(&quot;扣减失败，库存不足&quot;);        &#125;    &#125;finally &#123;        // 如果uuid相同则释放锁        if(clientId.equals(redisTemplate.opsForValue().get(locKey)))&#123;            // 删除key，表示已经解锁            redisTemplate.delete(locKey);        &#125;    &#125;&#125;\n\n以上代码解决了锁被其他人释放的问题，但是还是会存在一些问题\n\n很多人想的是对于超时时间，可以设置长一点，但是这种情况治标不治本，还是会有可能出现\n以上这种情况需要用到锁续命，后台开一个定时任务，每过一段时间检查锁的业务是否还在执行，如果没执行完，就重置锁的超时时间\n市面上有很多大牛对于这种情况提供了 解决方案\nRedisson我们可以使用redisson来使用分布式锁，简化了我们加锁的步骤\n&lt;dependency&gt;   &lt;groupId&gt;org.redisson&lt;/groupId&gt;   &lt;artifactId&gt;redisson&lt;/artifactId&gt;   &lt;version&gt;3.16.8&lt;/version&gt;&lt;/dependency&gt;  \n\n@Beanpublic Redisson redisson()&#123;    // 单机模式    Config config = new  Config();    config.useSingleServer().setAddress(&quot;redis://localhost:6379&quot;).setDatabase(0);    return (Redisson)Redisson.create(config);&#125;\n\n代码实现\n@Autowiredprivate Redisson redisson;@Autowiredprivate StringRedisTemplate redisTemplate;@Testpublic void deductStock()&#123;    String locKey = &quot;lockey&quot;;    RLock lock = redisson.getLock(locKey);    try &#123;        // 加锁        lock.lock();        int stock = Integer.parseInt(redisTemplate.opsForValue().get(&quot;stock&quot;));        if(stock &gt; 0)&#123;            int realStock = stock - 1;            redisTemplate.opsForValue().set(&quot;stock&quot;,realStock + &quot;&quot;);            System.out.println(&quot;扣减成功，剩余库存：&quot; + realStock);        &#125;else&#123;            System.out.println(&quot;扣减失败，库存不足&quot;);        &#125;    &#125;finally &#123;        // 解锁        lock.unlock();    &#125;&#125;\n\n主要是通过lua脚本实现代码的原子性\n&lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long waitTime, long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) &#123;        return evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,                &quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot; +                        &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +                        &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +                        &quot;return nil; &quot; +                        &quot;end; &quot; +                        &quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot; +                        &quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot; +                        &quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot; +                        &quot;return nil; &quot; +                        &quot;end; &quot; +                        &quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;,                Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));    &#125;\n\n\n1.加锁机制：\n线程去获取锁，获取成功：执行lua脚本，保存数据到redis数据库\n线程去获取锁，获取失败: 一直通过while循环尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。\n2.看门狗\n在一个分布式环境下，假如一个线程获得锁后，突然服务器宕机了，那么这个时候在一定时间后这个锁会自动释放，你也可以设置锁的有效时间(不设置默认30秒），这样的目的主要是防止死锁的发生。\n //设置锁1秒过去redissonLock.lock(&quot;redisson&quot;, 1);/*** 业务逻辑需要咨询2秒*/redissonLock.release(&quot;redisson&quot;);/*** 线程1 进来获得锁后，线程一切正常并没有宕机，但它的业务逻辑需要执行2秒，这就会有个问题，在 线程1 执行1秒后，这个锁就自动过期了* 那么这个时候 线程2 进来了。那么就存在 线程1和线程2 同时在这段业务逻辑里执行代码，这当然是不合理的。* 而且如果是这种情况，那么在解锁时系统会抛异常，因为解锁和加锁已经不是同一线程了，具体后面代码演示。*/\n\n所以这个时候看门狗就出现了，它的作用就是 线程1 业务还没有执行完，时间就过了，线程1 还想持有锁的话，就会启动一个watch dog后台线程，不断的延长锁key的生存时间。\n注意 正常这个看门狗线程是不启动的，还有就是这个看门狗启动后对整体性能也会有一定影响，所以不建议开启看门狗。\n3.为啥使用lua脚本\n如果你的业务逻辑复杂的话，通过封装在lua脚本中发送给redis，而且redis是单线程的，这样就保证这段复杂业务逻辑执行的原子性。\n4.分布式锁的缺陷\nRedis分布式锁会有个缺陷，就是在Redis哨兵模式下:\n客户端1 对某个master节点写入了redisson锁，此时会异步复制给对应的 slave节点。但是这个过程中一旦发生 master节点宕机，主备切换，slave节点从变为了 master节点。\n这时客户端2 来尝试加锁的时候，在新的master节点上也能加锁，此时就会导致多个客户端对同一个分布式锁完成了加锁。\n这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。\n缺陷在哨兵模式或者主从模式下，如果 master实例宕机的时候，可能导致多个客户端同时完成加锁。\n","tags":["redis","分布式锁"]},{"title":"数据库中间件","url":"/2022/04/17/0.0.9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%97%B4%E4%BB%B6/","content":"数据库中间件Cobar：阿里团队开发，已经多年没有维护更新\nMyCat：基于Cobar二次开发，开源社区维护\nOneProxy：不开源的商业中间件专注性能和稳定性\nKingShard：GO语言开发，在不断完善\nVitess：youtobe生产在使用，不支持MySql原生协议\nAtlas：360团队基于MySqlProxy改写，高并发下不稳定\nMaxScale：MaxScale是mariadb研发的中间件\nMysqlRoute：MySql官方Oracle公司发布的中间件\nShardingJDBC：现在比较主流的中间件\nSQL解析&gt;查询优化&gt;SQL路由&gt;SQL改写&gt;SQL执行&gt;结果归并\n","tags":["分库分表","多数据源","mysql"]},{"title":"线程池工具类","url":"/2022/05/01/0.1.0%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"1.编写线程池工具类public class ThreadUtils &#123;    public static ExecutorService newFixedThreadPool() &#123;        return new ThreadPoolExecutor(4,4, 10L, TimeUnit.MILLISECONDS,                new LinkedBlockingDeque&lt;Runnable&gt;(100),                Executors.defaultThreadFactory(),                new ThreadPoolExecutor.CallerRunsPolicy());    &#125;    /**     * （1.8版本）使用线程池请求接口     */    public static &lt;T&gt; void  executerPool(List&lt;T&gt; list) throws InterruptedException &#123;        ExecutorService executorService = newFixedThreadPool();        List&lt;T&gt; collect = list.stream().filter(l -&gt; l instanceof Runnable).collect(Collectors.toList());        final CountDownLatch count=new CountDownLatch(collect.size());        for (T runnable : collect) &#123;            Customers customers = (Customers) runnable;            customers.counts(count);            executorService.execute(customers);        &#125;        count.await();        executorService.shutdown();    &#125;    /**     * （1.7版本）使用线程池请求接口     */    public static &lt;T&gt; void  executerPool2(List&lt;T&gt; list) throws InterruptedException &#123;        ExecutorService executorService = newFixedThreadPool();        List&lt;Customers&gt; runnables = new ArrayList&lt;&gt;();        for (T t : list) &#123;            if(t instanceof Customers)&#123;                runnables.add((Customers) t);            &#125;        &#125;        final CountDownLatch count=new CountDownLatch(runnables.size());        for (Customers runnable : runnables) &#123;            runnable.counts(count);            executorService.execute(runnable);        &#125;        count.await();        executorService.shutdown();    &#125;&#125;\n\n2.定义接口ThreadFactorys和Customerspublic interface ThreadFactorys&#123;    public abstract void counts(CountDownLatch countDownLatch);&#125;\n\npublic interface Customers extends Runnable,ThreadFactorys&#123;&#125;\n\n3.继承Customerspublic class InterfaceRunnable implements Customers&#123;    private String name;    // 线程计数器    private CountDownLatch count;    public InterfaceRunnable(String name) &#123;        this.name = name;    &#125;    @Override    public void run() &#123;        // 执行方法        System.out.println(name);        count.countDown();    &#125;    @Override    public void counts(CountDownLatch countDownLatch) &#123;        this.count = countDownLatch;    &#125;&#125;\n4.使用工具类进行调用（只需要把需要执行的类继承runnable方法，然后用list丢入工具类就行了）public class ThreadController &#123;    public static void main(String[] args) throws InterruptedException &#123;        List&lt;InterfaceRunnable&gt; list = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; 10; i++) &#123;            list.add(new InterfaceRunnable(&quot;方法调用:&quot;+i));        &#125;        ThreadUtils.executerPool(list);    &#125;&#125;","tags":["工具类","算法公式"]},{"title":"ip地址白名单校验","url":"/2022/04/04/0.1.3ip%E5%9C%B0%E5%9D%80%E7%99%BD%E5%90%8D%E5%8D%95%E6%A0%A1%E9%AA%8C/","content":"package com.service.taobao.util;import org.springframework.context.annotation.Configuration;import javax.servlet.http.HttpServletRequest;import java.util.ArrayList;import java.util.HashSet;import java.util.List;import java.util.Set;import java.util.regex.Pattern;/** * @ClassName WhiteIPInterceptor * @Description //TODO * @Author yinjuan * @Date 2022-01-12 16:45 * @Version 1.0 */public class WhiteIPInterceptor &#123;    // IP的正则    private static Pattern pattern = Pattern            .compile(&quot;(1\\\\d&#123;1,2&#125;|2[0-4]\\\\d|25[0-5]|\\\\d&#123;1,2&#125;)\\\\.&quot; + &quot;(1\\\\d&#123;1,2&#125;|2[0-4]\\\\d|25[0-5]|\\\\d&#123;1,2&#125;)\\\\.&quot;                    + &quot;(1\\\\d&#123;1,2&#125;|2[0-4]\\\\d|25[0-5]|\\\\d&#123;1,2&#125;)\\\\.&quot; + &quot;(1\\\\d&#123;1,2&#125;|2[0-4]\\\\d|25[0-5]|\\\\d&#123;1,2&#125;)&quot;);    private static final String DEFAULT_ALLOW_ALL_FLAG = &quot;*&quot;;\t// 允许所有ip标志位    private static final String DEFAULT_DENY_ALL_FLAG = &quot;0&quot;; \t// 禁止所有ip标志位    /**     * Description: 获取访问的ip地址     * @param request     * @return     */    public static String getIpAddr(HttpServletRequest request) &#123;        String ip = request.getHeader(&quot;X-Forwarded-For&quot;);        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getHeader(&quot;Proxy-Client-IP&quot;);        &#125;        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getHeader(&quot;WL-Proxy-Client-IP&quot;);        &#125;        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getHeader(&quot;HTTP_CLIENT_IP&quot;);        &#125;        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getHeader(&quot;HTTP_X_FORWARDED_FOR&quot;);        &#125;        if (ip == null || ip.length() == 0 || &quot;unknown&quot;.equalsIgnoreCase(ip)) &#123;            ip = request.getRemoteAddr();        &#125;        if (&quot;0:0:0:0:0:0:0:1&quot;.equals(ip)) &#123;            ip = &quot;127.0.0.1&quot;;        &#125;        return ip;    &#125;    /**     * 根据IP白名单设置获取可用的IP列表     * @param allowIp     * @return     */    private static Set&lt;String&gt; getAvaliIpList(String allowIp) &#123;        String[] splitRex = allowIp.split(&quot;;&quot;);// 拆分出白名单正则        Set&lt;String&gt; ipList = new HashSet&lt;String&gt;(splitRex.length);        for (String allow : splitRex) &#123;            allow = allow.trim();            if (allow.contains(&quot;*&quot;)) &#123;// 处理通配符 *                String[] ips = allow.split(&quot;\\\\.&quot;);                String[] from = new String[] &#123; &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot; &#125;;                String[] end = new String[] &#123; &quot;255&quot;, &quot;255&quot;, &quot;255&quot;, &quot;255&quot; &#125;;                List&lt;String&gt; tem = new ArrayList&lt;String&gt;();                for (int i = 0; i &lt; ips.length; i++)                    if (ips[i].indexOf(&quot;*&quot;) &gt; -1) &#123;                        tem = complete(ips[i]);                        from[i] = null;                        end[i] = null;                    &#125; else &#123;                        from[i] = ips[i];                        end[i] = ips[i];                    &#125;                StringBuilder fromIP = new StringBuilder();                StringBuilder endIP = new StringBuilder();                for (int i = 0; i &lt; 4; i++)                    if (from[i] != null) &#123;                        fromIP.append(from[i]).append(&quot;.&quot;);                        endIP.append(end[i]).append(&quot;.&quot;);                    &#125; else &#123;                        fromIP.append(&quot;[*].&quot;);                        endIP.append(&quot;[*].&quot;);                    &#125;                fromIP.deleteCharAt(fromIP.length() - 1);                endIP.deleteCharAt(endIP.length() - 1);                for (String s : tem) &#123;                    String ip = fromIP.toString().replace(&quot;[*]&quot;, s.split(&quot;;&quot;)[0]) + &quot;-&quot;                            + endIP.toString().replace(&quot;[*]&quot;, s.split(&quot;;&quot;)[1]);                    if (validate(ip)) &#123;                        ipList.add(ip);                    &#125;                &#125;            &#125; else if (allow.contains(&quot;/&quot;)) &#123;// 处理 网段 xxx.xxx.xxx./24                ipList.add(allow);            &#125; else &#123;// 处理单个 ip 或者 范围                if (validate(allow)) &#123;                    ipList.add(allow);                &#125;            &#125;        &#125;        return ipList;    &#125;    /**     * \t对单个IP节点进行范围限定     * @param arg     * @return 返回限定后的IP范围，格式为List[10;19, 100;199]     */    private static List&lt;String&gt; complete(String arg) &#123;        List&lt;String&gt; com = new ArrayList&lt;String&gt;();        int len = arg.length();        if (len == 1) &#123;            com.add(&quot;0;255&quot;);        &#125; else if (len == 2) &#123;            String s1 = complete(arg, 1);            if (s1 != null)                com.add(s1);            String s2 = complete(arg, 2);            if (s2 != null)                com.add(s2);        &#125; else &#123;            String s1 = complete(arg, 1);            if (s1 != null)                com.add(s1);        &#125;        return com;    &#125;    private static String complete(String arg, int length) &#123;        String from = &quot;&quot;;        String end = &quot;&quot;;        if (length == 1) &#123;            from = arg.replace(&quot;*&quot;, &quot;0&quot;);            end = arg.replace(&quot;*&quot;, &quot;9&quot;);        &#125; else &#123;            from = arg.replace(&quot;*&quot;, &quot;00&quot;);            end = arg.replace(&quot;*&quot;, &quot;99&quot;);        &#125;        if (Integer.valueOf(from) &gt; 255)            return null;        if (Integer.valueOf(end) &gt; 255)            end = &quot;255&quot;;        return from + &quot;;&quot; + end;    &#125;    /**     *\t 在添加至白名单时进行格式校验     * @param ip     * @return     */    private static boolean validate(String ip) &#123;        String[] temp = ip.split(&quot;-&quot;);        for (String s : temp)            if (!pattern.matcher(s).matches()) &#123;                return false;            &#125;        return true;    &#125;    /**     * \t根据IP,及可用Ip列表来判断ip是否包含在白名单之中     * @param ip     * @param ipList     * @return     */    private static boolean isPermited(String ip, Set&lt;String&gt; ipList) &#123;        if (ipList.isEmpty() || ipList.contains(ip))            return true;        for (String allow : ipList) &#123;            if (allow.indexOf(&quot;-&quot;) &gt; -1) &#123;// 处理 类似 192.168.0.0-192.168.2.1                String[] tempAllow = allow.split(&quot;-&quot;);                String[] from = tempAllow[0].split(&quot;\\\\.&quot;);                String[] end = tempAllow[1].split(&quot;\\\\.&quot;);                String[] tag = ip.split(&quot;\\\\.&quot;);                boolean check = true;                for (int i = 0; i &lt; 4; i++) &#123;// 对IP从左到右进行逐段匹配                    int s = Integer.valueOf(from[i]);                    int t = Integer.valueOf(tag[i]);                    int e = Integer.valueOf(end[i]);                    if (!(s &lt;= t &amp;&amp; t &lt;= e)) &#123;                        check = false;                        break;                    &#125;                &#125;                if (check)                    return true;            &#125; else if (allow.contains(&quot;/&quot;)) &#123;// 处理 网段 xxx.xxx.xxx./24                int splitIndex = allow.indexOf(&quot;/&quot;);                // 取出子网段                String ipSegment = allow.substring(0, splitIndex); // 192.168.3.0                // 子网数                String netmask = allow.substring(splitIndex + 1);// 24                // ip 转二进制                long ipLong = ipToLong(ip);                //子网二进制                long maskLong=(2L&lt;&lt;32 -1) -(2L &lt;&lt; Integer.valueOf(32-Integer.valueOf(netmask))-1);                // ip与和子网相与 得到 网络地址                String calcSegment = longToIP(ipLong &amp; maskLong);                // 如果计算得出网络地址和库中网络地址相同 则合法                if(ipSegment.equals(calcSegment))return true;            &#125;        &#125;        return false;    &#125;    /**     * \t根据IP地址，及IP白名单设置规则判断IP是否包含在白名单     * @param request     * @param ipWhiteConfig     * @return     */    public static boolean isPermitedByRequest(HttpServletRequest request, String ipWhiteConfig) &#123;        String ip = getIpAddr(request);        if (null == ip || &quot;&quot;.equals(ip) || null == ipWhiteConfig)            return false;        //ip格式不对        if(!pattern.matcher(ip).matches()) return false;        if (DEFAULT_ALLOW_ALL_FLAG.equals(ipWhiteConfig))            return true;        if (DEFAULT_DENY_ALL_FLAG.equals(ipWhiteConfig))            return false;        Set&lt;String&gt; ipList = getAvaliIpList(ipWhiteConfig.replaceAll(&quot;；&quot;, &quot;;&quot;));        return isPermited(ip, ipList);    &#125;    /**     * \t根据IP地址，及IP白名单设置规则判断IP是否包含在白名单     * @param ip     * @param ipWhiteConfig     * @return     */    public static boolean isPermited(String ip, String ipWhiteConfig) &#123;        if (null == ip || &quot;&quot;.equals(ip) || null == ipWhiteConfig)            return false;        //ip格式不对        if(!pattern.matcher(ip).matches()) return false;        if (DEFAULT_ALLOW_ALL_FLAG.equals(ipWhiteConfig))            return true;        if (DEFAULT_DENY_ALL_FLAG.equals(ipWhiteConfig))            return false;        Set&lt;String&gt; ipList = getAvaliIpList(ipWhiteConfig.replaceAll(&quot;；&quot;, &quot;;&quot;));        return isPermited(ip, ipList);    &#125;    private static long ipToLong(String strIP) &#123;        long[] ip = new long[4];        // 先找到IP地址字符串中.的位置        int position1 = strIP.indexOf(&quot;.&quot;);        int position2 = strIP.indexOf(&quot;.&quot;, position1 + 1);        int position3 = strIP.indexOf(&quot;.&quot;, position2 + 1);        // 将每个.之间的字符串转换成整型        ip[0] = Long.parseLong(strIP.substring(0, position1));        ip[1] = Long.parseLong(strIP.substring(position1 + 1, position2));        ip[2] = Long.parseLong(strIP.substring(position2 + 1, position3));        ip[3] = Long.parseLong(strIP.substring(position3 + 1));        return (ip[0] &lt;&lt; 24) + (ip[1] &lt;&lt; 16) + (ip[2] &lt;&lt; 8) + ip[3];    &#125;    // 将10进制整数形式转换成127.0.0.1形式的IP地址    private static String longToIP(long longIP) &#123;        StringBuilder sb = new StringBuilder(&quot;&quot;);        // 直接右移24位        sb.append(String.valueOf(longIP &gt;&gt;&gt; 24));        sb.append(&quot;.&quot;);        // 将高8位置0，然后右移16位        sb.append(String.valueOf((longIP &amp; 0x00FFFFFF) &gt;&gt;&gt; 16));        sb.append(&quot;.&quot;);        sb.append(String.valueOf((longIP &amp; 0x0000FFFF) &gt;&gt;&gt; 8));        sb.append(&quot;.&quot;);        sb.append(String.valueOf(longIP &amp; 0x000000FF));        return sb.toString();    &#125;    public static void main(String[] args) &#123;        String ipWhilte = &quot;1.168.1.1;&quot; //设置单个IP的白名单 //                + &quot;192.*； &quot; //设置ip通配符,对一个ip段进行匹配                + &quot;192.168.1.1-192.168.1.3； &quot; //设置一个IP范围                + &quot;25.168.4.0/24 &quot;; //設置一个网段        System.out.println(WhiteIPInterceptor.isPermited(&quot;192.168.1.1&quot;,ipWhilte));//true    &#125;&#125;","tags":["java","ip","白名单","校验"]},{"title":"java文件用GZip压缩gz","url":"/2022/04/04/0.1.4java%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/","content":"描述：利用Gzip进行文件压缩\npackage com.util;import java.io.*;import java.util.zip.GZIPInputStream;import java.util.zip.GZIPOutputStream;public class GZipUtils &#123;    public static final int BUFFER = 1024;    public static final String EXT = &quot;.gz&quot;;   public static void main(String[] args) throws Exception &#123;       String userHome = System.getProperties().getProperty(&quot;user.home&quot;); // 用户目录，如：C:\\Users\\chushiyun       String fileName = userHome+&quot;/01.jpg&quot;; // 用户目录下的01.jpg 会被压缩成01.jpg.gz       compress(new File(fileName));   &#125;    /**     * 数据压缩     *     * @param data     * @return     * @throws Exception     */    public static byte[] compress(byte[] data) throws Exception &#123;        ByteArrayInputStream bais = new ByteArrayInputStream(data);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        // 压缩        compress(bais, baos);        byte[] output = baos.toByteArray();        baos.flush();        baos.close();        bais.close();        return output;    &#125;    /**     * 文件压缩     *     * @param file     * @throws Exception     */    public static void compress(File file) throws Exception &#123;        compress(file, true);    &#125;    /**     * 文件压缩     *     * @param file     * @param delete     *            是否删除原始文件     * @throws Exception     */    public static void compress(File file, boolean delete) throws Exception &#123;        FileInputStream fis = new FileInputStream(file);        FileOutputStream fos = new FileOutputStream(file.getPath() + EXT);        compress(fis, fos);        fis.close();        fos.flush();        fos.close();        if (delete) &#123;            file.delete();        &#125;    &#125;    /**     * 数据压缩     *     * @param is     * @param os     * @throws Exception     */    public static void compress(InputStream is, OutputStream os)            throws Exception &#123;        GZIPOutputStream gos = new GZIPOutputStream(os);        int count;        byte data[] = new byte[BUFFER];        while ((count = is.read(data, 0, BUFFER)) != -1) &#123;            gos.write(data, 0, count);        &#125;        gos.finish();        gos.flush();        gos.close();    &#125;    /**     * 文件压缩     *     * @param path     * @throws Exception     */    public static void compress(String path) throws Exception &#123;        compress(path, true);    &#125;    /**     * 文件压缩     *     * @param path     * @param delete     *            是否删除原始文件     * @throws Exception     */    public static void compress(String path, boolean delete) throws Exception &#123;        File file = new File(path);        compress(file, delete);    &#125;    /**     * 数据解压缩     *     * @param data     * @return     * @throws Exception     */    public static byte[] decompress(byte[] data) throws Exception &#123;        ByteArrayInputStream bais = new ByteArrayInputStream(data);        ByteArrayOutputStream baos = new ByteArrayOutputStream();        // 解压缩        decompress(bais, baos);        data = baos.toByteArray();        baos.flush();        baos.close();        bais.close();        return data;    &#125;    /**     * 文件解压缩     *     * @param file     * @throws Exception     */    public static void decompress(File file) throws Exception &#123;        decompress(file, true);    &#125;    /**     * 文件解压缩     *     * @param file     * @param delete     *            是否删除原始文件     * @throws Exception     */    public static void decompress(File file, boolean delete) throws Exception &#123;        FileInputStream fis = new FileInputStream(file);        FileOutputStream fos = new FileOutputStream(file.getPath().replace(EXT,                &quot;&quot;));        decompress(fis, fos);        fis.close();        fos.flush();        fos.close();        if (delete) &#123;            file.delete();        &#125;    &#125;    /**     * 数据解压缩     *     * @param is     * @param os     * @throws Exception     */    public static void decompress(InputStream is, OutputStream os)            throws Exception &#123;        GZIPInputStream gis = new GZIPInputStream(is);        int count;        byte data[] = new byte[BUFFER];        while ((count = gis.read(data, 0, BUFFER)) != -1) &#123;            os.write(data, 0, count);        &#125;        gis.close();    &#125;    /**     * 文件解压缩     *     * @param path     * @throws Exception     */    public static void decompress(String path) throws Exception &#123;        decompress(path, true);    &#125;    /**     * 文件解压缩     *     * @param path     * @param delete     *            是否删除原始文件     * @throws Exception     */    public static void decompress(String path, boolean delete) throws Exception &#123;        File file = new File(path);        decompress(file, delete);    &#125;&#125;","tags":["java","gzip","压缩"]},{"title":"mysql创建定时任务","url":"/2022/04/23/0.1.6mysql%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","content":"\n需求：定时删除三个月之前的数据\n\n1.编写需要执行的sql语句\n## 因为表数据过大（大约2亿数据），需要先查询三个月之前的id节点，增加查询速度select MAX(id) from other_log_info where DATE_FORMAT(createtime,&#x27;%Y-%m-%d&#x27;) = DATE_SUB(CURDATE(),INTERVAL 3 MONTH);## 查询的sql一次不能删除太多数据，防止锁表select * from other_log_info where id &lt; (select MAX(id) from other_log_info where DATE_FORMAT(createtime,&#x27;%Y-%m-%d&#x27;) = DATE_SUB(CURDATE(),INTERVAL 3 MONTH)) LIMIT 0,1000## 由于delete不能直接删除子查询表中的数据，必须用过嵌套一层的方式来解决## 第二种执行方式，如果对于sql比较熟悉，可以用存储过程的&quot;游标&quot;进行循环DELETE FROM other_log_info where id in \t(select t2.id from \t\t(select id from other_log_info where \t\t\tid &lt; (select MAX(id) from other_log_info where createtime &lt; DATE_SUB(CURDATE(),INTERVAL 3 MONTH)) LIMIT 0,1000) t2)\n\n游标使用方式：https://www.cnblogs.com/cbt-home/p/15269736.html\n\nCURDATE() 返回当前日期\nCURNOW() 返回当前datetime\nINTERVAL 是mysql间隔值，用法为INTERVAL expr unit。INTERVAL 3 DAY表示三天的间隔\nDATE_SUB(start_date,INTERVAL expr unit);\n\n2.编写存储过程\n存储过程相当于mysql的函数，它是存储在数据库服务器中的一组sql语句，通过调用这个函数的名称来执行这些sql语句命令。\n-- 分隔符切换防止“;”直接分隔了DELIMITER //-- 创建存储过程CREATE procedure del_log2()BEGIN\tSELECT * FROM xxl_job_log WHERE trigger_time &lt; DATE_SUB(CURDATE(),INTERVAL 5 MONTH);END //DELIMITER ;\n\n\nDELIMITER是分割符的意思，声明存储过程前将&quot;//&quot;声明为分隔符，这样存储过程中的“;”才不会被当作分隔符处理。声明结束后再还原分隔符。\n存储过程也可以带参数，存储过程名(参数)\n在声明存储过程前要先用use database_name切换到想要应用的数据库，否则存储过程会应用到默认数据库中\n\n查看存储过程\n-- db指的数据库名select * from mysql.proc where db = &quot;xxl_job&quot;\n\n调用存储过程\ncall del_log();\n\n3.编写事件调度器（定时任务）\n-- 确认是否开启事件调度器SHOW VARIABLES LIKE &#x27;event_scheduler&#x27;;-- 开启事件调度器SET GLOBAL event_scheduler = ON;\n\n创建事件\n-- 创建调度任务(从2022-4-22开始，每天执行一次del_data())create event del_event  on schedule EVERY 1 day  STARTS &#x27;2022-4-22 00:00:00&#x27; do call del_data()\n\n查看事件\n-- 查看事件SHOW EVENTS;\n\n\n\n\n","tags":["mysql","定时任务"]},{"title":"mycat简单介绍","url":"/2022/04/17/0.1.5mycat%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","content":"MyCat介绍\n如今随着互联网的发展，数据的量级也是成指数式的增长，从GB到TB到PB。对数据的各种操作也是愈加的困难，传统的关系性数据库已经无法满足快速查询与插入数据的需求,这个时候NoSQL的出现暂时解决了这一危机。它通过降低数据的安全性，减少对事务的支持，减少对复杂查询的支持，来获取性能上的提升。但是，在有些场合NoSQL一些折衷是无法满足使用场景的，就比如有些使用场景是绝对要有事务与安全指标的。这个时候NoSQL肯定是无法满足的，所以还是需要使用关系性数据库。如何使用关系型数据库解决海量存储的问题呢？此时就需要做数据库集群，为了提高查询性能将一个数据库的数据分散到不同的数据库中存储，为应对此问题就出现了——MyCat 。\n\nMyCAT的目标是：低成本的将现有的单机数据库和应用平滑迁移到”云”端，解决海量数据存储和业务规模迅速增长情况下的数据存储和访问的瓶颈问题 。\nMycat 背后是阿里曾经开源的知名产品——Cobar，Cobar 的核心功能和优势是 MySQL 数据库分片\n相对于cobar的优势\n\n对 cobar 的代码进行了彻底的重构，Mycat在I/O方面进行了重大改进,将原来的BIO改成了NIO, 并发量有大幅提高 \n增加了对Order By、Group By、limit等聚合功能的支持，同时兼容绝大多数数据库成为通用的数据库中间件\n对于开发人员来说根本感觉不到mycat的存在\n\nMyCat发展到目前的版本，已经不是一个单纯的MySQL代理了，它的后端可以支持MySQL、SQL Server、Oracle、DB2、PostgreSQL等主流数据库，也支持MongoDB这种新型NoSQL方式的存储，未来还会支持更多类型的存储。而在最终用户看来，无论是那种存储方式，在MyCat里，都是一个传统的数据库表，支持标准的SQL语句进行数据的操作，这样一来，对前端业务系统来说，可以大幅降低开发难度，提升开发速度\nMyCat使用场景1.高可用性与MySQL读写分离高可用：利用MyCat可以轻松实现热备份，当一台服务器停机时，可以由集群中的另一台服务器自动接管业务，无需人工干预，从而保证高可用。\n读写分离：通过MySQL数据库的binlog日志完成主从复制，并可以通过MyCat轻松实现读写分离，实现insert、update、delete走主库，而在select时走从库，从而缓解单台服务器的访问压力。\n2. 业务数据分级存储保障企业的数据量总是无休止的增长，这些数据的格式不一样，访问效率不一样，重要性也不一样。可以针对不同级别的数据，采用不同的存储设备，通过分级存储管理软件实现数据客体在存储设备之间自动迁移及自动访问切换\n3.大表水平拆分，集群并行计算数据切分是MyCat的核心功能，是指通过某种特定的条件，将存放在同一个数据库的数据，分散存储在多个数据库中，以达到分散单台设备负载的效果。当数据库量超过800万行且需要做分片时，就可以考虑使用MyCat实现数据切分。\n4.数据库路由器MyCat基于MySQL实例的连接池复用机制，可以让每个应用最大程度共享一个MySQL实例的所有连接池，让数据库的并发访问能力大大提升。\n5.整合多种数据源当一个项目中使用了多个数据库（Oracle，MySQL，SQL Server,PostgreSQL），并配置了多个数据源，操作起来就比较繁琐，这时就可以使用MyCat进行整合，最终我们的应用程序只需要访问一个数据源即可\nMyCat原理\nMyCat相当于MySQL的Server层\nMySQL相当于MyCat的存储层\n\n\n拦截：拦截用户发送的sql\n分析：分析分片，路由分析，读写分离分析，缓存分析\n分发：根据分片规则分发给对应的数据源\n拼接：把各数据源返回的结果聚合\n\nMyCat对于研发来说是透明的\nMyCat使用下载地址: https://github.com/MyCATApache/Mycat-download\n最新下载地址: http://dl.mycat.io/\n\n配置schema.xml\nschema.xml 作为MyCat中重要的配置文件之一，管理着MyCat的逻辑库、逻辑表以及对应的分片规则、DataNode以及DataSource。弄懂这些配置，是正确使用MyCat的前提。这里就一层层对该文件进行解析。\n\n\n\n\n属性\n含义\n\n\n\nschema\n标签用于定义MyCat实例中的逻辑库\n\n\ntable\n标签定义了MyCat中的逻辑表, rule用于指定分片规则，auto-sharding-long的分片规则是按ID值的范围进行分片 1-5000000 为第1片  5000001-10000000 为第2片….  具体设置我们会在第四节中讲解。\n\n\ndataNode\n标签定义了MyCat中的数据节点，也就是我们通常说所的数据分片。\n\n\ndataHost\n标签在mycat逻辑库中也是作为最底层的标签存在，直接定义了具体的数据库实例、读写分离配置和心跳语句。\n\n\nschema.xml文件配置(可根据自己的需求加减配置)\n&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE mycat:schema SYSTEM &quot;schema.dtd&quot;&gt;&lt;mycat:schema xmlns:mycat=&quot;http://io.mycat/&quot;&gt;    &lt;!-- 逻辑库配置 --&gt;\t&lt;schema name=&quot;ITCAST&quot; checkSQLschema=&quot;false&quot; sqlMaxLimit=&quot;100&quot;&gt;        &lt;!-- 逻辑表配置 --&gt;\t\t&lt;table name=&quot;TB_TEST&quot; dataNode=&quot;dn1,dn2,dn3&quot; rule=&quot;auto-sharding-long&quot; /&gt;\t&lt;/schema&gt;        &lt;!-- 数据节点配置 --&gt;\t&lt;dataNode name=&quot;dn1&quot; dataHost=&quot;host1&quot; database=&quot;db1&quot; /&gt;\t&lt;dataNode name=&quot;dn2&quot; dataHost=&quot;host2&quot; database=&quot;db1&quot; /&gt;\t&lt;dataNode name=&quot;dn3&quot; dataHost=&quot;host3&quot; database=&quot;db1&quot; /&gt;        &lt;!-- 节点主机配置 --&gt;\t&lt;dataHost name=&quot;host1&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;\t\twriteType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;\t\t&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;\t\t&lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.192.157:3306&quot; user=&quot;root&quot; password=&quot;itcast&quot;&gt;&lt;/writeHost&gt;\t&lt;/dataHost&gt;\t        &lt;dataHost name=&quot;host2&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;\t\twriteType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;\t\t&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;\t\t&lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.192.158:3306&quot; user=&quot;root&quot; password=&quot;itcast&quot;&gt;&lt;/writeHost&gt;\t&lt;/dataHost&gt;\t        &lt;dataHost name=&quot;host3&quot; maxCon=&quot;1000&quot; minCon=&quot;10&quot; balance=&quot;0&quot;\t\twriteType=&quot;0&quot; dbType=&quot;mysql&quot; dbDriver=&quot;native&quot; switchType=&quot;1&quot;  slaveThreshold=&quot;100&quot;&gt;\t\t&lt;heartbeat&gt;select user()&lt;/heartbeat&gt;\t\t&lt;writeHost host=&quot;hostM1&quot; url=&quot;192.168.192.159:3306&quot; user=&quot;root&quot; password=&quot;itcast&quot;&gt;&lt;/writeHost&gt;\t&lt;/dataHost&gt;\t    &lt;/mycat:schema&gt;\n\n配置详解\nsystem标签\n\n\n属性\n取值\n含义\n\n\n\ncharset\nutf8\n设置Mycat的字符集, 字符集需要与MySQL的字符集保持一致\n\n\nnonePasswordLogin\n0,1\n0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户\n\n\nuseHandshakeV10\n0,1\n使用该选项主要的目的是为了能够兼容高版本的jdbc驱动, 是否采用HandshakeV10Packet来与client进行通信, 1:是, 0:否\n\n\nuseSqlStat\n0,1\n开启SQL实时统计, 1 为开启 , 0 为关闭 ;开启之后, MyCat会自动统计SQL语句的执行情况 ;mysql -h 127.0.0.1 -P 9066 -u root -p查看MyCat执行的SQL, 执行效率比较低的SQL , SQL的整体执行情况、读写比例等 ;show @@sql ; show @@sql.slow ; show @@sql.sum ;\n\n\nuseGlobleTableCheck\n0,1\n是否开启全局表的一致性检测。1为开启 ，0为关闭 。\n\n\nsqlExecuteTimeout\n1000\nSQL语句执行的超时时间 , 单位为 s ;\n\n\nsequnceHandlerType\n0,1,2\n用来指定Mycat全局序列类型，0 为本地文件，1 为数据库方式，2 为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试\n\n\nsequnceHandlerPattern\n正则表达式\n必须带有MYCATSEQ_或者 mycatseq_进入序列匹配流程 注意MYCATSEQ_有空格的情况\n\n\nsubqueryRelationshipCheck\ntrue,false\n子查询中存在关联查询的情况下,检查关联字段中是否有分片字段 .默认 false\n\n\nuseCompression\n0,1\n开启mysql压缩协议 , 0 : 关闭, 1 : 开启\n\n\nfakeMySQLVersion\n5.5,5.6\n设置模拟的MySQL版本号\n\n\ndefaultSqlParser\n\n由于MyCat的最初版本使用了FoundationDB的SQL解析器, 在MyCat1.3后增加了Druid解析器, 所以要设置defaultSqlParser属性来指定默认的解析器; 解析器有两个 : druidparser 和 fdbparser, 在MyCat1.4之后,默认是druidparser, fdbparser已经废除了\n\n\nprocessors\n1,2….\n指定系统可用的线程数量, 默认值为CPU核心 x 每个核心运行线程数量; processors 会影响processorBufferPool, processorBufferLocalPercent, processorExecutor属性, 所有, 在性能调优时, 可以适当地修改processors值\n\n\nprocessorBufferChunk\n\n指定每次分配Socket Direct Buffer默认值为4096字节, 也会影响BufferPool长度, 如果一次性获取字节过多而导致buffer不够用, 则会出现警告, 可以调大该值\n\n\nprocessorExecutor\n\n指定NIOProcessor上共享 businessExecutor固定线程池的大小; MyCat把异步任务交给 businessExecutor线程池中, 在新版本的MyCat中这个连接池使用频次不高, 可以适当地把该值调小\n\n\npacketHeaderSize\n\n指定MySQL协议中的报文头长度, 默认4个字节\n\n\nmaxPacketSize\n\n指定MySQL协议可以携带的数据最大大小, 默认值为16M\n\n\nidleTimeout\n30\n指定连接的空闲时间的超时长度;如果超时,将关闭资源并回收, 默认30分钟\n\n\ntxIsolation\n1,2,3,4\n初始化前端连接的事务隔离级别,默认为 REPEATED_READ , 对应数字为3READ_UNCOMMITED=1;READ_COMMITTED=2;REPEATED_READ=3;SERIALIZABLE=4;\n\n\nsqlExecuteTimeout\n300\n执行SQL的超时时间, 如果SQL语句执行超时,将关闭连接; 默认300秒;\n\n\nserverPort\n8066\n定义MyCat的使用端口, 默认8066\n\n\nmanagerPort\n9066\n定义MyCat的管理端口, 默认9066\n\n\nserver.xml配置\nserver.xml几乎保存了所有mycat需要的系统配置信息。最常用的是在此配置用户名、密码及权限。在system中添加UTF-8字符集设置，否则存储中文会出现问号\n\n&lt;property name=&quot;charset&quot;&gt;utf8&lt;/property&gt;\n\n修改user的设置 ,  我们这里为 ITCAST 设置了两个用户 : \n&lt;user name=&quot;root&quot;&gt;    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;    &lt;property name=&quot;schemas&quot;&gt;ITCAST&lt;/property&gt;&lt;/user&gt;&lt;user name=&quot;test&quot;&gt;    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;    &lt;property name=&quot;schemas&quot;&gt;ITCAST&lt;/property&gt;&lt;/user&gt;\n\nuser标签&lt;user name=&quot;root&quot; defaultAccount=&quot;true&quot;&gt;    &lt;property name=&quot;password&quot;&gt;123456&lt;/property&gt;    &lt;property name=&quot;schemas&quot;&gt;ITCAST&lt;/property&gt;    &lt;property name=&quot;readOnly&quot;&gt;true&lt;/property&gt;    &lt;property name=&quot;benchmark&quot;&gt;1000&lt;/property&gt;    &lt;property name=&quot;usingDecrypt&quot;&gt;0&lt;/property&gt;        &lt;!-- 表级 DML 权限设置 --&gt;    &lt;!-- \t\t    &lt;privileges check=&quot;false&quot;&gt;        &lt;schema name=&quot;TESTDB&quot; dml=&quot;0110&quot; &gt;            &lt;table name=&quot;tb01&quot; dml=&quot;0000&quot;&gt;&lt;/table&gt;            &lt;table name=&quot;tb02&quot; dml=&quot;1111&quot;&gt;&lt;/table&gt;        &lt;/schema&gt;    &lt;/privileges&gt;\t\t    --&gt;&lt;/user&gt;\n\nuser标签主要用于定义登录MyCat的用户和权限 :\n1). &lt;user name=”root” defaultAccount=”true”&gt; : name 属性用于声明用户名 ;\n2). &lt;property name=”password”&gt;123456&lt;/property&gt; : 指定该用户名访问MyCat的密码 ;\n3). &lt;property name=”schemas”&gt;ITCAST&lt;/property&gt; : 能够访问的逻辑库, 多个的话, 使用 “,” 分割\n4). &lt;property name=”readOnly”&gt;true&lt;/property&gt; : 是否只读\n5). &lt;property name=”benchmark”&gt;11111&lt;/property&gt; : 指定前端的整体连接数量 , 0 或不设置表示不限制 \n6). &lt;property name=”usingDecrypt”&gt;0&lt;/property&gt; : 是否对密码加密默认 0 否 , 1 是\njava -cp Mycat-server-1.6.7.3-release.jar io.mycat.util.DecryptUtil 0:root:123456\n\n7). &lt;privileges check=”false”&gt;\nA. 对用户的 schema 及 下级的 table 进行精细化的 DML 权限控制; \nB. privileges 节点中的 check 属性是用 于标识是否开启 DML 权限检查， 默认 false 标识不检查，当然 privileges 节点不配置，等同 check=false, 由于 Mycat 一个用户的 schemas 属性可配置多个 schema ，所以 privileges 的下级节点 schema 节点同样 可配置多个，对多库多表进行细粒度的 DML 权限控制;\nC. 权限修饰符四位数字(0000 - 1111)，对应的操作是 IUSD ( 增，改，查，删 )。同时配置了库跟表的权限，就近原则。以表权限为准。\nfirewall 标签firewall标签用来定义防火墙；firewall下whitehost标签用来定义 IP白名单 ，blacklist用来定义 SQL黑名单。\n&lt;firewall&gt;    &lt;!-- 白名单配置 --&gt;    &lt;whitehost&gt;        &lt;host user=&quot;root&quot; host=&quot;127.0.0.1&quot;&gt;&lt;/host&gt;    &lt;/whitehost&gt;    &lt;!-- 黑名单配置 --&gt;    &lt;blacklist check=&quot;true&quot;&gt;        &lt;property name=&quot;selelctAllow&quot;&gt;false&lt;/property&gt;    &lt;/blacklist&gt;&lt;/firewall&gt;\n\n黑名单拦截明细配置:\n\n\n\n配置项\n缺省值\n描述\n\n\n\nselelctAllow\ntrue\n是否允许执行 SELECT 语句\n\n\nselectAllColumnAllow\ntrue\n是否允许执行 SELECT * FROM T 这样的语句。如果设置为 false，不允许执行 select * from t，但可以select * from (select id, name from t) a。这个选项是防御程序通过调用 select * 获得数据表的结构信息。\n\n\nselectIntoAllow\ntrue\nSELECT 查询中是否允许 INTO 字句\n\n\ndeleteAllow\ntrue\n是否允许执行 DELETE 语句\n\n\nupdateAllow\ntrue\n是否允许执行 UPDATE 语句\n\n\ninsertAllow\ntrue\n是否允许执行 INSERT 语句\n\n\nreplaceAllow\ntrue\n是否允许执行 REPLACE 语句\n\n\nmergeAllow\ntrue\n是否允许执行 MERGE 语句，这个只在 Oracle 中有用\n\n\ncallAllow\ntrue\n是否允许通过 jdbc 的 call 语法调用存储过程\n\n\nsetAllow\ntrue\n是否允许使用 SET 语法\n\n\ntruncateAllow\ntrue\ntruncate 语句是危险，缺省打开，若需要自行关闭\n\n\ncreateTableAllow\ntrue\n是否允许创建表\n\n\nalterTableAllow\ntrue\n是否允许执行 Alter Table 语句\n\n\ndropTableAllow\ntrue\n是否允许修改表\n\n\ncommentAllow\nfalse\n是否允许语句中存在注释，Oracle 的用户不用担心，Wall 能够识别 hints和注释的区别\n\n\nnoneBaseStatementAllow\nfalse\n是否允许非以上基本语句的其他语句，缺省关闭，通过这个选项就能够屏蔽 DDL。\n\n\nmultiStatementAllow\nfalse\n是否允许一次执行多条语句，缺省关闭\n\n\nuseAllow\ntrue\n是否允许执行 mysql 的 use 语句，缺省打开\n\n\ndescribeAllow\ntrue\n是否允许执行 mysql 的 describe 语句，缺省打开\n\n\nshowAllow\ntrue\n是否允许执行 mysql 的 show 语句，缺省打开\n\n\ncommitAllow\ntrue\n是否允许执行 commit 操作\n\n\nrollbackAllow\ntrue\n是否允许执行 roll back 操作\n\n\n拦截配置－永真条件\n\n\n\n\nselectWhereAlwayTrueCheck\ntrue\n检查 SELECT 语句的 WHERE 子句是否是一个永真条件\n\n\nselectHavingAlwayTrueCheck\ntrue\n检查 SELECT 语句的 HAVING 子句是否是一个永真条件\n\n\ndeleteWhereAlwayTrueCheck\ntrue\n检查 DELETE 语句的 WHERE 子句是否是一个永真条件\n\n\ndeleteWhereNoneCheck\nfalse\n检查 DELETE 语句是否无 where 条件，这是有风险的，但不是 SQL 注入类型的风险\n\n\nupdateWhereAlayTrueCheck\ntrue\n检查 UPDATE 语句的 WHERE 子句是否是一个永真条件\n\n\nupdateWhereNoneCheck\nfalse\n检查 UPDATE 语句是否无 where 条件，这是有风险的，但不是SQL 注入类型的风险\n\n\nconditionAndAlwayTrueAllow\nfalse\n检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永真条件\n\n\nconditionAndAlwayFalseAllow\nfalse\n检查查询条件(WHERE/HAVING 子句)中是否包含 AND 永假条件\n\n\nconditionLikeTrueAllow\ntrue\n检查查询条件(WHERE/HAVING 子句)中是否包含 LIKE 永真条件\n\n\n其他拦截配置\n\n\n\n\nselectIntoOutfileAllow\nfalse\nSELECT … INTO OUTFILE 是否允许，这个是 mysql 注入攻击的常见手段，缺省是禁止的\n\n\nselectUnionCheck\ntrue\n检测 SELECT UNION\n\n\nselectMinusCheck\ntrue\n检测 SELECT MINUS\n\n\nselectExceptCheck\ntrue\n检测 SELECT EXCEPT\n\n\nselectIntersectCheck\ntrue\n检测 SELECT INTERSECT\n\n\nmustParameterized\nfalse\n是否必须参数化，如果为 True，则不允许类似 WHERE ID = 1 这种不参数化的 SQL\n\n\nstrictSyntaxCheck\ntrue\n是否进行严格的语法检测，Druid SQL Parser 在某些场景不能覆盖所有的SQL 语法，出现解析 SQL 出错，可以临时把这个选项设置为 false，同时把 SQL 反馈给 Druid 的开发者。\n\n\nconditionOpXorAllow\nfalse\n查询条件中是否允许有 XOR 条件。XOR 不常用，很难判断永真或者永假，缺省不允许。\n\n\nconditionOpBitwseAllow\ntrue\n查询条件中是否允许有”&amp;”、”~”、”|”、”^”运算符。\n\n\nconditionDoubleConstAllow\nfalse\n查询条件中是否允许连续两个常量运算表达式\n\n\nminusAllow\ntrue\n是否允许 SELECT * FROM A MINUS SELECT * FROM B 这样的语句\n\n\nintersectAllow\ntrue\n是否允许 SELECT * FROM A INTERSECT SELECT * FROM B 这样的语句\n\n\nconstArithmeticAllow\ntrue\n拦截常量运算的条件，比如说 WHERE FID = 3 - 1，其中”3 - 1”是常量运算表达式。\n\n\nlimitZeroAllow\nfalse\n是否允许 limit 0 这样的语句\n\n\n禁用对象检测配置\n\n\n\n\ntableCheck\ntrue\n检测是否使用了禁用的表\n\n\nschemaCheck\ntrue\n检测是否使用了禁用的 Schema\n\n\nfunctionCheck\ntrue\n检测是否使用了禁用的函数\n\n\nobjectCheck\ntrue\n检测是否使用了“禁用对对象”\n\n\nvariantCheck\ntrue\n检测是否使用了“禁用的变量”\n\n\nreadOnlyTables\n空\n指定的表只读，不能够在 SELECT INTO、DELETE、UPDATE、INSERT、MERGE 中作为”被修改表”出现\n\n\n启动Mycatbin/mycat startbin/mycat stopbin/mycat status\n\n启动后用mysql链接工具直接连就可以了\n\n分片测试进入mycat ，执行下列语句创建一个表\nCREATE TABLE TB_TEST (  id BIGINT(20) NOT NULL,  title VARCHAR(100) NOT NULL ,  PRIMARY KEY (id)) ENGINE=INNODB DEFAULT CHARSET=utf8 ;\n\n\n\n我们再查看MySQL的3个库，发现表都自动创建好了\n接下来是插入表数据，注意，在写 INSERT 语句时一定要写把字段列表写出来，否则会出现下列错误提示：\n错误代码： 1064\npartition table, insert must provide ColumnList\n我们试着插入一些数据：\nINSERT INTO TB_TEST(ID,TITLE) VALUES(1,&#x27;goods1&#x27;);INSERT INTO TB_TEST(ID,TITLE) VALUES(2,&#x27;goods2&#x27;);INSERT INTO TB_TEST(ID,TITLE) VALUES(3,&#x27;goods3&#x27;);\n\n我们会发现这些数据被写入到第一个节点中了，那什么时候数据会写到第二个节点中呢？\n我们插入下面的数据就可以插入第二个节点了\nINSERT INTO TB_TEST(ID,TITLE) VALUES(5000001,&#x27;goods5000001&#x27;);\n\n因为我们采用的分片规则是每节点存储500万条数据，所以当ID大于5000000则会存储到第二个节点上。\n目前只设置了两个节点，如果数据大于1000万条，会怎么样呢？执行下列语句测试一下\nINSERT INTO TB_TEST(ID,TITLE) VALUES(10000001,&#x27;goods10000001&#x27;);\n\nMyCat原理MyCat原理中最重要的一个动词就是 “拦截”, 它拦截了用户发送过来的SQL语句, 首先对SQL语句做一些特定的分析,如分片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL语句发往后端的真实数据库，并将返回的结果做适当处理，最终再返回给用户，如图所示。\n\n在图中,user表被分为三个分片节点dn1、dn2、dn3, 他们分布式在三个MySQL Server(dataHost)上，因此可以使用1-N台服务器来分片,分片规则(sharding rule)为典型的字符串枚举分片规则, 一个规则的定义是分片字段+分片函数。这里的分片字段为 status，分片函数则为字符串枚举方式。\nMyCat收到一条SQL语句时，首先解析SQL语句涉及到的表，接着查看此表的定义，如果该表存在分片规则，则获取SQL语句里分片字段的值，并匹配分片函数，得到该SQL语句对应的分片列表，然后将SQL语句发送到相应的分片去执行，最后处理所有分片返回的数据并返回给客户端。以”select * from user where status=’0’” 为例, 查找 status=’0’ ,按照分片函数, ‘0’ 值存放在dn1,于是SQL语句被发送到第一个节点中执行, 然后再将查询的结果返回给用户。\n如果发送的SQL语句为 “select * from user where status in (‘0’,’1’)” , 那么SQL语句会被发送到dn1,dn2对应的主机上执行, 然后将结果集合并后输出给用户。\n小结mycat相对于shardingjdbc可以单独运行，让开发感觉不到它的存在，可以多数据源之间交互，只需要连mycat一个数据源就行了，也可以加监控Mycat-web\nMycat-web 是 Mycat 可视化运维的管理和监控平台，弥补了 Mycat 在监控上的空白。帮 Mycat 分担统计任务和配置管理任务。Mycat-web 引入了 ZooKeeper 作为配置中心，可以管理多个节点。Mycat-web 主要管理和监控 Mycat 的流量、连接、活动线程和内存等，具备 IP 白名单、邮件告警等模块，还可以统计 SQL 并分析慢 SQL 和高频 SQL 等。为优化 SQL 提供依据。\n\nmycat现在强推mycat2，缺点就是文档还在完善中，不够完全，不过相对于mycat1，在配置方面优化的更加简单容易入手了。 建议从mycat1慢慢学上去\n","tags":["分库分表","多数据源","mysql"]},{"title":"自定义注解","url":"/2022/04/22/0.1.1%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/","content":"简介注解是一种能被添加到java源代码中的元数据，方法、类、参数和包都可以用注解来修饰。注解可以看作是一种特殊的标记，可以用在方法、类、参数和包上，程序在编译或者运行时可以检测到这些标记而进行一些特殊的处理\n元注解介绍元注解的作用就是负责注解其他注解，Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明\n\n@Target\n@Retention\n@Documented\n@Inherited\n\n对应的参数详情说明见末尾\n修饰符：访问修饰符必须为public,不写默认为pubic\n关键字：关键字为@interface\n注解名称： 注解名称为自定义注解的名称\n注解内容：注解中内容，对注解的描述\n\n以下内容采用枚举方式进行注解\n\n1.定义枚举public enum newChannelEnum &#123;    BVC(&quot;BVC&quot;,&quot;bvc_timeout&quot;,&quot;BVC&quot;,&quot;BVC_config&quot;),    ACC(&quot;ACC&quot;,&quot;acc_timeout&quot;,&quot;ACC&quot;,&quot;ACC_config&quot;);    // 渠道简称    private String channel;    // 超时时间配置    private String timeout;    // 全名    private String name;    // 接口详情配置    private String interfaceName;    newChannelEnum(String channel, String timeout, String name, String interfaceName) &#123;        this.channel = channel;        this.timeout = timeout;        this.name = name;        this.interfaceName = interfaceName;    &#125;    public String getInterfaceName() &#123;        return interfaceName;    &#125;    public String getChannel() &#123;        return channel;    &#125;    public String getTimeout() &#123;        return timeout;    &#125;    public void setTimeout(String timeout) &#123;        this.timeout = timeout;    &#125;    public String getName() &#123;        return name;    &#125;&#125;\n\n2.定义注解@Target(&#123;ElementType.METHOD,ElementType.FIELD,ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface InterfaceTagConfig &#123;    newChannelEnum method();&#125;\n\n3.定义注解工具类public class InterfaceTarHelper &#123;    // 你需要使用注解的实体类    private static final InterfaceDefault CLASS_LOAD_PATH = new InterfaceDefault();    // 存放标记了自定义注解方法的MAP    private static final Map&lt;String,Method&gt; METHOD_MAP = new ConcurrentHashMap&lt;String,Method&gt;();    // 方法    private Method method;    static &#123;        // 获取所有方法        Method[] methods = CLASS_LOAD_PATH.getClass().getMethods();        for (Method method : methods) &#123;            // 筛选打了注解的方法，并存入MAP            InterfaceTagConfig annotation = method.getAnnotation(InterfaceTagConfig.class);            if(annotation != null)&#123;                METHOD_MAP.put(String.valueOf(annotation.method()),method);            &#125;        &#125;    &#125;        public static InterfaceTarHelper getInstance(newChannelEnum methodEnum)&#123;        InterfaceTarHelper helper = new InterfaceTarHelper();        // 根据枚举获取方法        helper.method = METHOD_MAP.get(String.valueOf(methodEnum));        return helper;    &#125;    public Object getSearchFlightDetail(Object... args) &#123;        try &#123;            // 方法传参数            return method.invoke(CLASS_LOAD_PATH, args);        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125;        return null;    &#125;&#125;\n\n4.使用注解public class NewSearch &#123;    @InterfaceTarget(method = InterfaceTagConfig.BVC)    public static void BVCValidation(InterfaceParam param)&#123;……&#125;        @InterfaceTarget(method = InterfaceTagConfig.ACC)    public static void ACCValidation(InterfaceParam param)&#123;……&#125;&#125;\n\n5.调用方法public class SearchUtils &#123;    public static void getData_new(String channel, InterfaceParam param) throws Exception &#123;        // 获取对应的枚举        newChannelEnum enums = newChannelEnum.getEnums(channel);        // 调用对应的注解        InterfaceHelper.getInstance(enums).getSearchFlightDetail(param);    &#125;&#125;\n\n6.附释@Target表明该注解可以应用的java元素类型\n\n\n\nTarget类型\n描述\n\n\n\nElementType.TYPE\n应用于类、接口（包括注解类型）、枚举\n\n\nElementType.FIELD\n应用于属性（包括枚举中的常量）\n\n\nElementType.METHOD\n应用于方法\n\n\nElementType.PARAMETER\n应用于方法的形参\n\n\nElementType.CONSTRUCTOR\n应用于构造函数\n\n\nElementType.LOCAL_VARIABLE\n应用于局部变量\n\n\nElementType.ANNOTATION_TYPE\n应用于注解类型\n\n\nElementType.PACKAGE\n应用于包\n\n\nElementType.TYPE_PARAMETER\n1.8版本新增，应用于类型变量\n\n\nElementType.TYPE_USE\n1.8版本新增，应用于任何使用类型的语句中（例如声明语句、泛型和强制转换语句中的类型）\n\n\n@Retention表明该注解的生命周期\n\n\n\n生命周期类型\n描述\n\n\n\nRetentionPolicy.SOURCE\n编译时被丢弃，不包含在类文件中\n\n\nRetentionPolicy.CLASS\nJVM加载时被丢弃，包含在类文件中，默认值\n\n\nRetentionPolicy.RUNTIME\n由JVM 加载，包含在类文件中，在运行时可以被获取到\n\n\n@Document表明该注解标记的元素可以被Javadoc 或类似的工具文档化\n@Inherited表明使用了@Inherited注解的注解，所标记的类的子类也会拥有这个注解\n","tags":["java","自定义注解","反射"]},{"title":"aop的简单使用","url":"/2022/04/25/0.1.2aop%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","content":"简介\n AOP 的全称是“Aspect Oriented Programming”，即面向切面编程，和 OOP（面向对象编程）类似，也是一种编程思想\n\nAOP 采取横向抽取机制（动态代理），取代了传统纵向继承机制的重复性代码，其应用主要体现在事务处理、日志管理、权限控制、异常处理等方面。主要作用是分离功能性需求和非功能性需求，使开发人员可以集中处理某一个关注点或者横切逻辑，减少对业务代码的侵入，增强代码的可读性和可维护性。\nAOP 的作用就是保证开发者在不修改源代码的前提下，为系统中的业务组件添加某种通用功能AOP 就是代理模式的典型应用。\n目前最流行的 AOP 框架有两个，分别为 Spring AOP 和 AspectJ\n\nSpring AOP 是基于 AOP 编程模式的一个框架，它能够有效的减少系统间的重复代码，达到松耦合的目的。Spring AOP 使用纯 Java 实现，不需要专门的编译过程和类加载器，在运行期间通过代理方式向目标类植入增强的代码。有两种实现方式：基于接口的 JDK 动态代理和基于继承的 CGLIB 动态代理\nAspectJ 是一个基于 Java 语言的 AOP 框架，从 Spring 2.0 开始，Spring AOP 引入了对 AspectJ 的支持。AspectJ 扩展了 Java 语言，提供了一个专门的编译器，在编译时提供横向代码的植入\n\nspring4.0执行顺序正常执行顺序\n\naround开始 – before – 方法调用 –  around结束 – after 执行 – afterReturning 执行\n\n异常执行顺序\n\naround开始 – before – 方法调用 –  around结束 – after 执行 – afterThrowing 执行\n\nspring5.28执行顺序正常执行顺序\n\naround开始 – before – 方法调用 – afterReturning 执行 – after 执行 –  around结束\n\n异常执行顺序\n\naround开始 – before – 方法调用 – afterThrowing 执行 – after 执行 –  around结束\n\n普通使用（直接匹配包）import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;import java.util.Arrays;/** * @Author dw * @ClassName MyAop * @Description AOP 各个通知使用示例： * @EnableAspectJAutoProxy ： 默认已开启不需要再添加响应的注解 * @Date 2021/8/15 0:21 * @Version 1.0 */@Aspect@Componentpublic class MyAop &#123;    private final Logger log = LoggerFactory.getLogger(this.getClass());    /**     * 定义切入点 (一个切面类中可以定义多个切入点)     * 拦截所有 com.dw.study.controller 包以及子包下所有类的所有方案     * 第一个 * 表示所有返回值     * 第二个 * 表示所有类     * 第三个 * 表示所有的方法名     * 两个 .. 表示当前包以及子包     **/    @Pointcut(&quot;execution(* com.dw.study.controller..*.*(..))&quot;)    public void aspect() &#123;&#125;        /**     * 前置通知，目标方法调用前被调用     * 除@Around外，每个方法里都可以加或者不加参数JoinPoint。     * JoinPoint包含了类名、被切面的方法名、参数等属性。     **/    @Before(value = &quot;aspect()&quot;)    public void before(JoinPoint joinPoint) &#123;        log.info(&quot;AOP before 执行... ：参数类型：&#123;&#125;&quot;, joinPoint.getArgs());    &#125;    /**     * 最终通知，目标方法执行完之后执行     **/    @After(value = &quot;aspect()&quot;)    public void after(JoinPoint joinPoint) &#123;        log.info(&quot;AOP after 执行...  ：&#123;&#125;&quot;, joinPoint.toLongString());    &#125;    /**     * 后置返回通知     * 如果参数中的第一个参数为JoinPoint，则第二个参数为返回值的信息     * 如果参数中的第一个参数不为JoinPoint，则第一个参数为returning中对应的参数     * returning 只有目标方法返回值与通知方法具有相应参数类型时才能执行后置返回通知，否则不执行     * 除了使用上面定义好的切面aspect()， 也可以直接使用表达式。     **/    @AfterReturning(value = &quot;execution(* com.dw.study.controller..*.*(..))&quot;, returning = &quot;result&quot;)    public void afterReturning(JoinPoint joinPoint, Object result) &#123;        log.info(&quot;AOP afterReturning 执行...  ：返回结果：&#123;&#125;&quot;, result);    &#125;    /**     * 环绕通知     * 环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值。     * 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型     * 2：proceedingJoinPoint.proceed() 执行被代理的方法     **/    @Around(value = &quot;aspect()&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint) &#123;        try &#123;            log.info(&quot;AOP around开始... 执行方法... ：&#123;&#125;&quot;, proceedingJoinPoint.getSignature().getName());            Object proceed = proceedingJoinPoint.proceed();            log.info(&quot;AOP around结束... 执行方法... ：&#123;&#125;&quot;, proceedingJoinPoint.getSignature().getName());            return proceed;        &#125; catch (Throwable throwable) &#123;            log.info(&quot;AOP around 执行错误... error ：&#123;&#125;&quot;, throwable.getMessage());            throwable.printStackTrace();            return &quot;执行around出错。。。&quot;;        &#125;    &#125;    /**     * 后置异常通知     * 定义一个名字，该名字用于匹配通知实现方法的一个参数名，当目标方法抛出异常返回后，将把目标方法抛出的异常传给通知方法；     * throwing 只有目标方法抛出的异常与通知方法相应参数异常类型时才能执行后置异常通知，否则不执行，     **/    @AfterThrowing(value = &quot;aspect()&quot;, throwing = &quot;exception&quot;)    public void afterThrowing(JoinPoint joinPoint, Throwable exception) &#123;        log.error(&quot;AOP afterThrowing 执行... , msg : &#123;&#125;&quot;, exception.getMessage());        if (exception instanceof NullPointerException)            log.info(&quot;空指针异常&quot;);    &#125;&#125;\n\n自定义注解匹配(无参)1.自定义注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MethodAspect &#123;&#125;\n\n2.定义切面@Aspect@Componentpublic class MyAop &#123;    private final Logger log = LoggerFactory.getLogger(this.getClass());/**     * 基于注解定义切入点 2     * 对于注解了 @MethodAspect的方法进行拦截     * 表示标注了特定注解的目标方法链接点。如@annotation(com.dw.study.TestAnnotation)表示任何标注了@TestAnnotation注解的目标类方法。     */    @Pointcut(&quot;@annotation(com.dw.study.customAnnotation.MethodAspect)&quot;)    public void testMyAnnotationAspect() &#123;&#125;    /**     * 前置通知，目标方法调用前被调用     * 除@Around外，每个方法里都可以加或者不加参数JoinPoint。     * JoinPoint包含了类名、被切面的方法名、参数等属性。     **/    @Before(value = &quot;testMyAnnotationAspect()&quot;)    public void before(JoinPoint joinPoint) &#123;        log.info(&quot;AOP before 执行... ：参数类型：&#123;&#125;&quot;, joinPoint.getArgs());    &#125;&#125;\n\n3.扫描@RequestMapping(&quot;hello&quot;)@MethodAspectpublic String hello()&#123;    return &quot;SpringBoot-HelloWorld&quot;;&#125;\n\n自定义注解匹配(带参)1.自定义注解@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface MethodAspect &#123;    /**     * 传值     * @return     */    String value();    /**     * 描述     * @return     */    String description() default &quot;default description&quot;;&#125;\n\n2.定义切面如果需要获取@annotation中的值，需要和方法参数名相同\n@Aspect@Componentpublic class MyAop &#123;    private final Logger log = LoggerFactory.getLogger(this.getClass());    /**     * 基于注解定义切入点 2     * 对于注解了 @MethodAspect的方法进行拦截     * 表示标注了特定注解的目标方法链接点。如@annotation(com.dw.study.TestAnnotation)表示任何标注了@TestAnnotation注解的目标类方法。     */    @Pointcut(&quot;@annotation(com.dw.study.customAnnotation.MethodAspect)&quot;)    public void testMyAnnotationAspect() &#123;&#125;    /**     * 前置通知，目标方法调用前被调用     * 除@Around外，每个方法里都可以加或者不加参数JoinPoint。     * JoinPoint包含了类名、被切面的方法名、参数等属性。     * @annotation中的值，需要和方法参数名相同(重要)     **/    @Before(value = &quot;testMyAnnotationAspect() &amp;&amp; @annotation(methodAspect)&quot;)    public void before(JoinPoint joinPoint, MethodAspect methodAspect) &#123;        log.info(&quot;AOP before 执行... ：参数类型：&#123;&#125;&quot;, joinPoint.getArgs());        log.info(&quot;before-value== &quot;+ methodAspect.value() + &quot;before-description== &quot; + methodAspect.description());        // 接收到请求，记录请求内容        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        // 记录下请求内容        System.out.println(&quot;URL : &quot; + request.getRequestURL().toString());        System.out.println(&quot;HTTP_METHOD : &quot; + request.getMethod());        System.out.println(&quot;IP : &quot; + request.getRemoteAddr());        System.out.println(&quot;CLASS_METHOD : &quot; + joinPoint.getSignature().getDeclaringTypeName() + &quot;.&quot; + joinPoint.getSignature().getName());        System.out.println(&quot;ARGS : &quot; + Arrays.toString(joinPoint.getArgs()));    &#125;    /**     * 环绕通知     * 环绕通知非常强大，可以决定目标方法是否执行，什么时候执行，执行时是否需要替换方法参数，执行完毕是否需要替换返回值。     * 环绕通知第一个参数必须是org.aspectj.lang.ProceedingJoinPoint类型     * 2：proceedingJoinPoint.proceed() 执行被代理的方法     *   @annotation中的值，需要和方法参数名相同     **/    @Around(value = &quot;testMyAnnotationAspect() &amp;&amp; @annotation(methodAspect)&quot;)    public Object around(ProceedingJoinPoint proceedingJoinPoint, MethodAspect methodAspect) &#123;        try &#123;            log.info(&quot;AOP around开始... 执行方法... ：&#123;&#125;&quot;, proceedingJoinPoint.getSignature().getName());            log.info(&quot;around-value== &quot;+ methodAspect.value() + &quot;around-description== &quot; + methodAspect.description());            Object proceed = proceedingJoinPoint.proceed();            log.info(&quot;AOP around结束... 执行方法... ：&#123;&#125;&quot;, proceedingJoinPoint.getSignature().getName());            return proceed;        &#125; catch (Throwable throwable) &#123;            log.info(&quot;AOP around 执行错误... error ：&#123;&#125;&quot;, throwable.getMessage());            throwable.printStackTrace();            return &quot;执行around出错。。。&quot;;        &#125;    &#125;&#125;\n\n附文为了更好地理解 AOP，我们需要了解一些它的相关术语。这些专业术语并不是 Spring 特有的，有些也同样适用于其它 AOP 框架，如 AspectJ。\n它们的含义如下表所示：\n\n\n\n名称\n说明\n\n\n\nJoinpoint（连接点）\n指那些被拦截到的点，在 Spring 中，指可以被动态代理拦截目标类的方法。\n\n\nPointcut（切入点）\n指要对哪些 Joinpoint 进行拦截，即被拦截的连接点。\n\n\nAdvice（通知）\n指拦截到 Joinpoint 之后要做的事情，即对切入点增强的内容。\n\n\nTarget（目标）\n指代理的目标对象。\n\n\nWeaving（植入）\n指把增强代码应用到目标上，生成代理对象的过程。\n\n\nProxy（代理）\n指生成的代理对象。\n\n\nAspect（切面）\n切入点和通知的结合。\n\n\nAdvice 直译为通知，也有的资料翻译为“增强处理”，共有 5 种类型，如下表所示：\n\n\n\n通知\n说明\n\n\n\nbefore（前置通知）\n通知方法在目标方法调用之前执行\n\n\nafter（后置通知）\n通知方法在目标方法返回或异常后调用\n\n\nafter-returning（返回后通知）\n通知方法会在目标方法返回后调用\n\n\nafter-throwing（抛出异常通知）\n通知方法会在目标方法抛出异常后调用\n\n\naround（环绕通知）\n通知方法会将目标方法封装起来\n\n\nexecution表达式：用于匹配方法执行的连接点，属于方法级别， 语法： execution(修饰符 返回值类型 方法名（参数）异常)\n\n\n\n语法参数\n描述\n\n\n\n修饰符\n可选，如public，protected，写在返回值前，任意修饰符填*号就可以\n\n\n返回值类型\n必选，可以使用*来代表任意返回值\n\n\n方法名\n必选，可以用*来代表任意方法\n\n\n参数\n必选， ()代表是没有参数，(..)代表是匹配任意数量，任意类型的参数，当然也可以指定类型的参数进行匹配，如要接受一个String类型的参数，则(java.lang.String), 任意数量的String类型参数：(java.lang.String..)等等。。。\n\n\n异常\n可选，语法：throws 异常，异常是完整带包名，可以是多个，用逗号分隔\n\n\nexecution()表达式案例：\n\n拦截com.dw.study包下的所有子包里的任意类的任意方法execution(* com.dw.study..*.*(..))\n拦截com.dw.study.Test2Controller下的任意方法execution(* **com.dw.study**.Test2Controller.*(..))\n拦截任何修饰符为public的方法execution(public * * (..))\n拦截com.dw.study下的所有子包里的以ok开头的方法execution(* **com.dw.study**..*.ok* (..))\n\nJoinPointJoinPoint对象封装了SpringAop中切面方法的信息,在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象。 除 @Around 外，每个通知的方法里都可以加或者不加参数JoinPoint。JoinPoint包含了类名、被切面的方法名、参数等属性。@Around 参数必须为 ProceedingJoinPoint\n\n\n\n方法名\n功能\n\n\n\nSignature getSignature();\n获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息\n\n\nObject[] getArgs();\n获取传入目标方法的参数对象\n\n\nObject getTarget();\n获取被代理的对象\n\n\nObject getThis();\n获取代理对象\n\n\nProceedingJoinPoint ProceedingJoinPoint对象是JoinPoint 的子接口, 该对象只用在@Around的切面方法中：\n\n\n\n方法名\n功能\n\n\n\nObject proceed() throws Throwable\n执行目标方法\n\n\nObject proceed(Object[] var1) throws Throwable\n传入的新的参数去执行目标方法\n\n\n小结AOP 是 Spring 的核心之一，在 Spring 中经常会使用 AOP 来简化编程。\n 在 Spring 框架中使用 AOP 主要有以下优势：\n\n提供声明式企业服务，特别是作为 EJB 声明式服务的替代品。最重要的是，这种服务是声明式事务管理。\n允许用户实现自定义切面。在某些不适合用 OOP 编程的场景中，采用 AOP 来补充。\n可以对业务逻辑的各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时也提高了开发效率。\n\n参考\nSpring AOP：基于AspectJ注解开发\n\n细说SpringAop详解\n\nhttps://zhuanlan.zhihu.com/p/395709988\n\n\n","tags":["aop"]},{"title":"redis锁","url":"/2022/02/23/0.1.8redis%E9%94%81/","content":"暂时没时间整细节，给个粗略的记录一下\npackage com.util.qunar;import com.service.qunar.FQunarSearchService;import com.service.zl.ValidationCabinAndPrice_QNR;import org.apache.log4j.Logger;import org.redisson.Redisson;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import org.springframework.beans.factory.InitializingBean;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.concurrent.TimeUnit;@Servicepublic class RedissonTemplate &#123;    private static volatile RedissonClient redissonClient;    private static final String LOCK_TITLE = &quot;QNRLock_&quot;;    /**     * 加锁     * @param lockName     * @param waitTime     * @param timeOutSecond     * @return     */    public static boolean acquireSecond(String lockName, Integer waitTime, Integer timeOutSecond)&#123;        try &#123;            String key = LOCK_TITLE + lockName;            RLock mylock = redisLock().getLock(key);            //lock提供带timeout参数，timeout结束强制解锁，防止死锁            //先尝试在超时时间内获取锁，如果没有获取到，此时如果等待时间还有剩余进入循环不断取尝试获取锁 直到时间结束退出  循环中是订阅，时间结束取消订阅            return mylock.tryLock(waitTime, timeOutSecond, TimeUnit.SECONDS);        &#125; catch (InterruptedException e) &#123;            System.out.println(e);        &#125;        return false;    &#125;    /**     * 连接redis     * @return     */    private static RedissonClient redisLock()&#123;        if(redissonClient == null)&#123;            synchronized (FQunarSearchService.class)&#123;                if(redissonClient == null)&#123;                    Config config = new Config();                    config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;)                            .setPassword(&quot;123&quot;)                            .setDatabase(17);                    redissonClient = Redisson.create(config);                &#125;            &#125;        &#125;        return redissonClient;    &#125;    /**     * 解锁     * @param lockName     */    public static void release(String lockName)&#123;        String key = LOCK_TITLE + lockName;        RLock mylock = redissonClient.getLock(key);        mylock.unlock();    &#125;&#125;","tags":["redis","分布式锁"]},{"title":"IDEA内存调优","url":"/2022/05/06/0.2.0IDEA%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/","content":"idea2020无法启动报错初始堆值大于最大堆值_寒烟雾柳的博客-CSDN博客\n调整内存的时候一定Xms2048m不能大于Xmx4096m【否则idea启动不起来】\nxmx建议设置为（总内存的3/4 ÷ 你要开的idea个数），这样才不会卡\n-Xms1024m-Xmx8192m-XX:MaxPermSize=2048m-XX:ReservedCodeCacheSize=256m-ea-Dsun.io.useCanonCaches=false-Dsun.awt.keepWorkingSetOnMinimize=true-Djava.net.preferIPv4Stack=true#-Djsse.enableSNIExtension=false-XX:+UseCodeCacheFlushing-XX:+UseConcMarkSweepGC-XX:SoftRefLRUPolicyMSPerMB=50","tags":["jvm"]},{"title":"RedisTemplate统一集成","url":"/2022/05/06/0.2.1RedisTemplate%E7%BB%9F%E4%B8%80%E9%9B%86%E6%88%90/","content":"1.配置redis-config&lt;!-- Jedis 连接池配置 --&gt;&lt;bean id=&quot;jedisPoolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;   &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;redis.maxIdle&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;minEvictableIdleTimeMillis&quot; value=&quot;$&#123;redis.minEvictableIdleTimeMillis&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;numTestsPerEvictionRun&quot; value=&quot;$&#123;redis.numTestsPerEvictionRun&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;timeBetweenEvictionRunsMillis&quot; value=&quot;$&#123;redis.timeBetweenEvictionRunsMillis&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;stringRedisSerializer&quot;  class=&quot;org.springframework.data.redis.serializer.StringRedisSerializer&quot; /&gt;   &lt;bean id=&quot;jdkRedisSerializer&quot;  class=&quot;org.springframework.data.redis.serializer.JdkSerializationRedisSerializer&quot; /&gt;   &lt;bean id=&quot;jedisConnectionZero&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot; destroy-method=&quot;destroy&quot;&gt;   &lt;property name=&quot;poolConfig&quot; ref=&quot;jedisPoolConfig&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;hostName&quot; value=&quot;$&#123;redisst.hostName&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;port&quot; value=&quot;$&#123;redisst.port&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;timeout&quot; value=&quot;$&#123;redisst.timeout&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;usePool&quot; value=&quot;$&#123;redisst.usePool&#125;&quot;&gt;&lt;/property&gt;   &lt;property name=&quot;password&quot; value=&quot;$&#123;redisst.password&#125;&quot; &gt;&lt;/property&gt;    &lt;property name=&quot;database&quot; value=&quot;$&#123;redisst.db0&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;redisTemplateZero&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;   &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionZero&quot; /&gt;    &lt;property name=&quot;keySerializer&quot; ref=&quot;stringRedisSerializer&quot; /&gt;   &lt;property name=&quot;hashKeySerializer&quot; ref=&quot;jdkRedisSerializer&quot; /&gt;   &lt;property name=&quot;valueSerializer&quot; ref=&quot;jdkRedisSerializer&quot;/&gt;&lt;/bean&gt;\n\n2.定义枚举public enum CommonRedisEnums &#123;    O_DB_0(&quot;redisTemplateZero&quot;,&quot;ODB0&quot;);    // 对应redis-config中的bean名称    private String name;    // 别名    private String asName;    CommonRedisEnums(String name, String asName) &#123;        this.name = name;        this.asName = asName;    &#125;    public String getName() &#123;        return name;    &#125;    public String getAsName() &#123;        return asName;    &#125;&#125;\n\n3.使用SpringAppContextHolder获取beanprivate static Map&lt;String,RedisTemplate&gt; redisTemplateMap = new HashMap&lt;&gt;();public static void getRedis(CommonRedisEnums enums)&#123;   if(!redisTemplateMap.containsKey(enums.getName()))&#123;      RedisTemplate redisBean = (RedisTemplate) SpringAppContextHolder            .getBean(enums.getName());      if(redisBean != null)&#123;         redisTemplateMap.put(enums.getName(),redisBean);      &#125;   &#125;&#125;\n\n4.使用工具类进行调用/** * 搜索 */public static Map&lt;String, Object&gt; searchKeys(List&lt;String&gt; keys,CommonRedisEnums enums)&#123;   getRedis(enums);   return batchQueryByKeys(keys, false,redisTemplateMap.get(enums.getName()));&#125;public static Map&lt;String, Object&gt; batchQueryByKeys(final List&lt;String&gt; keys, Boolean useParallel, final RedisTemplate redisTemplate) &#123;   if (null == keys || keys.size() == 0) &#123;      return null;   &#125;   if (null == useParallel) &#123;      useParallel = true;   &#125;   Object object = redisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123;      @Override      public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;         connection.openPipeline();         for (String key : keys) &#123;            byte[] bkey = redisTemplate.getStringSerializer().serialize(key);            redisTemplate.getStringSerializer().serialize(JSON.toJSONString(connection.get(bkey)));         &#125;         return connection.closePipeline();      &#125;   &#125;);   List&lt;Object&gt; results = null;   if (null == object) &#123;      return null;   &#125; else &#123;      results = (List) object;   &#125;   Map&lt;String, Object&gt; resultMap = null;   if (useParallel) &#123;      Map&lt;String, Object&gt; resultMapOne = Collections.synchronizedMap(new HashMap&lt;String, Object&gt;());      for (String t : keys) &#123;         resultMapOne.put(t, results.get(keys.indexOf(t)));      &#125;      resultMap = resultMapOne;   &#125; else &#123;      Map&lt;String, Object&gt; resultMapTwo = new HashMap&lt;&gt;();      for (String t : keys) &#123;         Object o = results.get(keys.indexOf(t));         if (null != o) &#123;            String val = (String) redisTemplate.getStringSerializer().deserialize((byte[]) o);            resultMapTwo.put(t, val);         &#125;      &#125;      resultMap = resultMapTwo;   &#125;   return resultMap;&#125;\n\n小结使用@Autowired的时候，对于static标识的变量或者方法一般是获取到的null值常规的方法已经使用不了\n@Autowiredprivate NewRedisZeroService redisZeroService;\n\n需要使用注入方法的形式来使用\nprivate static ZXSearchNewService_new zxSearchNewService_new;private static QueueProducerService messageService;@Autowiredpublic zxSearch(QueueProducerService queueProducerService,ZXSearchNewService_new zxSearchNewService_new) &#123;    zxSearch.zxSearchNewService_new = zxSearchNewService_new;    zxSearch.messageService = queueProducerService;&#125;\n\n这样就可以在工具类中使用了，不需要通过传参的形式去获取\n","tags":["工具类","redis"]},{"title":"redis存储Data truncation: Incorrect datetime value","url":"/2022/03/07/0.1.7redis%E5%AD%98%E5%82%A8Data-truncation-Incorrect-datetime-value/","content":"最近在编写项目时，用redis存储结果一直报转换异常对此我有了以下思路1.在mysql进行格式转换2.在java先转换3.存json之前就进行格式转换\n但是以上方法都不行，因为数据需要的是date类型，如果走转换又过慢有大佬提了一下使用序列化解决，我就尝试了一下，还真可以,以下是我编写思路1.首先需要序列化的类继承Serializable接口2.编写序列化工具类\npackage com.tiantai.policy.utils;import java.io.*;public class SerializeUtil &#123;    // 序列化    public static byte[] serialize(Object object) &#123;        ObjectOutputStream oos = null;        ByteArrayOutputStream baos = null;        byte[] bytes = null;        try &#123;            baos = new ByteArrayOutputStream();            oos = new ObjectOutputStream(baos);            oos.writeObject(object);            bytes = baos.toByteArray();        &#125; catch (Exception e) &#123;            System.err.println(&quot;序列化失败&quot; + e.getMessage());        &#125;        return bytes;    &#125;    // 反序列化    public static Object deserialize(byte[] bytes) throws IOException, ClassNotFoundException &#123;        ByteArrayInputStream bais = null;        ObjectInputStream ois = null;        try &#123;            bais = new ByteArrayInputStream(bytes);            ois = new ObjectInputStream(bais);        &#125; catch (Exception e) &#123;            System.err.println(&quot;反序列化失败&quot; + e.getMessage());        &#125;        return ois.readObject();    &#125;&#125;\n3.使用序列化存储\nHashMap&lt;Integer , Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();                                objectObjectHashMap.put(airChannelEnum.getType(), SerializeUtil.serialize(selectPage));                                redisTemplate.opsForList().leftPush(&quot;error&quot;,gson.toJson(objectObjectHashMap));\n4.反序列化读取\nPage deserialize = (Page)SerializeUtil.deserialize(entry.getValue());\n第一个红框是我用gson进行json转换第二个红框是序列化后强转为原对象\n","tags":["java","redis","bug"]},{"title":"ShardingJDBC简单介绍","url":"/2022/04/10/0.1.9ShardingJDBC%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","content":"ShardingJDBC介绍\nShardingJDBC是当当网研发的开源分布式数据库中间件，从 3.0 开始Sharding-JDBC被包含在 Sharding-Sphere中，之后该项目进入进入Apache孵化器，4.0版本之后的版本为Apache版本。\n\nShardingSphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar（计划中）这3款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。\n官方地址：https://shardingsphere.apache.org/document/current/cn/overview/\n它定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架\n在 maven 的工程里面，我们使用它的方式是引入依赖，然后进行配置就可以了，不用像 Mycat 一样独立运行一个服务，客户端不需要修改任何一行代码，原来是 SSM 连接数据库，还是 SSM，因为它是支持 MyBatis 的\n特点Sharding-JDBC的核心功能为数据分片和读写分离，通过Sharding-JDBC，应用可以透明的使用jdbc访问已经分库分表、读写分离的多个数据源，而不用关心数据源的数量以及数据如何分布。 \n\n适用于任何基于Java的ORM框架，如：Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC\n基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等\n支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL\n\n分库分表的一些核心动作，比如 SQL 解析，路由，执行，结果处理，都是由它来完成的\n\n上图展示了Sharding-Jdbc的工作方式，使用Sharding-Jdbc前需要人工对数据库进行分库分表\n在应用程序中加入Sharding-Jdbc的Jar包，应用程序通过Sharding-Jdbc操作分库分表后的数据库和数据表，由于Sharding-Jdbc是对Jdbc驱动的增强，使用Sharding-Jdbc就像使用Jdbc驱动一样，在应用程序中是无需指定具体要操作的分库和分表的\n主要概念：逻辑表会在 SQL 解析和路由时被替换成真实的表名\n\n性能对比以下为网上统计数据\n1.性能损耗测试：服务器资源充足、并发数相同，比较JDBC和Sharding-JDBC性能损耗，Sharding-JDBC相对JDBC损耗不超过7%\n\n2.性能对比测试：服务器资源使用到极限，相同的场景JDBC与Sharding-JDBC的吞吐量相当\n3.性能对比测试：服务器资源使用到极限，Sharding-JDBC采用分库分表后，Sharding-JDBC吞吐量较JDBC不分表有接近2倍的提升。 \n\nShardingJDBC引入1.引入boot的依赖整合包\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.shardingsphere&lt;/groupId&gt;    &lt;artifactId&gt;sharding‐jdbc‐spring‐boot‐starter&lt;/artifactId&gt;    &lt;version&gt;4.0.0‐RC1&lt;/version&gt;&lt;/dependency&gt;\n\n2.创建数据库和表\n\n创建订单库order_db \nCREATE DATABASE `order_db` CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_general_ci&#x27;;\n在order_db中创建t_order_1、t_order_2表 \nDROP TABLE IF EXISTS `t_order_1`;CREATE TABLE `t_order_1`(    `order_id` bigint(20) NOT NULL COMMENT &#x27;订单id&#x27;,    `price` decimal(10, 2) NOT NULL COMMENT &#x27;订单价格&#x27;,    `user_id` bigint(20) NOT NULL COMMENT &#x27;下单用户id&#x27;,    `status` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#x27;订单状态&#x27;,    PRIMARY KEY (`order_id`) USING BTREE)ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;DROP TABLE IF EXISTS `t_order_2`;CREATE TABLE `t_order_2` (    `order_id` bigint(20) NOT NULL COMMENT &#x27;订单id&#x27;,    `price` decimal(10, 2) NOT NULL COMMENT &#x27;订单价格&#x27;,    `user_id` bigint(20) NOT NULL COMMENT &#x27;下单用户id&#x27;,    `status` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT &#x27;订单状态&#x27;,    PRIMARY KEY (`order_id`) USING BTREE)ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n3.application.properties配置规则\n\n定义数据源\n# 定义数据源m1，并对m1进行实际的参数配置spring.shardingsphere.datasource.names=m1spring.shardingsphere.datasource.m1.type=com.alibaba.druid.pool.DruidDataSourespring.shardingsphere.datasource.m1.driver‐class‐name=com.mysql.jdbc.Driverspring.shardingsphere.datasource.m1.url=jdbc:mysql://localhost:3306/order_db?useUnicode=truespring.shardingsphere.datasource.m1.username=rootspring.shardingsphere.datasource.m1.password=root\n配置数据节点\n# 指定t_order表的数据分布情况，配置数据节点# 他分布在m1.t_order_1，m1.t_order_2spring.shardingsphere.sharding.tables.t_order.actual‐data‐nodes=m1.t_order_$‐&gt;&#123;1..2&#125;\n配置主键策略\n# 指定t_order表的主键生成策略为SNOWFLAKE,SNOWFLAKE是一种分布式自增算法，保证id全局唯一spring.shardingsphere.sharding.tables.t_order.key‐generator.column=order_idspring.shardingsphere.sharding.tables.t_order.key‐generator.type=SNOWFLAKE\n配置分片算法\n# 指定t_order表的分片策略，分片策略包括分片键和分片算法# order_id为偶数的数据落在t_order_1，为奇数的落在t_order_2，分表策略的表达式为 t_order_$-&gt;&#123;order_id % 2 + 1&#125;spring.shardingsphere.sharding.tables.t_order.table‐strategy.inline.sharding‐column=order_idspring.shardingsphere.sharding.tables.t_order.table‐strategy.inline.algorithm‐expression=t_order_$‐&gt;&#123;order_id % 2 + 1&#125;\n日志输出sql\nspring.shardingsphere.props.sql.show=true\n\n4.数据操作\n@Mapper@Componentpublic interface OrderDao &#123;    /*** 新增订单     * @param price 订单价格     * @param userId 用户id     * @param status 订单状态     * @return     */    @Insert(&quot;insert into t_order(price,user_id,status) value(#&#123;price&#125;,#&#123;userId&#125;,#&#123;status&#125;)&quot;)    int insertOrder(@Param(&quot;price&quot;) BigDecimal price, @Param(&quot;userId&quot;)Long userId, @Param(&quot;status&quot;)String status);        /*** 根据id列表查询多个订单    * @param orderIds 订单id列表     * @return     */     @Select(&#123;&quot;&lt;script&gt;&quot; +        &quot;select &quot; +        &quot; * &quot; +        &quot; from t_order t&quot; +        &quot; where t.order_id in &quot; +        &quot;&lt;foreach collection=&#x27;orderIds&#x27; item=&#x27;id&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27;&gt;&quot; +        &quot; #&#123;id&#125; &quot; +        &quot;&lt;/foreach&gt;&quot;+        &quot;&lt;/script&gt;&quot;&#125;)    List&lt;Map&gt; selectOrderbyIds(@Param(&quot;orderIds&quot;)List&lt;Long&gt; orderIds);&#125;\n\n5.测试\n@Testpublic void testInsertUser()&#123;    for (int i = 0 ; i&lt;10; i++)&#123;        Long id = i + 1L;        userDao.insertUser(id,&quot;姓名&quot;+ id);    &#125;&#125;@Testpublic void testSelectUserbyIds()&#123;    List&lt;Long&gt; userIds = new ArrayList&lt;&gt;();    userIds.add(1L);    userIds.add(2L);    List&lt;Map&gt; users = userDao.selectUserbyIds(userIds);    System.out.println(users);&#125;\n\n小结Sharding-JDBC执行流程：SQL解析 =&gt; 查询优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt; 结果归并\n系统在设计之初就应该对业务数据的耦合松紧进行考量，从而进行垂直分库、垂直分表，使数据层架构清晰明了。 \n若非必要，无需进行水平切分，应先从缓存技术着手降低对数据库的访问压力。如果缓存使用过后，数据库访问量还是非常大，可以考虑数据库读、写分离原则。若当前数据库压力依然大，且业务数据持续增长无法估量，最后可考虑水平分库、分表，单表拆分数据控制在1000万以内。 \n注意：并不是所有的sql语句都能支持执行\n详细参考：https://shardingsphere.apache.org/document/current/cn/features/sharding/use-norms/sql/\n","tags":["分库分表","多数据源","mysql"]},{"title":"IDEA插件","url":"/2022/05/09/0.2.2IDEA%E6%8F%92%E4%BB%B6/","content":"插件官网JetBrains Marketplace\nAlibaba Java Coding Guidelines首先要推荐的是和《手册》配套的 阿里巴巴 Java代码规范插件。安装该插件后，代码超过 80 行、手动创建线程池等，这些和《手册》中的规约不符时，IDEA中会给出警告提示。\njclasslib bytecode viewer下面要隆重介绍的是一款可视化的字节码查看插件：jclasslib大家可以直接在 IDEA 插件管理中安装（安装步骤略）使用方法：\n\n在 IDEA 打开想研究的类\n编译该类或者直接编译整个项目（ 如果想研究的类在 jar 包中，此步可略过）\n打开“view” 菜单，选择“Show Bytecode With jclasslib” 选项\n选择上述菜单项后 IDEA 中会弹出 jclasslib 工具窗口那么有自带的强大的反汇编工具 javap 还有必要用这个插件吗？这个插件的强大之处在于：\n不需要敲命令，简单直接，在右侧方便和源代码进行对比学习。\n字节码命令支持超链接，点击其中的虚拟机指令即可跳转到 jvms 相关章节，超级方便。该插件对我们学习虚拟机指令有极大的帮助。详细安装和介绍参考另外一篇手记：https://www.imooc.com/article/29625\n\nCodota另外一个不得不说的就是专栏中提到的辅助开发神器: Codota可以点击下图所示“Add Codota to you IDEA” 了解安装步骤该插件的强大之处在于：\n\n支持智能代码自动提示，该功能可以增强 IDEA 的代码提示功能。\n支持 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法当我们第一次使用某个类，对某个函数不够熟悉时，可以通过该插件搜索相关用法，快速模仿学习如上图所示，我们想了解 Stream 类中 flatMap 函数的用法，可以使用该插件查看知名开源项目的用法插件窗口顶部还给出了该类最常用的函数，可以点击查看相关用法案例，每个案例右侧的 “view source”可以跳转到该片段对应的开源项目的源码中\n\nAuto filling Java call arguments开发中，我们通常会调用其他已经编写好的函数，调用后需要填充参数，但是绝大多数情况下，传入的变量名称和该函数的参数名一致，当参数较多时，手动单个填充参数非常浪费时间该插件就可以帮你解决这个问题安装完该插件以后，调用一个函数，使用 Alt+Enter 组合键，调出 “Auto fill call parameters” 自动使用该函数定义的参数名填充\nGenerateO2O、GenerateAllSetter我们定义好从 A 类转换到 B 类的函数转换函数后，使用这两个插件可以自动调用 Getter 和 Setter 函数实行自动转换实际开发中还有一个非常常见的场景： 我们创建一个对象后，想依次调用 Setter 函数对属性赋值，如果属性较多很容易遗漏或者重复可以使用这 GenerateAllSetter 提供的功能，自动调用所有 Setter 函数（可填充默认值），然后自己再跟进实际需求设置属性值\nRainbow Brackets由于很多人没有养成好的编码风格，没有随手 format 代码的习惯，甚至有些同事会写代码超过几百行，阅读起来将非常痛苦痛苦的原因之一就是找到上下文，由于括号太多，不确定当前代码行是否属于某个代码块，此时这个插件就会帮上大忙插件 github 地址：https://github.com/izhangzhihao/intellij-rainbow-brackets大家可以观看其 github 首页的动图体会和学习其强大功能\nMaven Helper现在 Java 项目通常会使用 maven 或者 gradle 构建，对于maven 项目来说， jar 包冲突非常常见那么如何更容易地查看和解决 jar 包冲突呢？大家可以安装该插件，安装后 IDEA 中打开 pom.xml 文件时，就会多出一个 “Dependency Analyzer” 选项卡如上图所示，该插件支持值插件冲突的 jar 包，可以选择冲突的 jar 包将其 exclude 掉\nFindBugs程序员总是想尽可能地避免写 BUG， FindBugs 作为静态代码检查插件，可以检查你代码中的隐患，并给出原因。当然还有很多类似的静态代码检查插件，大家可以自行了解安装\nSequenceDiagramSequenceDiagram 可以根据代码调用链路自动生成时序图，超级赞，超级推荐！这对研究源码，梳理工作中的业务代码有极大的帮助，堪称神器。安装完成后，在某个类的某个函数中，右键 –Sequence Diagaram 即可调出。如下图是 Netty 的源码，可以通过该插件绘制出当前函数的调用链路。双击顶部的类名可以跳转到对应类的源码中，双击调用的函数名可以直接调入某个函数的源码，总之非常强大。\nJava Stream DebuggerStream 非常好用，可以灵活对数据进行操作，但是对很多刚接触的人来说，不好理解。那么 Java Stream Debugger 这款神器的 IDEA 就可以帮到你。它可以将 Stream 的操作步骤可视化，非常有助于我们的学习。\nKey promoter X很多人不愿意切换 IDE 就是因为快捷键的习惯问题。刚好这个插件可以提醒快捷键，有代入感，提醒的多了你就会了。对于新手建议安装熟悉一下快捷键。\nIDEA Mind Map思维导图对于我们需求分析和知识库关系梳理十分重要。有了这个插件以后 IDEA 也可以画思维导图了。而且功能还十分强大，贴图啥的应有尽有\nCodeGlance代码编辑区迷你缩放插件，可以进行代码的全局预览。来看看效果吧\nCamelCase命名风格转换插件，可以在 kebab-case，SNAKE_CASE，PascalCase，camelCase，snake_case 和 空格风格之间切换。快捷键苹果为 ⇧+⌥+ U ，windows 下为 Shift + Alt +U\nMybatisXMybatis-plus 团队为 Mybatis 开发的插件，提供了 Mapper 接口和 XML之间的跳转和自动生成模版的功能\nMyBatis Log Plugin另一款国人关于 Mybatis 的作品，评分也很高，作用是将 Mybatis 生成的 sql 还原为原始整个 sql。方便在开发中从日志中跟踪调试 sql语句https://vdn.vzuu.com/SD/04205f24-23a2-11eb-a602-d6a043673cc5.mp4?disable_local_cache=1&amp;bu=078babd7&amp;c=avc.0.0&amp;f=mp4&amp;expiration=1652064414&amp;auth_key=1652064414-0-0-ed4dc28442589dc4e9e6703457fc9811&amp;v=ali&amp;pu=078babd7\nGit Commit Template老是有人吐槽你提交的 Git 不规范？你可以试试这个插件。它提供了很好的 Git 格式化模版，你可以按照实际情况格式化你的提交信息\nFast RequestFast Request是一个基于springmvc的帮助你快速生成url和参数的插件,同时也是一个http client工具,调试API的时候只需要点击生成图标即可在工具窗口生成方法的url以及对应的参数，再点击发送请求按钮即可完成api调试，非常实用，相比于 Http client和restfultool，该插件拥有postman一样的界面和参数生成功能，域名管理功能，自定义参数解析功能，功能更加强大全面【缺点】收费\nEasy Javadoc快速生成javadoc文档，点击快捷键生成方法或类或属性的javadoc，同时支持各种渠道的翻译(建议不要用有道翻译，不准)\nMybatisCodeHelperPro最好的Mybatis代码提示，完整支持Mybatis动态sql代码提示，代码检测，写sql几乎所有地方都有代码提示，支持基于方法名动态生成sql，生成基础实体类及mapper，功能非常强大\nTranslation对于英文不好的开发者来说，这款插件就是神器，在看各种框架源码的时候十分有用; 选择右键就可以翻译，对于方法或者类上面的注释，只要按下F1就自动被翻译成中文(建议自定义快捷键)\nJrebel老牌插件了，支持热启动，修改一些代码不再需要重启应用，大大减小项目重启带来的时间浪费，同时也支持远程启动调试\n.ignore.ignore是IDEA的一款专用忽略文件的插件\ngoogle-java-formatgoogle-java-format插件可以帮助我们不通过对应的快捷键就可以实现特定方式下自动格式化代码\nLeetcode EditorLeetCode插件，可以在IDEA中在线刷题。上班摸鱼属实方便，表面上我在干活，实际上我在刷算法题\nJson Parser厌倦了打开浏览器格式化和验证JSON?为什么不安装JSON解析器并在IDE中使用离线支持呢?JSON解析器是一个用于验证和格式化JSON字符串的轻量级插件\n","tags":["idea","插件"]},{"title":"AOP解决内部方法调用不生效问题","url":"/2022/05/28/0.2.4-AOP%E8%A7%A3%E5%86%B3%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E4%B8%8D%E7%94%9F%E6%95%88%E9%97%AE%E9%A2%98/","content":"\n描述：在使用AOP切面的时候Controller层可以正常切入进去，但是Service层内部方法调用切入不进去\n\n大致情况就算打注解放methodB上也不会进切面，Aop只支持外部调用\nimport org.springframework.stereotype.Service;/** * 目标对象类 * @author Gufung */@Servicepublic class TestAopService &#123;    public void methodA() &#123;        System.out.println(&quot;method A run&quot;);        //内部调用方法B时AOP的增强处理方法不会执行        methodB();    &#125;        public void methodB() &#123;        System.out.println(&quot;method B run&quot;);    &#125;&#125;\n\n解决方式1.配置spring-context.xml&lt;!-- 通过@Aspect注解实现AOP --&gt;&lt;!-- proxy-target-class=&quot;true&quot;表示使用CGlib动态代理 --&gt;&lt;!-- expose-proxy=&quot;true&quot;暴露代理对象 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot;/&gt;\n\n2.使用AopContext.currentProxy()获取代理对象方法，并且执行import org.springframework.aop.framework.AopContext;import org.springframework.stereotype.Service;/** * 目标对象类 * @author Gufung * */@Servicepublic class TestAopService &#123;    public void methodA() &#123;        System.out.println(&quot;method A run&quot;);        //methodB();        //从spring上下文获取代理对象执行方法        ((TestAopService) AopContext.currentProxy()).methodB();    &#125;        public void methodB() &#123;        System.out.println(&quot;method B run&quot;);    &#125;&#125;\n\n注意点methodB一定要声明为public 否则进不去切面！！！\n注解实现方法计时1.自定义注解/** * 耗时统计 * @author Foam */@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface TimeComsumingStatics &#123;    String methodName();&#125;\n\n2.aop@Aspect@Component@EnableAspectJAutoProxy(proxyTargetClass = true)public class TimeComsumingAOP &#123;    private static final Logger log = LoggerFactory.getLogger(TimeComsumingAOP.class);    @Value(&quot;$&#123;timeCusming:false&#125;&quot;)    public String openButton;    /**     * 基于注解定义切入点     * 对于注解了 @TimeComsumingStatics的方法进行拦截     * 表示标注了特定注解的目标方法链接点。如@annotation(com.dw.study.TestAnnotation)表示任何标注了@TestAnnotation注解的目标类方法。     **/    @Pointcut(&quot;@annotation(com.service.zl.vo.TimeComsumingStatics)&quot;)    public void aspect() &#123;    &#125;    /**     * 定时任务记录执行日志     * @return     */    @Around(value = &quot;aspect() &amp;&amp; @annotation(timeComsumingStatics)&quot;)    public Object before(ProceedingJoinPoint proceedingJoinPoint,TimeComsumingStatics timeComsumingStatics) throws Throwable &#123;        if(&quot;true&quot;.equals(openButton))&#123;            long actStartTime = System.currentTimeMillis();            Object proceed = proceedingJoinPoint.proceed();            long actEndTime = System.currentTimeMillis();            String timecusming = (actEndTime - actStartTime)  + &quot;毫秒&quot;;            log.info(timeComsumingStatics.methodName() + &quot;耗时：&quot; + timecusming);            return proceed;        &#125;else &#123;            return proceedingJoinPoint.proceed();        &#125;    &#125;&#125;\n\n3.application.properties当timeCusming为true时开启接口耗时统计，false反之\ntimeCusming=true\n\n4.注解使用import org.springframework.aop.framework.AopContext;import org.springframework.stereotype.Service;/** * 目标对象类 * @author Gufung * */@Servicepublic class TestAopService &#123;    public void methodA() &#123;        System.out.println(&quot;method A run&quot;);        //methodB();        //从spring上下文获取代理对象执行方法        ((TestAopService) AopContext.currentProxy()).methodB();    &#125;        @TimeComsumingStatics(methodName = &quot;调用methodB&quot;)    public void methodB() &#123;        System.out.println(&quot;method B run&quot;);    &#125;&#125;\n\n5.结果调用methodB耗时：17毫秒\n\n参考文献\nAOP内部调用失效-解决方法_咕了个咕的博客-CSDN博客_aop 内部调用\n注意：jdk1.8的default才能使用接口方式\n\nJava 8 interface default方法_Code_My_Life的博客-CSDN博客_interface的default方法\n\nspring–aop内部调用失效问题分析 - 11014p - 博客园\n\n\n","tags":["自定义注解","AOP"]},{"title":"设计模式-创建型模式-原型模式","url":"/2022/05/21/0.2.3-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/","content":"介绍原型模式是指，一个抽象类 Prototype 具有一个clone 方法，其实现类ConcretePrototype1、ConcretePrototype2 实现各自的clone方法，在使用的时候，调用Prototype的clone方法可以clone任意实现类。其作用就是快速创建一个新的对象\n角色\nPrototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。\nConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。\nClient（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。\n何时使用原型模式\n需要创建的对象应独立于其类型与创建方式\n要实例化的类是在运行时决定的\n类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易\n从功能的角度来讲，不管什么对象，只要复制自身比手工实例化要好，都可以是原型对象\n不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便\n需要使用组合(树型)对象作为其他东西的基础。例如，使用组合对象作为组件来构建另一个组合对象\n\n原型模式原理一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，Java编译器将抛出一个CloneNotSupportedException异常。\nclass ConcretePrototype implements  Cloneable&#123;……public Prototype  clone()&#123;　　Object object = null;　　try &#123;　　　　　object = super.clone();　　&#125; catch (CloneNotSupportedException exception) &#123;　　　　　System.err.println(&quot;Not support cloneable&quot;);　　&#125;　　return (Prototype )object;&#125;……&#125;\n\n在客户端创建原型对象和克隆对象也很简单，如下代码所示：\nPrototype obj1  = new ConcretePrototype();Prototype obj2  = obj1.clone();\n\n一般而言，Java语言中的clone()方法都需要满足：\n\n对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；\n对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；\n如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：\n在派生类中覆盖基类的clone()方法，并声明为public；\n在派生类的clone()方法中，调用super.clone()；\n派生类需实现Cloneable接口。此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。\n\n浅拷贝(ShallowClone)和深拷贝(DeepClone)介绍\n浅拷贝在浅拷贝中，如果原型对象的成员变量是值类型，将复制一份给拷贝对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给拷贝对象，也就是说原型对象和拷贝对象的成员变量指向相同的内存地址。简单来说，在浅拷贝中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制\n深拷贝在深拷贝中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给拷贝对象，深拷贝将原型对象的所有引用对象也复制一份给拷贝对象。简单来说，在深拷贝中，除了对象本身被复制外，对象所包含的所有成员变量也将复制\n\n总结简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的\n浅拷贝public class Message implements Cloneable&#123;    private String name; //姓名    private ExpenseDetail detail;//消费明细    public Message() &#123;        System.out.println(&quot;执行构造函数Message&quot;);        detail = new ExpenseDetail();    &#125;    public void setMessage(String name, String type,double money) &#123;        this.name = name;        this.detail.setType(type);        this.detail.setMoney(money);    &#125;    @NonNull    @Override    public Message clone() &#123;        Message message = null;        try &#123;            message = (Message) super.clone();        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;        return message;    &#125;    public void sendMessage()&#123;        System.out.println(name +&quot;您好：您今天&quot;+detail.getType()+&quot;消费了&quot;+detail.getMoney()+&quot;元&quot;);    &#125;&#125;\n消费明细\npublic class ExpenseDetail&#123;    private String type;    private double money;    public String getType() &#123;        return type;    &#125;    public void setType(String type) &#123;        this.type = type;    &#125;    public double getMoney() &#123;        return money;    &#125;    public void setMoney(double money) &#123;        this.money = money;    &#125;&#125;\n\npublic class MbClient &#123;    public static void main(String[] args)&#123;        Message message = new Message();        message.setMessage(&quot;张三&quot;,&quot;吃饭&quot;,10);        Message message1 = message.clone();        message1.setMessage(&quot;李四&quot;,&quot;看电影&quot;,50);        Message message2 = message.clone();        message2.setMessage(&quot;王五&quot;,&quot;买书&quot;,100);        message.sendMessage();        message1.sendMessage();        message2.sendMessage();    &#125;&#125;结果执行构造函数Message张三您好：您今天买书消费了100.0元李四您好：您今天买书消费了100.0元王五您好：您今天买书消费了100.0元\n\n我们可以看到所有人的消费明细居然都一样，这是因为Object类提供的clone方法，不会拷贝对象中的内部数组和引用对象，导致它们仍旧指向原来对象的内部元素地址，这种拷贝叫做浅拷贝。\n\n由此而导致最后一次的值会覆盖前一次的值。此时的message.getDetail = message1.getDetail =message2.getDetail\n\n深拷贝深拷贝方式有两种:继承cloneable或者进行Serializable\n继承cloneable接口public class Message implements Cloneable&#123;    ...        @NonNull    @Override    public Message clone() &#123;        Message message = null;        try &#123;            message = (Message) super.clone();            message.detail = this.detail.clone();//拷贝消费明细        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;        return message;    &#125;    ...&#125;\npublic class ExpenseDetail implements Cloneable&#123;    private String type;    private double money;    ...    @NonNull    @Override    protected ExpenseDetail clone()&#123;        ExpenseDetail detail = null;        try &#123;            detail = (ExpenseDetail) super.clone();        &#125; catch (CloneNotSupportedException e) &#123;            e.printStackTrace();        &#125;        return detail;    &#125;&#125;\n结果执行构造函数Message张三您好：您今天吃饭消费了10.0元李四您好：您今天看电影消费了50.0元王五您好：您今天买书消费了100.0元\n\n此时的message.getDetail != message1.getDetail !=message2.getDetail\n序列化实现import  java.io.*;//附件类class  Attachment implements Serializable&#123;       private  String name; //附件名       public  void setName(String name)       &#123;              this.name  = name;       &#125;       public  String getName()       &#123;              return  this.name;       &#125;     public void download()     &#123;            System.out.println(&quot;下载附件，文件名为&quot; + name);     &#125;&#125;\nimport  java.io.*;//工作周报类class  WeeklyLog implements Serializable&#123;       private  Attachment attachment;       private  String name;       private  String date;       private  String content;       public  void setAttachment(Attachment attachment) &#123;              this.attachment  = attachment;       &#125;       public  void setName(String name) &#123;              this.name  = name;       &#125;       public  void setDate(String date) &#123;              this.date  = date;       &#125;       public  void setContent(String content) &#123;              this.content  = content;       &#125;       public  Attachment getAttachment()&#123;              return  (this.attachment);       &#125;       public  String getName() &#123;              return  (this.name);       &#125;       public  String getDate() &#123;              return  (this.date);       &#125;       public  String getContent() &#123;              return  (this.content);       &#125;   //使用序列化技术实现深克隆       public WeeklyLog deepClone() throws  IOException, ClassNotFoundException, OptionalDataException       &#123;              //将对象写入流中              ByteArrayOutputStream bao=new  ByteArrayOutputStream();              ObjectOutputStream oos=new  ObjectOutputStream(bao);              oos.writeObject(this);              //将对象从流中取出              ByteArrayInputStream bis=new  ByteArrayInputStream(bao.toByteArray());              ObjectInputStream ois=new  ObjectInputStream(bis);              return  (WeeklyLog)ois.readObject();       &#125;&#125;\n工作周报类WeeklyLog不再使用Java自带的克隆机制，而是通过序列化来从头实现对象的深克隆，所以我们需要重新编写clone()方法\nclass Client&#123;       public  static void main(String args[])       &#123;              WeeklyLog  log_previous, log_new = null;              log_previous  = new WeeklyLog(); //创建原型对象              Attachment  attachment = new Attachment(); //创建附件对象              log_previous.setAttachment(attachment);  //将附件添加到周报中              try              &#123;                     log_new =  log_previous.deepClone(); //调用深克隆方法创建克隆对象                                &#125;              catch(Exception e)              &#123;                     System.err.println(&quot;克隆失败！&quot;);              &#125;              //比较周报              System.out.println(&quot;周报是否相同？ &quot; + (log_previous ==  log_new));              //比较附件              System.out.println(&quot;附件是否相同？ &quot; +  (log_previous.getAttachment() == log_new.getAttachment()));       &#125;&#125;\n周报是否相同？  false附件是否相同？  false\n此情况下：不论是基本数据类型还有引用类型，都是重新创建的\n优点\n原型模式是在内存中二进制流的拷贝，要比new一个对象的性能要好，特别是需要生产大量对象时\n\n(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。\n缺点\n直接在内存中拷贝，构造函数是不会执行的，这样就减少了约束，既是优点也是缺点，在实际开发当中应注意这个问题\n\n(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦\n适用场景(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便\n面试点\n克隆是否调用构造器方法？不会，clone方法直接复制内存中的二进制，效率高\n克隆出的对象和之前的是否一致？不一致，但是浅拷贝下引用类型对象是一致的（因为指向同一份地址），深拷贝下不一致\n改变克隆对象的值，原对象是否会变？基本类型不变，引用类型随之改变\n\n参考文献\n原型模式 | 菜鸟教程 (runoob.com)\n原型模式-Prototype Pattern - 对象的克隆——原型模式（一） - 《设计模式 Java版本》 - 书栈网 · BookStack\n设计模式之什么是原型模式 - 知乎 (zhihu.com)\n设计模式：原型模式 - 掘金 (juejin.cn)\n设计模式-原型模式 - 掘金 (juejin.cn)\n设计模式实战 - 原型模式_技术交流_牛客网 (nowcoder.com)\n看完就明白的原型模式 - 知乎 (zhihu.com)\n23 种设计模式详解（全23种）_鬼灭之刃的博客-CSDN博客_设计模式\n23种设计模式全解析 - codeTao - 博客园 (cnblogs.com)\n\n","tags":["设计模式","创建型模式"]},{"title":"关于@Autowired注解失效问题","url":"/2022/06/02/0.2.6-%E5%85%B3%E4%BA%8E-Autowired%E6%B3%A8%E8%A7%A3%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98/","content":"关于@Autowired注解扫描不到expected at least 1 bean which qualifies as autowire candidate需求：在旧的SSM项目中，经常会出现找不到Bean的情况，然后会报红色下划线解决方式：检查配置，检查注解\n@Autowiredprivate CommonService commonservice;\n\n1.检查配置文件检查spring配置文件是否有去扫描包（如果少了这一步就报错找不到Bean）\n&lt;!-- 自动扫描 --&gt;&lt;context:component-scan base-package=&quot;com.foam&quot;/&gt;\n\n2.是否有注解比如如service，repository，component，controller，Mapper等。\n@Repositorypublic interface CompanyMapper&#123;……&#125;@Servicepublic class Service&#123;……&#125;\n\n3.是否有配置监听器&lt;!-- 上下文配置文件 --&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:config/spring/spring-*.xml&lt;/param-value&gt;&lt;/context-param&gt; &lt;!-- 监听器 --&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;\n\n参考文章\nspringmvc流程分析，读取web.xml配置被扫描bean - 代码先锋\n\nexpected at least 1 bean which qualifies as autowire candidate(Spring Bean 无法注入)_熊猫同学呀的博客-CSDN博客\n\nSpringMVC自动扫描@Controller注解的bean\n\n关于@Autowired的这些新姿势，你学会了？\n\n\n","tags":["问题解析"]},{"title":"IDEA解决vue项目卡死","url":"/2022/06/02/0.2.7-IDEA%E8%A7%A3%E5%86%B3vue%E9%A1%B9%E7%9B%AE%E5%8D%A1%E6%AD%BB/","content":"IDEA解决vue项目卡死问题原因在加载vue项目的时候，把node_modules的包一起进行了加载\nidea是基于index来实现快速加载项目配置的,故所有在idea打开目录下的文件都会被索引,包括vue项目运行时产生的node_modules文件夹里的js等文件\n解决方式\n\n在Ignored Files and Folders中加入node_modules再重启一下idea就好了\n","tags":["问题解析"]},{"title":"创建型模式-工厂模式","url":"/2022/07/30/0.2.9-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","content":"\n前言工厂模式是最常用的创建型模式，分为三种：简单工厂模式，工厂方法模式和抽象工厂模式\n源码场景（后续补充）\n线程池：ThreadFactory在线程池构建 Worker 的时候会通过调用传入线程工厂对象的 newThread() 方法创建Worker 持有的线程\n日志：LoggerFactory\nSpring：BeanFactory\nMyBatis：SqlSessionFactory\n简单工厂模式简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础\n角色\nFactory 工厂角色\n工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product\n\nclass ChartFactory &#123;      //静态工厂方法      public static Chart getChart(String type) &#123;          Chart chart = null;          if (type.equalsIgnoreCase(&quot;histogram&quot;)) &#123;              chart = new HistogramChart();              System.out.println(&quot;初始化设置柱状图！&quot;);          &#125;          else if (type.equalsIgnoreCase(&quot;pie&quot;)) &#123;              chart = new PieChart();              System.out.println(&quot;初始化设置饼状图！&quot;);          &#125;        return chart;      &#125;  &#125;\n\nProduct 抽象产品角色\n它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法；它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象\n\ninterface Chart &#123;      public void display();  &#125;  \n\nConcreteProduct 具体产品角色\n它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例；每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法\n\nclass HistogramChart implements Chart &#123;      public HistogramChart() &#123;          System.out.println(&quot;创建柱状图！&quot;);      &#125;      public void display() &#123;          System.out.println(&quot;显示柱状图！&quot;);      &#125;  &#125;  \nclass PieChart implements Chart &#123;      public PieChart() &#123;          System.out.println(&quot;创建饼状图！&quot;);      &#125;      public void display() &#123;          System.out.println(&quot;显示饼状图！&quot;);      &#125;  &#125; \n\n测试class Client &#123;      public static void main(String args[]) &#123;          Chart chart;          chart = ChartFactory.getChart(&quot;histogram&quot;); //通过静态工厂方法创建产品          chart.display();      &#125;  &#125;创建柱状图！初始化设置柱状图！显示柱状图！若需要饼状图则改为chart = ChartFactory.getChart(&quot;pie&quot;);\n\n优点\n增加固定类型产品的不同具体工厂比较方便\n\n实现了对象创建和使用的分离，使用者不必关心类对象如何创建，明确了职责\n\n在需要多个相关产品的时候，仍然只需要一个工厂对象\n缺点\n由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响\n\n会增加系统中类的个数，增加了系统的复杂度和理解难度\n\n要新增产品类的时候，就要修改工厂类的代码，违反了开放封闭原则\n\n简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构\n适用场景\n工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂\n\n客户端只知道传入工厂类的参数，对于如何创建对象并不关心\n工厂方法模式简单工厂模式虽然简单，但存在一个很严重的问题当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？工厂方法模式应运而生。\n角色\nProduct 抽象产品\n它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类\n\n\n\ninterface Logger &#123;      public void writeLog();  &#125;  \n\nConcreteProduct 具体产品\n它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应\n\nclass DatabaseLogger implements Logger &#123;      public void writeLog() &#123;          System.out.println(&quot;数据库日志记录。&quot;);      &#125;  &#125;  \nclass FileLogger implements Logger &#123;      public void writeLog() &#123;          System.out.println(&quot;文件日志记录。&quot;);      &#125;  &#125;\n\nFactory 抽象工厂\n在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口\n\ninterface LoggerFactory &#123;      public Logger createLogger();  &#125;  \n\nConcreteFactory 具体工厂\n它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例\n\nclass DatabaseLoggerFactory implements LoggerFactory &#123;      public Logger createLogger() &#123;              //连接数据库，代码省略              //创建数据库日志记录器对象              Logger logger = new DatabaseLogger();               //初始化数据库日志记录器，代码省略              return logger;      &#125;     &#125; \nclass FileLoggerFactory implements LoggerFactory &#123;      public Logger createLogger() &#123;              //创建文件日志记录器对象              Logger logger = new FileLogger();               //创建文件，代码省略              return logger;      &#125;     &#125;\n\n测试class Client &#123;      public static void main(String args[]) &#123;          LoggerFactory factory;          Logger logger;          factory = new FileLoggerFactory();        logger = factory.createLogger();          logger.writeLog();      &#125;  &#125;\n\n优点\n在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名\n\n基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类\n\n使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”\n缺点\n在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销\n\n由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度\n适用场景\n客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中\n\n抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展、\n抽象工厂模式工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想\n角色\nAbstractFactory 抽象工厂\n它声明了一组用于创建一族产品的方法，每一个方法对应一种产品\n\n\n\ninterface SkinFactory &#123;      public Button createButton();      public TextField createTextField();  &#125;  \n\nConcreteFactory 具体工厂\n它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中\n\nclass SpringSkinFactory implements SkinFactory &#123;      public Button createButton() &#123;          return new SpringButton();      &#125;      public TextField createTextField() &#123;          return new SpringTextField();      &#125;  &#125;  \nclass SummerSkinFactory implements SkinFactory &#123;      public Button createButton() &#123;          return new SummerButton();      &#125;      public TextField createTextField() &#123;          return new SummerTextField();      &#125;  &#125;\n\nAbstractProduct 抽象产品\n它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法\n\ninterface Button &#123;      public void display();  &#125;  \ninterface TextField &#123;      public void display();  &#125;  \n\nConcreteProduct 具体产品\n它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法\n\nclass SpringButton implements Button &#123;      public void display() &#123;          System.out.println(&quot;显示浅绿色按钮。&quot;);      &#125;  &#125; \nclass SummerButton implements Button &#123;      public void display() &#123;          System.out.println(&quot;显示浅蓝色按钮。&quot;);      &#125;     &#125;  \nclass SpringTextField implements TextField &#123;      public void display() &#123;          System.out.println(&quot;显示绿色边框文本框。&quot;);      &#125;  &#125; \nclass SummerTextField implements TextField &#123;      public void display() &#123;          System.out.println(&quot;显示蓝色边框文本框。&quot;);      &#125;     &#125; \n\n测试class Client &#123;      public static void main(String args[]) &#123;          //使用抽象层定义          SkinFactory factory;          Button bt;          TextField tf;          factory = new SpringSkinFactory();          bt = factory.createButton();          tf = factory.createTextField();          bt.display();          tf.display();      &#125;  &#125;\n\n优点\n抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为\n\n当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象\n\n增加新的产品族很方便，无须修改已有系统，符合“开闭原则”\n缺点\n增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”\n适用场景\n一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦\n\n系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族\n\n属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型\n\n产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构\n\n\n","tags":["设计模式","创建型模式"]},{"title":"实时问题解决","url":"/2022/05/28/0.2.5-%E5%AE%9E%E6%97%B6%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/","content":"实战bug解决1.mybatisplus导致url无法访问原因：因为在application配置了componentScan去扫描了mybatisplus的mapper，导致其他的未扫描到解决方式：在自动生成的mapper上加上@mapper注解去进行组件扫描\n2.druid多数据源切换不成功，报错找不到数据库原因：boot自带的数据库配置会去扫描默认数据源，而druid的路径不一样解决方式：编写一个默认的数据源\n3.mybatisplus生成不了代码原因：freemarker模板引擎不可用解决方式：切换为velocity的模板引擎\n4.JobThread Exception:java.lang.reflect.InvocationTargetException原因：这个是xxljob定时注解导致的，和redis的缓存注解冲突了解决方式：把redis的@cacheable注解去除掉就行了\n5.驱动程序无法通过使用安全套接字层(SSL)加密与 SQL Server 建立安全连接。原因：sqlserver在1.8之前的版本安全验证不一样解决方法：把C:\\Program Files\\Java\\jdk1.8.0_301\\jre\\lib\\security下的java.security的3DES_EDE_CBC  TLSv1, TLSv1.1注释掉，网上写的只注释3DES_EDE_CBC不完全参考：https://blog.csdn.net/weixin_47180824/article/details/116236919\n6.mybatisplus生成sqlserver文件失败，SQLServerException: 列名 ‘TABLE_NAME’ 无效。原因：mybatisplus版本过高解决方法：把mybatisplus从3.3.1降为3.2.0\n7.Invalid bound statement (not found)原因：mybatis-plus.mapper-locations= classpath*:mapper/**/*.xml在配置时多打了一个空格，应该要贴着打注意：这种在xml经常会出现这种问题导致配置不生效\n8.druid中不同数据源之间的交互原因：DataSource打在controller层，如果都是在这个方法中执行，则全都会连接到一个数据源中，如果需要多数据交互，则需要给各自的server层打上该使用的数据源解决方法：把DataSource的注解打在server层\n9.mybatisplus分页不起作用，查询全数据原因：mp在官方文档有说明，默认的分页最大限制是500条每页解决办法：在mybatisplus配置文件把paginationInterceptor.setLimit(-1);设置-1，如果不设置默认是500上限\n10.多线程在跑动时会先把线程加入线程池，然后执行，redis队列会有冲突解决办法：使用阻塞队列arrayBlockQueue后续解决方法：给线程池自定义优化如下，前面使用自带的三大方法都不好用\n ExecutorService threadPool= new ThreadPoolExecutor(4,4, 10L, TimeUnit.MILLISECONDS,                new LinkedBlockingDeque&lt;&gt;(100),                Executors.defaultThreadFactory(),                new ThreadPoolExecutor.CallerRunsPolicy());\n11.mysql插入量每次只有5k左右，插入时间过长原因：mysql限制插入4M解决方案：提升每条sql内存为256M\nselect @@max_allowed_packet;SET GLOBAL max_allowed_packet=268435456;\n12.INSERT command denied原因：1.数据库没有权限，2.你的sql指定错了库名，mybatisplus自动生成会带库名\n13.Java HotSpot(TM) 64-Bit Server VM warning: INFO: os::commit_memory(0x000001fd7819d000, 2195456, 0) failed; error=’ҳ   ļ ̫С   ޷   ɲ     ‘ (DOS error/errno=1455)解决思路：增加了idea的jvm内存\n14.日期格式不正确导致每次会查询重复数据，没有后面的2702021-11-02 08:21:25.270原因：后面的270是毫秒解决方案：把原来的yyyy-MM-dd HH:mm:ss改为yyyy-MM-dd HH:mm:ss.SSS切记：s一定要大写，大写查询的是微秒，小写查询的是毫秒\n15.xxljob没有日志原因：xxljob有自带的打印日志，使用原来的logger不管用解决方案：使用xxljob自带的日志方法XxlJobHelper.log\n16.Data truncation: Incorrect datetime value原因：因为存入redis的数据为json格式，最后解析出来的数据为String类型，而数据库存储需要Date类型解决方法：把存储的数据序列化，然后取出的时候反序列化，这样可以保证数据的格式\n17.MISCONF Redis is configured to save RDB snapshots原因：redis存满了，强制把redis快照关闭了导致不能持久化解决方法：控制台输入config set stop-writes-on-bgsave-error no\n18.sql injection violation, multi-statement not allow原因：mysql的批量更新是要我们主动去设置的解决方法：在mysql连接url后面加上&amp;allowMultiQueries=true\n19.insert into select from会导致锁表解决方法：改为先删除再搜索插入，如果是小数据量插入可以忽略这个问题，但是如果涉及到金额类型，能不用就不用，很容易造成生产问题\n20.No tests found matching Method test2(io.renren.DynamicDataSourceTest) from org.junit.internal.requests.ClassRequest@7e6ef134解决方法：没加@Test注解\n21.Elementui的el-pagination分页不更新问题解决方法：:current-page.sync=”pageIndex” 使用异步吐槽：网上的方法使用if重新加载是不管用的，每次都会去默认刷新第一页，这个是大坑\n22.mybatisplus时间查询当天日期问题原因：因为数据有时分秒，然后mp里面查询的又是精确的解决方法：1.改为范围查询，查询今天到明天的时间\n2.写xml文件使用formate格式化当天时间\n","tags":["问题解析"]},{"title":"openFeign引入失败","url":"/2022/08/22/0.3.2-openFeign%E5%BC%95%E5%85%A5%E5%A4%B1%E8%B4%A5/","content":"最近用nacos集成openFeign的时候，遇到一直引入不了依赖\n&lt;!-- 添加 openfeign 框架依赖 --&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;\n一开始以为是maven源的问题，所以加了特别多的仓库都没有解决，后面试着加版本号，没想到就解决了\n&lt;!-- 添加 openfeign 框架依赖 --&gt;&lt;dependency&gt;\t&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\t&lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;\t&lt;version&gt;2.1.1.RELEASE&lt;/version&gt;&lt;/dependency&gt;\n而且在启动类中也可使用@EnableFeignClients注解如果下次引入依赖，没有指定版本，可以试试指定一下版本，最新的不行就用稳定版本\n","tags":["中间件","openFeign"]},{"title":"maven数据源","url":"/2022/08/17/0.3.1-maven%E6%95%B0%E6%8D%AE%E6%BA%90/","content":"&lt;mirror&gt;\t&lt;id&gt;aliyun-public&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun public&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-central&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun central&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-spring&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun spring&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-spring-plugin&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun spring-plugin&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-apache-snapshots&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun apache-snapshots&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-google&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun google&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/google&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-gradle-plugin&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun gradle-plugin&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/gradle-plugin&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-jcenter&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun jcenter&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/jcenter&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-releases&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun releases&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/releases&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-snapshots&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun snapshots&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/snapshots&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-grails-core&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun grails-core&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/grails-core&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-mapr-public&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun mapr-public&lt;/name&gt;\t&lt;url&gt;https://maven.aliyun.com/repository/mapr-public&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt;\t&lt;id&gt;aliyun-mapr-publicss&lt;/id&gt;\t&lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\t&lt;name&gt;aliyun mapr-publicss&lt;/name&gt;\t&lt;url&gt;https://mvnrepository.com/artifact&lt;/url&gt;&lt;/mirror&gt;\n","tags":["maven"]},{"title":"mac安装软件","url":"/2022/07/28/0.2.8-mac%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/","content":"\nJDKhttps://www.cnblogs.com/imzhizi/p/macos-jdk-installation-homebrew.html\n# 最新版 Oracle JDKbrew cask install oracle-jdk# Oracle JDK11、Oracle JDK8 需要手动下载# https://www.oracle.com/hk/java/technologies/javase-downloads.html# 最新版 Oracle OpenJDKbrew cask install java# Oracle OpenJDK11brew cask install java11# 使用该命令则安装由 Oracle 提供的最新版的 OpenJDKbrew cask install java# 使用该命令则安装由 Oracle 提供的 OpenJDK11brew cask install java11# OpenJDK 在 Oracle 不再维护后会转交给 RedHat 维护brew cask install openjdk@11# AdoptOpenJDK brew cask install AdoptOpenJDK/openjdk/adoptopenjdk8brew cask install AdoptOpenJDK/openjdk/adoptopenjdk9brew cask install AdoptOpenJDK/openjdk/adoptopenjdk10brew cask install AdoptOpenJDK/openjdk/adoptopenjdk11brew cask install AdoptOpenJDK/openjdk/adoptopenjdk12brew cask install AdoptOpenJDK/openjdk/adoptopenjdk# Azul Zulu 提供了 JDK 7# Azul Zulu 也提供其他版本的 JDK 像 zulu8、zulu11 等brew cask install homebrew/cask-versions/zulu7brew cask install homebrew/cask-versions/zulu8brew cask install homebrew/cask-versions/zulu11brew cask install homebrew/cask-versions/zulu# Apple 提供的 JDK6brew cask install homebrew/cask-versions/java6\n\nMavenbrew install maven\n\nNodebrew install node\n\nMySQLbrew install mysql\n\n设置密码mysql_secure_installation\n\n启动mysqlbrew service start mysql\n\nRedisbrew install redis// 指定版本brew install redis@3.2\n\n启动命令// 使用brew帮助我们启动软件brew services start redis\n\n关闭命令brew services stop redis\n\n查看服务进程ps axu | grep redis\n\nHomebrew用来装其他东西很方便“macOS缺失的软件包的管理器”\n/bin/zsh -c &quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;\n\n一些操作命令brew search ** //查找某个软件包brew list //列出已经安装的软件的包brew install ** //安装某个软件包,默认安装的是稳定版本brew uninstall **//卸载某个软件的包brew upgrade ** //更新某个软件包brew info ** //查看指定软件包的说明brew cache clean //清理缓存\n\nMac应用程序无法打开或文件损坏的处理方法// 方法11. 打开系统偏好设置界面，进入安全性与隐私2. 点按左下角的锁头图标，解锁更改权限3. 将允许从以下位置下载的应用，更改为 “ 任何来源 ” ，然后再打开应用即可// 方法2sudo xattr -d com.apple.quarantine /Applications/xxxx.app// 方法3sudo codesign --force --deep --sign - 文件位置（直接将应用拖进去即可）\n","tags":["软件安装"]},{"title":"对象转MAP工具类","url":"/2022/10/16/0.3.4-%E5%AF%B9%E8%B1%A1%E8%BD%ACMAP%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"package com.service.zxing.util;import java.lang.reflect.Field;import java.lang.reflect.Modifier;import java.util.HashMap;import java.util.Map;public class BeanMapUtilByReflect &#123;    /**     * 对象转Map     * @param object     * @return     * @throws IllegalAccessException     */    public static Map beanToMap(Object object) throws IllegalAccessException &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        Field[] fields = object.getClass().getDeclaredFields();        for (Field field : fields) &#123;            field.setAccessible(true);            map.put(field.getName(), field.get(object));        &#125;        return map;    &#125;    /**     * map转对象     * @param map     * @param beanClass     * @param &lt;T&gt;     * @return     * @throws Exception     */    public static &lt;T&gt; T mapToBean(Map map, Class&lt;T&gt; beanClass) throws Exception &#123;        T object = beanClass.newInstance();        Field[] fields = object.getClass().getDeclaredFields();        for (Field field : fields) &#123;            int mod = field.getModifiers();            if (Modifier.isStatic(mod) || Modifier.isFinal(mod)) &#123;                continue;            &#125;            field.setAccessible(true);            if (map.containsKey(field.getName())) &#123;                field.set(object, map.get(field.getName()));            &#125;        &#125;        return object;    &#125;&#125;","tags":["工具类"]},{"title":"驼峰命名转换工具类","url":"/2022/12/17/0.3.6-%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%BD%AC%E6%8D%A2%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"package com.tiantai.policys.commons.utils.common;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject; import java.util.*; /** * @Description JOSNObject 驼峰转换工具 * @Author WangKun * @Date 2021/9/17 15:12 * @Version */public class JSONObjectUtil &#123;      /**     * @param json     * @Description 驼峰命名转换     * @Throws     * @Return com.alibaba.fastjson.JSONObject     * @Date 2021-09-17 17:04:31     * @Author WangKun     **/    public static JSONObject humpConvertJSONObject(JSONObject json) &#123;        if (null == json) &#123;            return null;        &#125;        Set&lt;String&gt; keys = json.keySet();        String[] array = keys.toArray(new String[0]);        for (String key : array) &#123;            Object value = json.get(key);            String[] keyArray = key.toLowerCase().split(&quot;_&quot;);            if (isUpperCase(key) &amp;&amp; !key.contains(&quot;_&quot;)) &#123;                json.remove(key);                json.put(key.toLowerCase(), value);                continue;            &#125;            if (keyArray.length &gt; 1) &#123;                StringBuilder sb = new StringBuilder();                for (int i = 0; i &lt; keyArray.length; i++) &#123;                    String ks = keyArray[i];                    if (!&quot;&quot;.equals(ks)) &#123;                        if (i == 0) &#123;                            sb.append(ks);                        &#125; else &#123;                            int c = ks.charAt(0);                            if (c &gt;= 97 &amp;&amp; c &lt;= 122) &#123;                                int v = c - 32;                                sb.append((char) v);                                if (ks.length() &gt; 1) &#123;                                    sb.append(ks.substring(1));                                &#125;                            &#125; else &#123;                                sb.append(ks);                            &#125;                        &#125;                    &#125;                &#125;                json.remove(key);                json.put(sb.toString(), value);            &#125;        &#125;        return json;    &#125;     /**     * @param objectList     * @Description 驼峰转换     * @Throws     * @Return java.util.List&lt;com.alibaba.fastjson.JSONObject&gt;     * @Date 2021-09-17 17:09:15     * @Author WangKun     **/    public static List&lt;JSONObject&gt; humpConvertListObject(List&lt;JSONObject&gt; objectList) &#123;        if (null == objectList || objectList.size() &lt;= 0) &#123;            return null;        &#125;        List&lt;JSONObject&gt; data = new ArrayList&lt;&gt;();        for (JSONObject object : objectList) &#123;            data.add(humpConvertJSONObject(object));        &#125;        return data;    &#125;     /**     * @param array     * @Description 驼峰转换     * @Throws     * @Return java.util.List&lt;com.alibaba.fastjson.JSONObject&gt;     * @Date 2021-09-17 17:13:22     * @Author WangKun     **/    public static List&lt;JSONObject&gt; humpConvertJSONArray(JSONArray array) &#123;        if (null == array || array.size() &lt;= 0) &#123;            return null;        &#125;        List&lt;JSONObject&gt; data = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; array.size(); i++) &#123;            data.add(humpConvertJSONObject(array.getJSONObject(i)));        &#125;        return data;    &#125;     /**     * @param str     * @Description 判断字符串字母是否为大写     * @Throws     * @Return boolean     * @Date 2021-09-17 17:03:50     * @Author WangKun     **/    public static boolean isUpperCase(String str) &#123;        for (int i = 0; i &lt; str.length(); i++) &#123;            char c = str.charAt(i);            if (c &gt;= 97 &amp;&amp; c &lt;= 122) &#123;                return false;            &#125;        &#125;        return true;    &#125;      public static void main(String[] args) &#123;        JSONObject jsonObject = new JSONObject();        jsonObject.put(&quot;QWE_QWE1&quot;,&quot;1&quot;);        jsonObject.put(&quot;qwe_qwe2&quot;,&quot;2&quot;);        jsonObject.put(&quot;qwe_Qwe3&quot;,&quot;3&quot;);        jsonObject.put(&quot;QWEQWE4&quot;,&quot;4&quot;);        jsonObject.put(&quot;qweqwe5&quot;,&quot;5&quot;);        jsonObject.put(&quot;qweQwe6&quot;,&quot;6&quot;);        System.out.println(humpConvertJSONObject(jsonObject));     &#125; &#125;","tags":["工具类"]},{"title":"ArrayList和LinkedList区别","url":"/2023/02/06/0.3.7-ArrayList%E5%92%8CLinkedList%E5%8C%BA%E5%88%AB/","content":"这是一道比较经典的面试题\n主要不同点：\n数据结构不同\n\n效率不同\n\n空间灵活性和占用内存不同\n注意点：\n在新建ArrayList的时候最好指定初始化大小，防止频繁扩容影响效率\n\n在jdk1.7中ArrayList默认初始化大小为10，每次扩容0.5(1.5倍)【饿汉式】\n\n在jdk1.8中ArrayList默认为空数组，第一次add的时候会设置为10，如果满了再自动扩容【懒汉式】\n\n\n\n1.LinkedList实现了Deque接口，可以作为双端队列使用\n2.因为数据结构不同，ArrayList是数组结构，LinkedList是双向链表结构\nArrayList指定下标查询的时候有优势，因为数组是提前分配好内存空间的\n\nLinkedList指定下标（get）查询时候需要去遍历这个链表，才能找到指定下标位置\n\n当Linkedlist获取第一个元素（getFirst）和最后一个元素（getLast）的速度也是非常快的\n原因：在LinkedList中有两个属性，first和last它俩会一直持续记录着第一个元素和最后一个元素的位置（不会涉及到遍历操作）3.由于底层数据结构不同，ArrayList更适合随机查找,LinkedList更适合删除和添加\n\n\n\n\n当随机访问List（get和set操作）时，ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。ArrayList对于数据查询非常快，但是插入与删除元素比较慢\n\n当对数据进行增加和删除的操作(add和remove操作)时，LinkedList是恰好相反的，它的查询速度非常慢，但是插入与删除元素的速度非常快。\n\nArrayList进行新增Add操作的时候，会把当前待插入元素添加到最后的一个位置\n\n\n\n\n如果不需要进行扩容是非常快速的，如果需要扩容会有扩容成本\n\n\n\n如果数组指定的位置有元素了，则会把指定元素后的元素挨个往后移动，会导致效率低\narraylist.add(1,1);\nLinkedList进行新增Add操作的时候，只需要遍历找到对应下标，然后替换对应元素的next和prev的操作\n\n\n\n\nLinkedList没有扩容操作，因为是链表结构，只需要指定下一个节点\n\n","tags":["基础"]},{"title":"实体类设计","url":"/2023/02/26/0.3.9-%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%AE%BE%E8%AE%A1/","content":"DDD领域驱动设计（Domain-driven design）介绍领域驱动设计：是一种通过将实现连接到持续进化的模型来满足复杂需求的软件开发方法（一种解决业务复杂性的设计思想，不是一种标准规则的解决方法）领域模型是对业务模型的抽象，DDD是把业务模型翻译成系统架构设计的一种方式\n失血模型\n模型仅仅包含对象属性的定义和操作对象的getter/setter方法其它所有的业务逻辑完全由业务逻辑层去实现，这种类叫POJO\n\n优点：对象结构简单缺点：会导致业务逻辑层臃肿，难于理解和维护，无法良好的扩展复杂业务逻辑和场景\n@Datapublic class person &#123;    private String name;    private String sex;    private Integer age;&#125;\n贫血模型\n模型包含了对象属性的定义和操作对象的getter/setter方法并且包含了对象的行为【是完整的一个对象】属性：姓名，性别，年龄等行为：走路，吃饭，睡觉等不包括依赖持久层的业务逻辑，这部分持久层的数据还是在业务逻辑层去实现，组合逻辑也是服务类负责\n\n优点：层次结构清楚，在少量业务逻辑的服务中，容易理解，调用方无需理解内部逻辑缺点：在复杂的逻辑和场景不太适用\n@Datapublic class person &#123;    private String name;    private String sex;    private Integer age;    // 走路    public void walking()&#123;&#125;    // 吃东西    public void eating()&#123;&#125;    // 睡觉    public void sleeping()&#123;&#125;    &#125;\n充血模型\n模型包含了对象属性的定义和操作对象的getter/setter方法并且包含了对象的行为，大多数相关的业务逻辑和持久层业务逻辑业务逻辑层（Business Logic）的业务逻辑减少，仅仅是简单封装少量业务，事务控制，权限控制等等，不和持久层打交道充血模型是依赖持久层的\n\n优点：符合OO（面向对象）原则，业务逻辑层很薄，符合单一职责，不像贫血模型那么业务逻辑沉重缺点：业务逻辑不好划分，哪些业务要放在领域对象，哪些业务要放在业务逻辑层需要开发自己去判断，其次控制事务的时候要重新包装一遍，有点冗余\n@Datapublic class person &#123;    private String name;    private String sex;    private Integer age;    // 走路    public void walking(String address)&#123;&#125;    // 吃东西    public void eating()&#123;&#125;    // 睡觉    public void sleeping()&#123;&#125;\t// 业务逻辑层    private PersonDao personDao;    // 查看地图再走路(问路)    public void askingTheWay()&#123;       MapObject mapObject = personDao.getMap();       walking(mapObject.getAddress());    &#125;&#125;\npublic class PersonDao &#123;\tprivate PersonMapping personMapping;\t    // 获取地图    public MapObject getMap()&#123;\t\tpersonMapping.getMap();\t&#125;&#125;\n胀血模型\n模型包含了对象属性的定义和操作对象的getter/setter方法并且包含了对象的行为，所有的业务逻辑，也包含了不相干的其它模块逻辑（如授权，事务等）相当与直接去掉了业务逻辑层，只有领域对象和持久层，所有的逻辑在领域对象上面\n\n优点：简化代码分层体系，符合面向对象设计缺点：取消了业务逻辑层，会导致领域对象变得臃肿，而且容易逻辑混乱，对于代码的理解和维护性变差\n@Datapublic class person &#123;    private String name;    private String sex;    private Integer age;    // 走路    public void walking(String address)&#123;&#125;    // 吃东西    public void eating()&#123;&#125;    // 睡觉    public void sleeping()&#123;&#125;\t// 业务逻辑层    private PersonMapping personMapping;    // 查看地图再走路(问路)    public void askingTheWay()&#123;       MapObject mapObject = personMapping.getMap();       walking(mapObject.getAddress());    &#125;&#125;\n开发规范PO(Persistent Object)等同于DO(Data Object)\n持久层对象它是由一组属性和属性的get和set方法组成，最简单的 PO 就是对应数据库中某个表中的一条记录（也就是说，我们可以将数据库表中的一条记录理解为一个持久层对象），多个记录可以用 PO 的集合，PO 中应该不包含任何对数据库的操作。PO 的属性是跟数据库表的字段一一对应的，此外 PO 对象需要实现序列化接口。\n\nssm框架开发中一般定义为entity层\nBO(Business Object)\n业务层对象，是简单的真实世界的软件抽象，通常位于中间层。BO 的主要作用是把业务逻辑封装为一个对象，这个对象可以包括一个或多个其它的对象。举一个求职简历的例子，每份简历都包括教育经历、项目经历等，我们可以让教育经历和项目经历分别对应一个 PO，这样在我们建立对应求职简历的 BO 对象处理简历的时候，让每个 BO 都包含这些 PO 即可\n\n用于业务逻辑传输层\nVO(Value Object)\n值对象，通常用于业务层之间的数据传递，和 PO 一样也是仅仅包含数据而已，但 VO 应该是抽象出的业务对象，可以和表对应，也可以不对应，这根据业务的需要。 如果锅碗瓢盆分别为对应的业务对象的话，那么整个碗柜就是一个值对象。此外，VO 也可以称为页面对象，如果称为页面对象的话，那么它所代表的将是整个页面展示层的对象，也可以由需要的业务对象进行组装而来。\n\n用于返回给前端\nDTO(Data Transfer Object)\n数据传输对象，主要用于远程调用等需要大量传输对象的地方，比如我们有一个交易订单表，含有 25 个字段，那么其对应的 PO 就有 25 个属性，但我们的页面上只需要显示 5 个字段，因此没有必要把整个 PO 对象传递给客户端，这时我们只需把仅有 5 个属性的 DTO 把结果传递给客户端即可，而且如果用这个对象来对应界面的显示对象，那此时它的身份就转为 VO。使用 DTO 的好处有两个一是能避免传递过多的无用数据，提高数据的传输速度；二是能隐藏后端的表结构。常见的用法是：将请求的数据或属性组装成一个 RequestDTO，再将响应的数据或属性组装成一个 ResponseDTO\n\n用于接收来自客户端的参数，用于封装数据库查询的结果对象\nTO(Transfer Object)\n不同的应用程序之间传输的对象\n\n\n实体类之间互相转换@Data@Builderpublic class Person &#123;    private String name;    private String sex;    private Integer age;&#125;\n@Data@Builderpublic class Teacher &#123;    private String name;    private String sex;    private Integer ages;    private String classes;    private String course;&#125;\n将person转换为teacher\n方法1：写一个转换工具类，不同对象之间进行赋值\npublic class PersonUtils &#123;    public static Teacher convert(Person person)&#123;        return Teacher.builder()                .name(person.getName())                .ages(person.getAge())                .sex(person.getSex())                .build();    &#125;&#125;\n调用\n@Slf4jpublic class PersonTest &#123;    @Test    public void convert()&#123;        Person person = Person.builder().name(&quot;张三&quot;).sex(&quot;男&quot;).age(30).build();        Teacher teacher2 = PersonUtils.convert(person);        log.info(teacher2.toString());\t\t// 18:05:00.431 [main] INFO com.tiantai.policys.PersonTest - Teacher(name=张三, sex=男, ages=30, classes=null, course=null)    &#125;&#125;\n方法2：使用mapstruct\n@Mapper(builder = @Builder(disableBuilder = true))public interface PersonToTeacher &#123;    PersonToTeacher INSTANCE = Mappers.getMapper(PersonToTeacher.class);    @Mapping(source = &quot;age&quot;,target = &quot;ages&quot;)    Teacher convert(Person person);&#125;\n调用\n@Slf4jpublic class PersonTest &#123;    @Test    public void convert()&#123;        Person person = Person.builder().name(&quot;张三&quot;).sex(&quot;男&quot;).age(30).build();        Teacher teacher2 = PersonUtils.convert(person);        log.info(teacher2.toString());\t\t// 18:05:00.431 [main] INFO com.tiantai.policys.PersonTest - Teacher(name=张三, sex=男, ages=30, classes=null, course=null)    &#125;&#125;\n推荐使用mapstruct，在不同的PO,BO,DTO等等之间进行转换，如果属性名称相近的话，转换速度比较快，更适合使用\n\n\n","tags":["实体类"]},{"title":"网页添加L2D猫","url":"/2022/07/30/0.3.0-%E7%BD%91%E9%A1%B5%E6%B7%BB%E5%8A%A0L2D%E7%8C%AB/","content":"&lt;!DOCTYPE html&gt;&lt;!-- saved from url=(0047)https://www.cnblogs.com/icemomo/p/16004713.html --&gt;&lt;html lang=&quot;zh-cn&quot; style=&quot;--olcb-folder-code-block-max-height:80vh;&quot; class=&quot;windows desktop landscape&quot; mode=&quot;light&quot; theme=&quot;a&quot;&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta name=&quot;referrer&quot; content=&quot;origin-when-cross-origin&quot;&gt;    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot;&gt;    &lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;&lt;style type=&quot;text/css&quot;&gt;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#x27;&#x27;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&lt;/style&gt;&lt;meta http-equiv=&quot;origin-trial&quot; content=&quot;AzoawhTRDevLR66Y6MROu167EDncFPBvcKOaQispTo9ouEt5LvcBjnRFqiAByRT+2cDHG1Yj4dXwpLeIhc98/gIAAACFeyJvcmlnaW4iOiJodHRwczovL2RvdWJsZWNsaWNrLm5ldDo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjYxMjk5MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ==&quot;&gt;&lt;meta http-equiv=&quot;origin-trial&quot; content=&quot;A6+nc62kbJgC46ypOwRsNW6RkDn2x7tgRh0wp7jb3DtFF7oEhu1hhm4rdZHZ6zXvnKZLlYcBlQUImC4d3kKihAcAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXN5bmRpY2F0aW9uLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjYxMjk5MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ==&quot;&gt;&lt;meta http-equiv=&quot;origin-trial&quot; content=&quot;A/9La288e7MDEU2ifusFnMg1C2Ij6uoa/Z/ylwJIXSsWfK37oESIPbxbt4IU86OGqDEPnNVruUiMjfKo65H/CQwAAACLeyJvcmlnaW4iOiJodHRwczovL2dvb2dsZXRhZ3NlcnZpY2VzLmNvbTo0NDMiLCJmZWF0dXJlIjoiUHJpdmFjeVNhbmRib3hBZHNBUElzIiwiZXhwaXJ5IjoxNjYxMjk5MTk5LCJpc1N1YmRvbWFpbiI6dHJ1ZSwiaXNUaGlyZFBhcnR5Ijp0cnVlfQ==&quot;&gt;&lt;script src=&quot;./Java读取配置文件的几种方式 - 冰莫莫 - 博客园_files/pubads_impl_2022071401.js.下载&quot; async=&quot;&quot;&gt;&lt;/script&gt;&lt;script src=&quot;./Java读取配置文件的几种方式 - 冰莫莫 - 博客园_files/L2Dwidget.min.js.下载&quot;&gt;&lt;/script&gt;&lt;style&gt;  .live2d-widget-dialog-container &#123;    width: 300px;    height: 120px;    position: absolute;    bottom: 65%;    right: 0px;    transform-origin: right;    padding: 12px;    box-sizing: border-box;    -webkit-font-smoothing: antialiased;  &#125;  .live2d-widget-dialog &#123;    width: 100%;    height: 100%;    color: #917159;    font-size: 16px;    padding: 12px;    border: 2px solid rgb(236, 203, 180);    background: rgba(236, 203, 180, 0.14);    box-sizing: border-box;    border-radius: 10px;    transform: rotate(-2deg);    opacity: 0;    transition: 200ms opacity;    box-shadow: rgba(0, 0, 0, 0.12) 0px 1px 6px, rgba(0, 0, 0, 0.12) 0px 1px 4px;    animation: live2d-widget-dialog-tingle 4s ease-in-out 0s infinite alternate;  &#125;  @keyframes live2d-widget-dialog-tingle &#123;    0% &#123; transform: translate(-1px, 1.5px) rotate(-2deg); &#125;    100% &#123; transform: translate(1px, -1.5px) rotate(2deg); &#125;  &#125;&lt;/style&gt;&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; async=&quot;&quot; src=&quot;./Java读取配置文件的几种方式 - 冰莫莫 - 博客园_files/L2Dwidget.0.min.js.下载&quot;&gt;&lt;/script&gt;&lt;body class=&quot;skin-custom no-navbar hljs-engine&quot;&gt;&lt;script type=&quot;text/javascript&quot;&gt;   L2Dwidget.init(     　&#123;　&quot;model&quot;: &#123; 　　　　jsonPath: &quot;https://unpkg.com/live2d-widget-model-hijiki@1.0.5/assets/hijiki.model.json&quot;,//这是插件模型，可以任意选择想要添加的2d动画　　　　&quot;scale&quot;: 1 　　&#125;&#125;,         &#123;      &quot;display&quot;: &#123;        &quot;superSample&quot;: 2,        &quot;width&quot;: 200,//宽度        &quot;height&quot;: 400,//高度        &quot;position&quot;: &quot;left&quot;,//位置，right,left                &quot;hOffset&quot;: 0,        &quot;vOffset&quot;: 0      &#125;   &#125;);  window.$silence = &#123;          defaultTheme: &#x27;c&#x27;,      navbars: [        &#123;        title: &#x27;首页&#x27;,        url: &#x27;https://www.cnblogs.com/icemomo&#x27;    &#125;,        &#123;        title: &#x27;标签&#x27;,        url: &#x27;https://www.cnblogs.com/icemomo/tag/&#x27;    &#125;],    favicon:&#x27;https://blog-static.cnblogs.com/files/blogs/740138/anido-geh1u-001.ico?t=1646927784&#x27;,     defaultMode: &#x27;auto&#x27;,    hljsln: true,        catalog: &#123;        enable: true,        index: true,        active: false,        levels: [&#x27;h2&#x27;, &#x27;h3&#x27;, &#x27;h4&#x27;]    &#125;,    avatar:&#x27;https://s1.ax1x.com/2022/03/10/b5p0e0.jpg&#x27;,    enable:true,      signature: &#123;        enable: true,        author: null,        license: [&#x27;署名-非商业性使用-相同方式共享 4.0 国际&#x27;, &#x27;https://creativecommons.org/licenses/by-nc-sa/4.0/&#x27;],        remark: &#x27;转载请注明出处&#x27;,    &#125;,    github: &#x27;https://github.com/icemomo-hgy&#x27;,     sponsor: &#123;        enable: false,        text: &#x27;&#x27;,        wechat: &#x27;https://s1.ax1x.com/2022/03/10/b5StDx.jpg&#x27;,        alipay:  &#x27;https://images.cnblogs.com/cnblogs_com/blogs/740138/galleries/2122692/o_220311012057_d8cb988f0f3669b0e9d18b910d05514.jpg&#x27;    &#125;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n/*! https://github.com/xiazeyu/live2d-widget.js built@2019-4-2 16:24:00 */webpackJsonpL2Dwidget([0],&#123;79:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.captureFrame=e.theRealInit=void 0;var r,o=i(26),n=i(83),s=i(80),_=i(81),a=i(86),h=i(84),l=i(82),$=i(39),u=(r=$)&amp;&amp;r.__esModule?r:&#123;default:r&#125;;var p=null,c=void 0,f=!1,g=null,y=null,d=null,m=null,T=!1,P=.5,S=null;function v(t,e,i)&#123;if(e.x&lt;i.left+i.width&amp;&amp;e.y&lt;i.top+i.height&amp;&amp;e.x&gt;i.left&amp;&amp;e.y&gt;i.top)return e;var r=t.x-e.x,o=t.y-e.y;function n(t,e)&#123;return 180*Math.acos((i=&#123;x:0,y:1&#125;,o=t,n=e,s=Math.sqrt(o*o+n*n),r=&#123;x:o/s,y:n/s&#125;,i.x*r.x+i.y*r.y))/Math.PI;var i,r,o,n,s&#125;var s=n(r,o);e.x&lt;t.x&amp;&amp;(s=360-s);var _=360-n(i.left-t.x,-1*(i.top-t.y)),a=360-n(i.left-t.x,-1*(i.top+i.height-t.y)),h=n(i.left+i.width-t.x,-1*(i.top-t.y)),l=n(i.left+i.width-t.x,-1*(i.top+i.height-t.y)),$=o/r,u=&#123;&#125;;if(s&lt;h)&#123;var p=i.top-t.y,c=p/$;u=&#123;y:t.y+p,x:t.x+c&#125;&#125;else if(s&lt;l)&#123;var f=i.left+i.width-t.x,g=f*$;u=&#123;y:t.y+g,x:t.x+f&#125;&#125;else if(s&lt;a)&#123;var y=i.top+i.height-t.y,d=y/$;u=&#123;y:t.y+y,x:t.x+d&#125;&#125;else if(s&lt;_)&#123;var m=t.x-i.left,T=m*$;u=&#123;y:t.y-T,x:t.x-m&#125;&#125;else&#123;var P=i.top-t.y,S=P/$;u=&#123;y:t.y+P,x:t.x+S&#125;&#125;return u&#125;function L(t)&#123;T=!0;var e=n.currCanvas.getBoundingClientRect(),i=w(t.clientX-e.left),r=D(t.clientY-e.top),o=v(&#123;x:e.left+e.width/2,y:e.top+e.height*P&#125;,&#123;x:t.clientX,y:t.clientY&#125;,e),s=x(o.x-e.left),_=I(o.y-e.top);l.cDefine.DEBUG_MOUSE_LOG&amp;&amp;console.log(&quot;modelTapEvent onMouseDown device( x:&quot;+t.clientX+&quot; y:&quot;+t.clientY+&quot; ) view( x:&quot;+s+&quot; y:&quot;+_+&quot;)&quot;),i,r,S.emit(&quot;tap&quot;,t),p.tapEvent(s,_)&#125;function M()&#123;T&amp;&amp;(T=!1),g.setPoint(0,0)&#125;function E(t)&#123;if(&quot;mousedown&quot;==t.type)L(t);else if(&quot;mousemove&quot;==t.type)!function(t)&#123;T=!0;var e=n.currCanvas.getBoundingClientRect(),i=w(t.clientX-e.left),r=D(t.clientY-e.top),o=v(&#123;x:e.left+e.width/2,y:e.top+e.height*P&#125;,&#123;x:t.clientX,y:t.clientY&#125;,e),s=x(o.x-e.left),_=I(o.y-e.top);l.cDefine.DEBUG_MOUSE_LOG&amp;&amp;console.log(&quot;modelTurnHead onMouseMove device( x:&quot;+t.clientX+&quot; y:&quot;+t.clientY+&quot; ) view( x:&quot;+s+&quot; y:&quot;+_+&quot;)&quot;),i,r,g.setPoint(s,_)&#125;(t);else if(&quot;mouseup&quot;==t.type)&#123;if(&quot;button&quot;in t&amp;&amp;0!=t.button)return&#125;else&quot;mouseleave&quot;==t.type&amp;&amp;M()&#125;function A(t)&#123;var e,i,r,o,s,_,a,h=t.touches[0];&quot;touchstart&quot;==t.type?1==t.touches.length&amp;&amp;L(h):&quot;touchmove&quot;==t.type?(e=h,i=n.currCanvas.getBoundingClientRect(),r=w(e.clientX-i.left),o=D(e.clientY-i.top),s=v(&#123;x:i.left+i.width/2,y:i.top+i.height*P&#125;,&#123;x:e.clientX,y:e.clientY&#125;,i),_=x(s.x-i.left),a=I(s.y-i.top),l.cDefine.DEBUG_MOUSE_LOG&amp;&amp;console.log(&quot;followPointer onMouseMove device( x:&quot;+e.clientX+&quot; y:&quot;+e.clientY+&quot; ) view( x:&quot;+_+&quot; y:&quot;+a+&quot;)&quot;),T&amp;&amp;(r,o,g.setPoint(_,a))):&quot;touchend&quot;==t.type&amp;&amp;M()&#125;function x(t)&#123;var e=m.transformX(t);return y.invertTransformX(e)&#125;function I(t)&#123;var e=m.transformY(t);return y.invertTransformY(e)&#125;function w(t)&#123;return m.transformX(t)&#125;function D(t)&#123;return m.transformY(t)&#125;e.theRealInit=function(t)&#123;(0,n.createElement)(),n.currCanvas.addEventListener&amp;&amp;(window.addEventListener(&quot;click&quot;,E),window.addEventListener(&quot;mousedown&quot;,E),window.addEventListener(&quot;mousemove&quot;,E),window.addEventListener(&quot;mouseup&quot;,E),document.addEventListener(&quot;mouseleave&quot;,E),window.addEventListener(&quot;touchstart&quot;,A),window.addEventListener(&quot;touchend&quot;,A),window.addEventListener(&quot;touchmove&quot;,A)),p=new a.cManager(S),g=new _.L2DTargetPoint;var e,i,r=n.currCanvas.getBoundingClientRect(),$=r.height/r.width,T=l.cDefine.VIEW_LOGICAL_LEFT,P=l.cDefine.VIEW_LOGICAL_RIGHT,v=-$,L=$;(y=new _.L2DViewMatrix).setScreenRect(T,P,v,L),y.setMaxScreenRect(l.cDefine.VIEW_LOGICAL_MAX_LEFT,l.cDefine.VIEW_LOGICAL_MAX_RIGHT,l.cDefine.VIEW_LOGICAL_MAX_BOTTOM,l.cDefine.VIEW_LOGICAL_MAX_TOP),e=u.default.mobile()&amp;&amp;o.config.mobile.scale||o.config.model.scale,y.adjustScale(0,0,e),(d=new _.L2DMatrix44).multScale(1,r.width/r.height),(m=new _.L2DMatrix44).multTranslate(-r.width/2,-r.height/2),m.multScale(2/r.width,-2/r.height),s.Live2D.setGL(n.currWebGL),n.currWebGL.clearColor(0,0,0,0),i=o.config.model.jsonPath,p.reloadFlg=!0,p.count++,p.changeModel(n.currWebGL,i),f||(f=!0,function t()&#123;!function()&#123;h.MatrixStack.reset(),h.MatrixStack.loadIdentity(),g.update(),p.setDrag(g.getX(),g.getY()),n.currWebGL.clear(n.currWebGL.COLOR_BUFFER_BIT),h.MatrixStack.multMatrix(d.getArray()),h.MatrixStack.multMatrix(y.getArray()),h.MatrixStack.push();for(var t=0;t&lt;p.numModels();t++)&#123;var e=p.getModel(t);if(null==e)return;e.initialized&amp;&amp;!e.updating&amp;&amp;(e.update(),e.draw(n.currWebGL))&#125;h.MatrixStack.pop()&#125;();var e=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;e(t,n.currCanvas),void 0!==c&amp;&amp;(c(n.currCanvas.toDataURL()),c=void 0)&#125;())&#125;,e.captureFrame=function(t)&#123;c=t&#125;&#125;,80:function(t,e,i)&#123;&quot;use strict&quot;;(function(t)&#123;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;);var i=!0;function r()&#123;i||(this._$MT=null,this._$5S=null,this._$NP=0,r._$42++,this._$5S=new U(this))&#125;function o(t)&#123;if(!i)&#123;this.clipContextList=new Array,this.glcontext=t.gl,this.dp_webgl=t,this.curFrameNo=0,this.firstError_clipInNotUpdate=!0,this.colorBuffer=0,this.isInitGLFBFunc=!1,this.tmpBoundsOnModel=new P,_t.glContext.length&gt;_t.frameBuffers.length&amp;&amp;(this.curFrameNo=this.getMaskRenderTexture()),this.tmpModelToViewMatrix=new O,this.tmpMatrix2=new O,this.tmpMatrixForMask=new O,this.tmpMatrixForDraw=new O,this.CHANNEL_COLORS=new Array;var e=new E;(e=new E).r=0,e.g=0,e.b=0,e.a=1,this.CHANNEL_COLORS.push(e),(e=new E).r=1,e.g=0,e.b=0,e.a=0,this.CHANNEL_COLORS.push(e),(e=new E).r=0,e.g=1,e.b=0,e.a=0,this.CHANNEL_COLORS.push(e),(e=new E).r=0,e.g=0,e.b=1,e.a=0,this.CHANNEL_COLORS.push(e);for(var r=0;r&lt;this.CHANNEL_COLORS.length;r++)this.dp_webgl.setChannelFlagAsColor(r,this.CHANNEL_COLORS[r])&#125;&#125;function n(t,e,i)&#123;this.clipIDList=new Array,this.clipIDList=i,this.clippingMaskDrawIndexList=new Array;for(var r=0;r&lt;i.length;r++)this.clippingMaskDrawIndexList.push(e.getDrawDataIndex(i[r]));this.clippedDrawContextList=new Array,this.isUsing=!0,this.layoutChannelNo=0,this.layoutBounds=new P,this.allClippedDrawRect=new P,this.matrixForMask=new Float32Array(16),this.matrixForDraw=new Float32Array(16),this.owner=t&#125;function s()&#123;i||(this._$dP=null,this._$eo=null,this._$V0=null,this._$dP=1e3,this._$eo=1e3,this._$V0=1,this._$a0())&#125;function _()&#123;&#125;function a()&#123;i||(this.x=null,this.y=null,this.width=null,this.height=null)&#125;function h(t)&#123;i||it.prototype.constructor.call(this,t)&#125;function l(t)&#123;i||it.prototype.constructor.call(this,t)&#125;function $()&#123;i||(this._$vo=null,this._$F2=null,this._$ao=400,this._$1S=400,$._$42++)&#125;function u()&#123;i||(this.p1=new p,this.p2=new p,this._$Fo=0,this._$Db=0,this._$L2=0,this._$M2=0,this._$ks=0,this._$9b=0,this._$iP=0,this._$iT=0,this._$lL=new Array,this._$qP=new Array,this.setup(.3,.5,.1))&#125;function p()&#123;this._$p=1,this.x=0,this.y=0,this.vx=0,this.vy=0,this.ax=0,this.ay=0,this.fx=0,this.fy=0,this._$s0=0,this._$70=0,this._$7L=0,this._$HL=0&#125;function c(t,e,i)&#123;this._$wL=null,this.scale=null,this._$V0=null,this._$wL=t,this.scale=e,this._$V0=i&#125;function f(t,e,i,r)&#123;c.prototype.constructor.call(this,e,i,r),this._$tL=null,this._$tL=t&#125;function g(t,e,i)&#123;this._$wL=null,this.scale=null,this._$V0=null,this._$wL=t,this.scale=e,this._$V0=i&#125;function y(t,e,i,r)&#123;g.prototype.constructor.call(this,e,i,r),this._$YP=null,this._$YP=t&#125;function d()&#123;i||(this._$fL=0,this._$gL=0,this._$B0=1,this._$z0=1,this._$qT=0,this.reflectX=!1,this.reflectY=!1)&#125;r._$0s=1,r._$4s=2,r._$42=0,r._$62=function(t,e)&#123;try&#123;if(e instanceof ArrayBuffer&amp;&amp;(e=new DataView(e)),!(e instanceof DataView))throw new ht(&quot;_$SS#loadModel(b) / b _$x be DataView or ArrayBuffer&quot;);var i,o=new Pt(e),n=o._$ST(),s=o._$ST(),a=o._$ST();if(109!=n||111!=s||99!=a)throw new ht(&quot;_$gi _$C _$li , _$Q0 _$P0.&quot;);if(i=o._$ST(),o._$gr(i),i&gt;G._$T7)throw t._$NP|=r._$4s,new ht(&quot;_$gi _$C _$li , _$n0 _$_ version _$li ( SDK : &quot;+G._$T7+&quot; &lt; _$f0 : &quot;+i+&quot; )@_$SS#loadModel()\\n&quot;);var h=o._$nP();if(i&gt;=G._$s7)&#123;var l=o._$9T(),$=o._$9T();if(-30584!=l||-30584!=$)throw t._$NP|=r._$0s,new ht(&quot;_$gi _$C _$li , _$0 _$6 _$Ui.&quot;)&#125;t._$KS(h);var u=t.getModelContext();u.setDrawParam(t.getDrawParam()),u.init()&#125;catch(t)&#123;_._$Rb(t)&#125;&#125;,r.prototype._$KS=function(t)&#123;this._$MT=t&#125;,r.prototype.getModelImpl=function()&#123;return null==this._$MT&amp;&amp;(this._$MT=new $,this._$MT._$zP()),this._$MT&#125;,r.prototype.getCanvasWidth=function()&#123;return null==this._$MT?0:this._$MT.getCanvasWidth()&#125;,r.prototype.getCanvasHeight=function()&#123;return null==this._$MT?0:this._$MT.getCanvasHeight()&#125;,r.prototype.getParamFloat=function(t)&#123;return&quot;number&quot;!=typeof t&amp;&amp;(t=this._$5S.getParamIndex(l.getID(t))),this._$5S.getParamFloat(t)&#125;,r.prototype.setParamFloat=function(t,e,i)&#123;&quot;number&quot;!=typeof t&amp;&amp;(t=this._$5S.getParamIndex(l.getID(t))),arguments.length&lt;3&amp;&amp;(i=1),this._$5S.setParamFloat(t,this._$5S.getParamFloat(t)*(1-i)+e*i)&#125;,r.prototype.addToParamFloat=function(t,e,i)&#123;&quot;number&quot;!=typeof t&amp;&amp;(t=this._$5S.getParamIndex(l.getID(t))),arguments.length&lt;3&amp;&amp;(i=1),this._$5S.setParamFloat(t,this._$5S.getParamFloat(t)+e*i)&#125;,r.prototype.multParamFloat=function(t,e,i)&#123;&quot;number&quot;!=typeof t&amp;&amp;(t=this._$5S.getParamIndex(l.getID(t))),arguments.length&lt;3&amp;&amp;(i=1),this._$5S.setParamFloat(t,this._$5S.getParamFloat(t)*(1+(e-1)*i))&#125;,r.prototype.getParamIndex=function(t)&#123;return this._$5S.getParamIndex(l.getID(t))&#125;,r.prototype.loadParam=function()&#123;this._$5S.loadParam()&#125;,r.prototype.saveParam=function()&#123;this._$5S.saveParam()&#125;,r.prototype.init=function()&#123;this._$5S.init()&#125;,r.prototype.update=function()&#123;this._$5S.update()&#125;,r.prototype._$Rs=function()&#123;return _._$li(&quot;_$60 _$PT _$Rs()&quot;),-1&#125;,r.prototype._$Ds=function(t)&#123;_._$li(&quot;_$60 _$PT _$SS#_$Ds() \\n&quot;)&#125;,r.prototype._$K2=function()&#123;&#125;,r.prototype.draw=function()&#123;&#125;,r.prototype.getModelContext=function()&#123;return this._$5S&#125;,r.prototype._$s2=function()&#123;return this._$NP&#125;,r.prototype._$P7=function(t,e,i,r)&#123;var o=-1,n=0,s=this;if(0!=i)if(1==t.length)&#123;p=t[0];var _=0!=s.getParamFloat(p),a=(c=e[0],s.getPartsOpacity(c)),h=i/r;_?(a+=h)&gt;1&amp;&amp;(a=1):(a-=h)&lt;0&amp;&amp;(a=0),s.setPartsOpacity(c,a)&#125;else&#123;for(u=0;u&lt;t.length;u++)&#123;p=t[u];if(f=0!=s.getParamFloat(p))&#123;if(o&gt;=0)break;o=u;c=e[u];n=s.getPartsOpacity(c),(n+=i/r)&gt;1&amp;&amp;(n=1)&#125;&#125;o&lt;0&amp;&amp;(console.log(&quot;No _$wi _$q0/ _$U default[%s]&quot;,t[0]),o=0,n=1,s.loadParam(),s.setParamFloat(t[o],n),s.saveParam());for(u=0;u&lt;t.length;u++)&#123;c=e[u];if(o==u)s.setPartsOpacity(c,n);else&#123;var l,$=s.getPartsOpacity(c);(1-(l=n&lt;.5?-.5*n/.5+1:.5*(1-n)/.5))*(1-n)&gt;.15&amp;&amp;(l=1-.15/(1-n)),$&gt;l&amp;&amp;($=l),s.setPartsOpacity(c,$)&#125;&#125;&#125;else for(var u=0;u&lt;t.length;u++)&#123;var p=t[u],c=e[u],f=0!=s.getParamFloat(p);s.setPartsOpacity(c,f?1:0)&#125;&#125;,r.prototype.setPartsOpacity=function(t,e)&#123;&quot;number&quot;!=typeof t&amp;&amp;(t=this._$5S.getPartsDataIndex(h.getID(t))),this._$5S.setPartsOpacity(t,e)&#125;,r.prototype.getPartsDataIndex=function(t)&#123;return t instanceof h||(t=h.getID(t)),this._$5S.getPartsDataIndex(t)&#125;,r.prototype.getPartsOpacity=function(t)&#123;return&quot;number&quot;!=typeof t&amp;&amp;(t=this._$5S.getPartsDataIndex(h.getID(t))),t&lt;0?0:this._$5S.getPartsOpacity(t)&#125;,r.prototype.getDrawParam=function()&#123;&#125;,r.prototype.getDrawDataIndex=function(t)&#123;return this._$5S.getDrawDataIndex(R.getID(t))&#125;,r.prototype.getDrawData=function(t)&#123;return this._$5S.getDrawData(t)&#125;,r.prototype.getTransformedPoints=function(t)&#123;var e=this._$5S._$C2(t);return e instanceof $t?e.getTransformedPoints():null&#125;,r.prototype.getIndexArray=function(t)&#123;if(t&lt;0||t&gt;=this._$5S._$aS.length)return null;var e=this._$5S._$aS[t];return null!=e&amp;&amp;e.getType()==W._$wb&amp;&amp;e instanceof lt?e.getIndexArray():null&#125;,o.CHANNEL_COUNT=4,o.RENDER_TEXTURE_USE_MIPMAP=!1,o.NOT_USED_FRAME=-100,o.prototype._$L7=function()&#123;if(this.tmpModelToViewMatrix&amp;&amp;(this.tmpModelToViewMatrix=null),this.tmpMatrix2&amp;&amp;(this.tmpMatrix2=null),this.tmpMatrixForMask&amp;&amp;(this.tmpMatrixForMask=null),this.tmpMatrixForDraw&amp;&amp;(this.tmpMatrixForDraw=null),this.tmpBoundsOnModel&amp;&amp;(this.tmpBoundsOnModel=null),this.CHANNEL_COLORS)&#123;for(var t=this.CHANNEL_COLORS.length-1;t&gt;=0;--t)this.CHANNEL_COLORS.splice(t,1);this.CHANNEL_COLORS=[]&#125;this.releaseShader()&#125;,o.prototype.releaseShader=function()&#123;for(var t=_t.frameBuffers.length,e=0;e&lt;t;e++)this.gl.deleteFramebuffer(_t.frameBuffers[e].framebuffer);_t.frameBuffers=[],_t.glContext=[]&#125;,o.prototype.init=function(t,e,i)&#123;for(var r=0;r&lt;e.length;r++)&#123;var o=e[r].getClipIDList();if(null!=o)&#123;var s=this.findSameClip(o);null==s&amp;&amp;(s=new n(this,t,o),this.clipContextList.push(s));var _=e[r].getDrawDataID(),a=t.getDrawDataIndex(_);s.addClippedDrawData(_,a),i[r].clipBufPre_clipContext=s&#125;&#125;&#125;,o.prototype.getMaskRenderTexture=function()&#123;var t;return t=this.dp_webgl.createFramebuffer(),_t.frameBuffers[this.dp_webgl.glno]=t,this.dp_webgl.glno&#125;,o.prototype.setupClip=function(t,e)&#123;for(var i=0,r=0;r&lt;this.clipContextList.length;r++)&#123;var o=this.clipContextList[r];this.calcClippedDrawTotalBounds(t,o),o.isUsing&amp;&amp;i++&#125;if(i&gt;0)&#123;var n=e.gl.getParameter(e.gl.FRAMEBUFFER_BINDING),s=new Array(4);s[0]=0,s[1]=0,s[2]=e.gl.canvas.width,s[3]=e.gl.canvas.height,e.gl.viewport(0,0,_t.clippingMaskBufferSize,_t.clippingMaskBufferSize),this.setupLayoutBounds(i),e.gl.bindFramebuffer(e.gl.FRAMEBUFFER,_t.frameBuffers[this.curFrameNo].framebuffer),e.gl.clearColor(0,0,0,0),e.gl.clear(e.gl.COLOR_BUFFER_BIT);for(r=0;r&lt;this.clipContextList.length;r++)&#123;var _=(o=this.clipContextList[r]).allClippedDrawRect,a=(o.layoutChannelNo,o.layoutBounds);this.tmpBoundsOnModel._$jL(_),this.tmpBoundsOnModel.expand(.05*_.width,.05*_.height);var h=a.width/this.tmpBoundsOnModel.width,l=a.height/this.tmpBoundsOnModel.height;this.tmpMatrix2.identity(),this.tmpMatrix2.translate(-1,-1,0),this.tmpMatrix2.scale(2,2,1),this.tmpMatrix2.translate(a.x,a.y,0),this.tmpMatrix2.scale(h,l,1),this.tmpMatrix2.translate(-this.tmpBoundsOnModel.x,-this.tmpBoundsOnModel.y,0),this.tmpMatrixForMask.setMatrix(this.tmpMatrix2.m),this.tmpMatrix2.identity(),this.tmpMatrix2.translate(a.x,a.y,0),this.tmpMatrix2.scale(h,l,1),this.tmpMatrix2.translate(-this.tmpBoundsOnModel.x,-this.tmpBoundsOnModel.y,0),this.tmpMatrixForDraw.setMatrix(this.tmpMatrix2.m);for(var $=this.tmpMatrixForMask.getArray(),u=0;u&lt;16;u++)o.matrixForMask[u]=$[u];var p=this.tmpMatrixForDraw.getArray();for(u=0;u&lt;16;u++)o.matrixForDraw[u]=p[u];for(var c=o.clippingMaskDrawIndexList.length,f=0;f&lt;c;f++)&#123;var g=o.clippingMaskDrawIndexList[f],y=t.getDrawData(g),d=t._$C2(g);e.setClipBufPre_clipContextForMask(o),y.draw(e,t,d)&#125;&#125;e.gl.bindFramebuffer(e.gl.FRAMEBUFFER,n),e.setClipBufPre_clipContextForMask(null),e.gl.viewport(s[0],s[1],s[2],s[3])&#125;&#125;,o.prototype.getColorBuffer=function()&#123;return this.colorBuffer&#125;,o.prototype.findSameClip=function(t)&#123;for(var e=0;e&lt;this.clipContextList.length;e++)&#123;var i=this.clipContextList[e],r=i.clipIDList.length;if(r==t.length)&#123;for(var o=0,n=0;n&lt;r;n++)for(var s=i.clipIDList[n],_=0;_&lt;r;_++)if(t[_]==s)&#123;o++;break&#125;if(o==r)return i&#125;&#125;return null&#125;,o.prototype.calcClippedDrawTotalBounds=function(t,e)&#123;for(var i=t._$Ri.getModelImpl().getCanvasWidth(),r=t._$Ri.getModelImpl().getCanvasHeight(),o=i&gt;r?i:r,n=o,s=o,_=0,a=0,h=e.clippedDrawContextList.length,l=0;l&lt;h;l++)&#123;var $=e.clippedDrawContextList[l].drawDataIndex,u=t._$C2($);if(u._$yo())&#123;for(var p=u.getTransformedPoints(),c=p.length,f=[],g=[],y=0,d=B._$i2;d&lt;c;d+=B._$No)f[y]=p[d],g[y]=p[d+1],y++;var m=Math.min.apply(null,f),T=Math.min.apply(null,g),P=Math.max.apply(null,f),S=Math.max.apply(null,g);m&lt;n&amp;&amp;(n=m),T&lt;s&amp;&amp;(s=T),P&gt;_&amp;&amp;(_=P),S&gt;a&amp;&amp;(a=S)&#125;&#125;if(n==o)e.allClippedDrawRect.x=0,e.allClippedDrawRect.y=0,e.allClippedDrawRect.width=0,e.allClippedDrawRect.height=0,e.isUsing=!1;else&#123;var v=_-n,L=a-s;e.allClippedDrawRect.x=n,e.allClippedDrawRect.y=s,e.allClippedDrawRect.width=v,e.allClippedDrawRect.height=L,e.isUsing=!0&#125;&#125;,o.prototype.setupLayoutBounds=function(t)&#123;var e=t/o.CHANNEL_COUNT,i=t%o.CHANNEL_COUNT;e=~~e,i=~~i;for(var r=0,n=0;n&lt;o.CHANNEL_COUNT;n++)&#123;var s=e+(n&lt;i?1:0);if(0==s);else if(1==s)($=this.clipContextList[r++]).layoutChannelNo=n,$.layoutBounds.x=0,$.layoutBounds.y=0,$.layoutBounds.width=1,$.layoutBounds.height=1;else if(2==s)for(var a=0;a&lt;s;a++)&#123;var h=0;l=~~(l=a%2),($=this.clipContextList[r++]).layoutChannelNo=n,$.layoutBounds.x=.5*l,$.layoutBounds.y=0,$.layoutBounds.width=.5,$.layoutBounds.height=1&#125;else if(s&lt;=4)for(a=0;a&lt;s;a++)&#123;l=~~(l=a%2),h=~~(h=a/2),($=this.clipContextList[r++]).layoutChannelNo=n,$.layoutBounds.x=.5*l,$.layoutBounds.y=.5*h,$.layoutBounds.width=.5,$.layoutBounds.height=.5&#125;else if(s&lt;=9)for(a=0;a&lt;s;a++)&#123;var l,$;l=~~(l=a%3),h=~~(h=a/3),($=this.clipContextList[r++]).layoutChannelNo=n,$.layoutBounds.x=l/3,$.layoutBounds.y=h/3,$.layoutBounds.width=1/3,$.layoutBounds.height=1/3&#125;else _._$li(&quot;_$6 _$0P mask count : %d&quot;,s)&#125;&#125;,n.prototype.addClippedDrawData=function(t,e)&#123;var i=new function(t,e)&#123;this._$gP=t,this.drawDataIndex=e&#125;(t,e);this.clippedDrawContextList.push(i)&#125;,s._$JT=function(t,e,i)&#123;var r=t/e,o=i/e,n=1-(1-o)*(1-o),s=1-(1-o)*(1-o),_=1/3*(1-o)*n+(o*(2/3)+1/3*(1-o))*(1-n),a=(o+2/3*(1-o))*s+(o*(1/3)+2/3*(1-o))*(1-s),h=1-3*a+3*_-0,l=3*a-6*_+0,$=3*_-0;if(r&lt;=0)return 0;if(r&gt;=1)return 1;var u=r*r;return h*(r*u)+l*u+$*r+0&#125;,s.prototype._$a0=function()&#123;&#125;,s.prototype.setFadeIn=function(t)&#123;this._$dP=t&#125;,s.prototype.setFadeOut=function(t)&#123;this._$eo=t&#125;,s.prototype._$pT=function(t)&#123;this._$V0=t&#125;,s.prototype.getFadeOut=function()&#123;return this._$eo&#125;,s.prototype._$4T=function()&#123;return this._$eo&#125;,s.prototype._$mT=function()&#123;return this._$V0&#125;,s.prototype.getDurationMSec=function()&#123;return-1&#125;,s.prototype.getLoopDurationMSec=function()&#123;return-1&#125;,s.prototype.updateParam=function(t,e)&#123;if(e._$AT&amp;&amp;!e._$9L)&#123;var i=x.getUserTimeMSec();if(e._$z2&lt;0)&#123;e._$z2=i,e._$bs=i;var r=this.getDurationMSec();e._$Do&lt;0&amp;&amp;(e._$Do=r&lt;=0?-1:e._$z2+r)&#125;var o=this._$V0;0&lt;=(o=o*(0==this._$dP?1:at._$r2((i-e._$bs)/this._$dP))*(0==this._$eo||e._$Do&lt;0?1:at._$r2((e._$Do-i)/this._$eo)))&amp;&amp;o&lt;=1||console.log(&quot;### assert!! ### &quot;),this.updateParamExe(t,i,o,e),e._$Do&gt;0&amp;&amp;e._$Do&lt;i&amp;&amp;(e._$9L=!0)&#125;&#125;,s.prototype.updateParamExe=function(t,e,i,r)&#123;&#125;,_._$8s=0,_._$fT=new Object,_.start=function(t)&#123;var e=_._$fT[t];null==e&amp;&amp;((e=new function()&#123;this._$r=null,this._$0S=null&#125;)._$r=t,_._$fT[t]=e),e._$0S=x.getSystemTimeMSec()&#125;,_.dump=function(t)&#123;var e=_._$fT[t];if(null!=e)&#123;var i=x.getSystemTimeMSec()-e._$0S;return console.log(t+&quot; : &quot;+i+&quot;ms&quot;),i&#125;return-1&#125;,_.end=function(t)&#123;var e=_._$fT[t];return null!=e?x.getSystemTimeMSec()-e._$0S:-1&#125;,_._$li=function(t,e)&#123;console.log(&quot;_$li : &quot;+t+&quot;\\n&quot;,e)&#125;,_._$Ji=function(t,e)&#123;console.log(t,e)&#125;,_._$dL=function(t,e)&#123;console.log(t,e),console.log(&quot;\\n&quot;)&#125;,_._$KL=function(t,e)&#123;for(var i=0;i&lt;e;i++)i%16==0&amp;&amp;i&gt;0?console.log(&quot;\\n&quot;):i%8==0&amp;&amp;i&gt;0&amp;&amp;console.log(&quot;  &quot;),console.log(&quot;%02X &quot;,255&amp;t[i]);console.log(&quot;\\n&quot;)&#125;,_._$nr=function(t,e,i)&#123;console.log(&quot;%s\\n&quot;,t);for(var r=e.length,o=0;o&lt;r;++o)console.log(&quot;%5d&quot;,e[o]),console.log(&quot;%s\\n&quot;,i),console.log(&quot;,&quot;);console.log(&quot;\\n&quot;)&#125;,_._$Rb=function(t)&#123;console.log(&quot;dump exception : &quot;+t),console.log(&quot;stack :: &quot;+t.stack)&#125;,a.prototype._$8P=function()&#123;return.5*(this.x+this.x+this.width)&#125;,a.prototype._$6P=function()&#123;return.5*(this.y+this.y+this.height)&#125;,a.prototype._$EL=function()&#123;return this.x+this.width&#125;,a.prototype._$5T=function()&#123;return this.y+this.height&#125;,a.prototype._$jL=function(t,e,i,r)&#123;this.x=t,this.y=e,this.width=i,this.height=r&#125;,a.prototype._$jL=function(t)&#123;this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height&#125;,h.prototype=new it,h._$tP=new Object,h._$27=function()&#123;h._$tP.clear()&#125;,h.getID=function(t)&#123;var e=h._$tP[t];return null==e&amp;&amp;(e=new h(t),h._$tP[t]=e),e&#125;,h.prototype._$3s=function()&#123;return new h&#125;,l.prototype=new it,l._$tP=new Object,l._$27=function()&#123;l._$tP.clear()&#125;,l.getID=function(t)&#123;var e=l._$tP[t];return null==e&amp;&amp;(e=new l(t),l._$tP[t]=e),e&#125;,l.prototype._$3s=function()&#123;return new l&#125;,$._$42=0,$.prototype._$zP=function()&#123;null==this._$vo&amp;&amp;(this._$vo=new rt),null==this._$F2&amp;&amp;(this._$F2=new Array)&#125;,$.prototype.getCanvasWidth=function()&#123;return this._$ao&#125;,$.prototype.getCanvasHeight=function()&#123;return this._$1S&#125;,$.prototype._$F0=function(t)&#123;this._$vo=t._$nP(),this._$F2=t._$nP(),this._$ao=t._$6L(),this._$1S=t._$6L()&#125;,$.prototype._$6S=function(t)&#123;this._$F2.push(t)&#125;,$.prototype._$Xr=function()&#123;return this._$F2&#125;,$.prototype._$E2=function()&#123;return this._$vo&#125;,u.prototype.setup=function(t,e,i)&#123;this._$ks=this._$Yb(),this.p2._$xT(),3==arguments.length&amp;&amp;(this._$Fo=t,this._$L2=e,this.p1._$p=i,this.p2._$p=i,this.p2.y=t,this.setup())&#125;,u.prototype.getPhysicsPoint1=function()&#123;return this.p1&#125;,u.prototype.getPhysicsPoint2=function()&#123;return this.p2&#125;,u.prototype._$qr=function()&#123;return this._$Db&#125;,u.prototype._$pr=function(t)&#123;this._$Db=t&#125;,u.prototype._$5r=function()&#123;return this._$M2&#125;,u.prototype._$Cs=function()&#123;return this._$9b&#125;,u.prototype._$Yb=function()&#123;return-180*Math.atan2(this.p1.x-this.p2.x,-(this.p1.y-this.p2.y))/Math.PI&#125;,u.prototype.addSrcParam=function(t,e,i,r)&#123;var o=new f(t,e,i,r);this._$lL.push(o)&#125;,u.prototype.addTargetParam=function(t,e,i,r)&#123;var o=new y(t,e,i,r);this._$qP.push(o)&#125;,u.prototype.update=function(t,e)&#123;if(0==this._$iP)return this._$iP=this._$iT=e,void(this._$Fo=Math.sqrt((this.p1.x-this.p2.x)*(this.p1.x-this.p2.x)+(this.p1.y-this.p2.y)*(this.p1.y-this.p2.y)));var i=(e-this._$iT)/1e3;if(0!=i)&#123;for(var r=this._$lL.length-1;r&gt;=0;--r)&#123;this._$lL[r]._$oP(t,this)&#125;this._$oo(t,i),this._$M2=this._$Yb(),this._$9b=(this._$M2-this._$ks)/i,this._$ks=this._$M2&#125;for(r=this._$qP.length-1;r&gt;=0;--r)&#123;this._$qP[r]._$YS(t,this)&#125;this._$iT=e&#125;,u.prototype._$oo=function(t,e)&#123;e&lt;.033&amp;&amp;(e=.033);var i=1/e;this.p1.vx=(this.p1.x-this.p1._$s0)*i,this.p1.vy=(this.p1.y-this.p1._$70)*i,this.p1.ax=(this.p1.vx-this.p1._$7L)*i,this.p1.ay=(this.p1.vy-this.p1._$HL)*i,this.p1.fx=this.p1.ax*this.p1._$p,this.p1.fy=this.p1.ay*this.p1._$p,this.p1._$xT();var r,o,n=-Math.atan2(this.p1.y-this.p2.y,this.p1.x-this.p2.x),s=Math.cos(n),_=Math.sin(n),a=9.8*this.p2._$p,h=this._$Db*vt._$bS,l=a*Math.cos(n-h);r=l*_,o=l*s;var $=-this.p1.fx*_*_,u=-this.p1.fy*_*s,p=-this.p2.vx*this._$L2,c=-this.p2.vy*this._$L2;this.p2.fx=r+$+p,this.p2.fy=o+u+c,this.p2.ax=this.p2.fx/this.p2._$p,this.p2.ay=this.p2.fy/this.p2._$p,this.p2.vx+=this.p2.ax*e,this.p2.vy+=this.p2.ay*e,this.p2.x+=this.p2.vx*e,this.p2.y+=this.p2.vy*e;var f=Math.sqrt((this.p1.x-this.p2.x)*(this.p1.x-this.p2.x)+(this.p1.y-this.p2.y)*(this.p1.y-this.p2.y));this.p2.x=this.p1.x+this._$Fo*(this.p2.x-this.p1.x)/f,this.p2.y=this.p1.y+this._$Fo*(this.p2.y-this.p1.y)/f,this.p2.vx=(this.p2.x-this.p2._$s0)*i,this.p2.vy=(this.p2.y-this.p2._$70)*i,this.p2._$xT()&#125;,p.prototype._$xT=function()&#123;this._$s0=this.x,this._$70=this.y,this._$7L=this.vx,this._$HL=this.vy&#125;,c.prototype._$oP=function(t,e)&#123;&#125;,f.prototype=new c,f.prototype._$oP=function(t,e)&#123;var i=this.scale*t.getParamFloat(this._$wL),r=e.getPhysicsPoint1();switch(this._$tL)&#123;default:case u.Src.SRC_TO_X:r.x=r.x+(i-r.x)*this._$V0;break;case u.Src.SRC_TO_Y:r.y=r.y+(i-r.y)*this._$V0;break;case u.Src.SRC_TO_G_ANGLE:var o=e._$qr();o+=(i-o)*this._$V0,e._$pr(o)&#125;&#125;,g.prototype._$YS=function(t,e)&#123;&#125;,y.prototype=new g,y.prototype._$YS=function(t,e)&#123;switch(this._$YP)&#123;default:case u.Target.TARGET_FROM_ANGLE:t.setParamFloat(this._$wL,this.scale*e._$5r(),this._$V0);break;case u.Target.TARGET_FROM_ANGLE_V:t.setParamFloat(this._$wL,this.scale*e._$Cs(),this._$V0)&#125;&#125;,u.Src=function()&#123;&#125;,u.Src.SRC_TO_X=&quot;SRC_TO_X&quot;,u.Src.SRC_TO_Y=&quot;SRC_TO_Y&quot;,u.Src.SRC_TO_G_ANGLE=&quot;SRC_TO_G_ANGLE&quot;,u.Target=function()&#123;&#125;,u.Target.TARGET_FROM_ANGLE=&quot;TARGET_FROM_ANGLE&quot;,u.Target.TARGET_FROM_ANGLE_V=&quot;TARGET_FROM_ANGLE_V&quot;,d.prototype.init=function(t)&#123;this._$fL=t._$fL,this._$gL=t._$gL,this._$B0=t._$B0,this._$z0=t._$z0,this._$qT=t._$qT,this.reflectX=t.reflectX,this.reflectY=t.reflectY&#125;,d.prototype._$F0=function(t)&#123;this._$fL=t._$_T(),this._$gL=t._$_T(),this._$B0=t._$_T(),this._$z0=t._$_T(),this._$qT=t._$_T(),t.getFormatVersion()&gt;=G.LIVE2D_FORMAT_VERSION_V2_10_SDK2&amp;&amp;(this.reflectX=t._$po(),this.reflectY=t._$po())&#125;,d.prototype._$e=function()&#123;&#125;;var T=function()&#123;&#125;;function P()&#123;i||(this.x=null,this.y=null,this.width=null,this.height=null)&#125;function S()&#123;&#125;function v()&#123;i||(this.x=null,this.y=null)&#125;function L()&#123;i||(this._$gP=null,this._$dr=null,this._$GS=null,this._$qb=null,this._$Lb=null,this._$mS=null,this.clipID=null,this.clipIDList=new Array)&#125;function M()&#123;i||(this._$Eb=M._$ps,this._$lT=1,this._$C0=1,this._$tT=1,this._$WL=1,this.culling=!1,this.matrix4x4=new Float32Array(16),this.premultipliedAlpha=!1,this.anisotropy=0,this.clippingProcess=M.CLIPPING_PROCESS_NONE,this.clipBufPre_clipContextMask=null,this.clipBufPre_clipContextDraw=null,this.CHANNEL_COLORS=new Array)&#125;function E()&#123;i||(this.a=1,this.r=1,this.g=1,this.b=1,this.scale=1,this._$ho=1,this.blendMode=_t.L2D_COLOR_BLEND_MODE_MULT)&#125;function A()&#123;i||(this._$kP=null,this._$dr=null,this._$Ai=!0,this._$mS=null)&#125;function x()&#123;&#125;function I()&#123;i||(this._$VP=0,this._$wL=null,this._$GP=null,this._$8o=I._$ds,this._$2r=-1,this._$O2=0,this._$ri=0)&#125;function w()&#123;&#125;function D()&#123;i||(this._$Ob=null)&#125;function O()&#123;this.m=new Float32Array(16),this.identity()&#125;function R(t)&#123;i||it.prototype.constructor.call(this,t)&#125;function b()&#123;i||(this._$7=1,this._$f=0,this._$H=0,this._$g=1,this._$k=0,this._$w=0,this._$hi=STATE_IDENTITY,this._$Z=_$pS)&#125;function F()&#123;i||(s.prototype.constructor.call(this),this.motions=new Array,this._$7r=null,this._$7r=F._$Co++,this._$D0=30,this._$yT=0,this._$E=!0,this.loopFadeIn=!0,this._$AS=-1,_$a0())&#125;function C()&#123;this._$P=new Float32Array(100),this.size=0&#125;function N()&#123;this._$4P=null,this._$I0=null,this._$RP=null&#125;function B()&#123;&#125;function G()&#123;&#125;function U(t)&#123;i||(this._$QT=!0,this._$co=-1,this._$qo=0,this._$pb=new Array(U._$is),this._$_2=new Float32Array(U._$is),this._$vr=new Float32Array(U._$is),this._$Rr=new Float32Array(U._$is),this._$Or=new Float32Array(U._$is),this._$fs=new Float32Array(U._$is),this._$Js=new Array(U._$is),this._$3S=new Array,this._$aS=new Array,this._$Bo=null,this._$F2=new Array,this._$db=new Array,this._$8b=new Array,this._$Hr=new Array,this._$Ws=null,this._$Vs=null,this._$Er=null,this._$Es=new Int16Array(B._$Qb),this._$ZP=new Float32Array(2*B._$1r),this._$Ri=t,this._$b0=U._$HP++,this.clipManager=null,this.dp_webgl=null)&#125;function Y()&#123;&#125;function k()&#123;i||(this._$12=null,this._$bb=null,this._$_L=null,this._$jo=null,this._$iL=null,this._$0L=null,this._$Br=null,this._$Dr=null,this._$Cb=null,this._$mr=null,this._$_L=V.STATE_FIRST,this._$Br=4e3,this._$Dr=100,this._$Cb=50,this._$mr=150,this._$jo=!0,this._$iL=&quot;PARAM_EYE_L_OPEN&quot;,this._$0L=&quot;PARAM_EYE_R_OPEN&quot;)&#125;T._$ni=function(t,e,i,r,o,n,s,_,a)&#123;var h=s*n-_*o;if(0==h)return null;var l,$=((t-i)*n-(e-r)*o)/h;return l=0!=o?(t-i-$*s)/o:(e-r-$*_)/n,isNaN(l)&amp;&amp;(l=(t-i-$*s)/o,isNaN(l)&amp;&amp;(l=(e-r-$*_)/n),isNaN(l)&amp;&amp;(console.log(&quot;a is NaN @UtVector#_$ni() &quot;),console.log(&quot;v1x : &quot;+o),console.log(&quot;v1x != 0 ? &quot;+(0!=o)))),null==a?new Array(l,$):(a[0]=l,a[1]=$,a)&#125;,P.prototype._$8P=function()&#123;return this.x+.5*this.width&#125;,P.prototype._$6P=function()&#123;return this.y+.5*this.height&#125;,P.prototype._$EL=function()&#123;return this.x+this.width&#125;,P.prototype._$5T=function()&#123;return this.y+this.height&#125;,P.prototype._$jL=function(t,e,i,r)&#123;this.x=t,this.y=e,this.width=i,this.height=r&#125;,P.prototype._$jL=function(t)&#123;this.x=t.x,this.y=t.y,this.width=t.width,this.height=t.height&#125;,P.prototype.contains=function(t,e)&#123;return this.x&lt;=this.x&amp;&amp;this.y&lt;=this.y&amp;&amp;this.x&lt;=this.x+this.width&amp;&amp;this.y&lt;=this.y+this.height&#125;,P.prototype.expand=function(t,e)&#123;this.x-=t,this.y-=e,this.width+=2*t,this.height+=2*e&#125;,S._$Z2=function(t,e,i,r)&#123;var o=e._$Q2(t,i),n=t._$vs(),s=t._$Tr();if(e._$zr(n,s,o),o&lt;=0)return r[n[0]];if(1==o)return(_=r[n[0]])+((a=r[n[1]])-_)*($=s[0])|0;if(2==o)&#123;var _=r[n[0]],a=r[n[1]],h=r[n[2]],l=r[n[3]],$=s[0],u=s[1];return(S=_+(a-_)*$|0)+((h+(l-h)*$|0)-S)*u|0&#125;if(3==o)&#123;var p=r[n[0]],c=r[n[1]],f=r[n[2]],g=r[n[3]],y=r[n[4]],d=r[n[5]],m=r[n[6]],T=r[n[7]],P=($=s[0],u=s[1],s[2]);return(S=(_=p+(c-p)*$|0)+((a=f+(g-f)*$|0)-_)*u|0)+(((h=y+(d-y)*$|0)+((l=m+(T-m)*$|0)-h)*u|0)-S)*P|0&#125;if(4==o)&#123;var S,v=r[n[0]],L=r[n[1]],M=r[n[2]],E=r[n[3]],A=r[n[4]],x=r[n[5]],I=r[n[6]],w=r[n[7]],D=r[n[8]],O=r[n[9]],R=r[n[10]],b=r[n[11]],F=r[n[12]],C=r[n[13]],N=r[n[14]],B=r[n[15]],G=($=s[0],u=s[1],P=s[2],s[3]);return(S=(_=(p=v+(L-v)*$|0)+((c=M+(E-M)*$|0)-p)*u|0)+((a=(f=A+(x-A)*$|0)+((g=I+(w-I)*$|0)-f)*u|0)-_)*P|0)+(((h=(y=D+(O-D)*$|0)+((d=R+(b-R)*$|0)-y)*u|0)+((l=(m=F+(C-F)*$|0)+((T=N+(B-N)*$|0)-m)*u|0)-h)*P|0)-S)*G|0&#125;for(var U=1&lt;&lt;o,Y=new Float32Array(U),k=0;k&lt;U;k++)&#123;for(var V=k,X=1,z=0;z&lt;o;z++)X*=V%2==0?1-s[z]:s[z],V/=2;Y[k]=X&#125;for(var H=new Float32Array(U),W=0;W&lt;U;W++)H[W]=r[n[W]];var j=0;for(W=0;W&lt;U;W++)j+=Y[W]*H[W];return j+.5|0&#125;,S._$br=function(t,e,i,r)&#123;var o=e._$Q2(t,i),n=t._$vs(),s=t._$Tr();if(e._$zr(n,s,o),o&lt;=0)return r[n[0]];if(1==o)return(_=r[n[0]])+((a=r[n[1]])-_)*($=s[0]);if(2==o)&#123;var _=r[n[0]],a=r[n[1]],h=r[n[2]],l=r[n[3]],$=s[0];return(1-(T=s[1]))*(_+(a-_)*$)+T*(h+(l-h)*$)&#125;if(3==o)&#123;var u=r[n[0]],p=r[n[1]],c=r[n[2]],f=r[n[3]],g=r[n[4]],y=r[n[5]],d=r[n[6]],m=r[n[7]],T=($=s[0],s[1]);return(1-(N=s[2]))*((1-T)*(u+(p-u)*$)+T*(c+(f-c)*$))+N*((1-T)*(g+(y-g)*$)+T*(d+(m-d)*$))&#125;if(4==o)&#123;var P=r[n[0]],S=r[n[1]],v=r[n[2]],L=r[n[3]],M=r[n[4]],E=r[n[5]],A=r[n[6]],x=r[n[7]],I=r[n[8]],w=r[n[9]],D=r[n[10]],O=r[n[11]],R=r[n[12]],b=r[n[13]],F=r[n[14]],C=r[n[15]],N=($=s[0],T=s[1],s[2]),B=s[3];return(1-B)*((1-N)*((1-T)*(P+(S-P)*$)+T*(v+(L-v)*$))+N*((1-T)*(M+(E-M)*$)+T*(A+(x-A)*$)))+B*((1-N)*((1-T)*(I+(w-I)*$)+T*(D+(O-D)*$))+N*((1-T)*(R+(b-R)*$)+T*(F+(C-F)*$)))&#125;for(var G=1&lt;&lt;o,U=new Float32Array(G),Y=0;Y&lt;G;Y++)&#123;for(var k=Y,V=1,X=0;X&lt;o;X++)V*=k%2==0?1-s[X]:s[X],k/=2;U[Y]=V&#125;for(var z=new Float32Array(G),H=0;H&lt;G;H++)z[H]=r[n[H]];var W=0;for(H=0;H&lt;G;H++)W+=U[H]*z[H];return W&#125;,S._$Vr=function(t,e,i,r,o,n,s,_)&#123;var a=e._$Q2(t,i),h=t._$vs(),l=t._$Tr();e._$zr(h,l,a);var $=2*r,u=s;if(a&lt;=0)&#123;var p=o[h[0]];if(2==_&amp;&amp;0==s)x._$jT(p,0,n,0,$);else for(var c=0;c&lt;$;)n[u]=p[c++],n[u+1]=p[c++],u+=_&#125;else if(1==a)&#123;p=o[h[0]];var f=o[h[1]],g=1-(m=l[0]);for(c=0;c&lt;$;)n[u]=p[c]*g+f[c]*m,++c,n[u+1]=p[c]*g+f[c]*m,++c,u+=_&#125;else if(2==a)&#123;p=o[h[0]],f=o[h[1]];var y=o[h[2]],d=o[h[3]],m=l[0],T=(k=1-(R=l[1]))*(g=1-m),P=k*m,S=R*g,v=R*m;for(c=0;c&lt;$;)n[u]=T*p[c]+P*f[c]+S*y[c]+v*d[c],++c,n[u+1]=T*p[c]+P*f[c]+S*y[c]+v*d[c],++c,u+=_&#125;else if(3==a)&#123;var L=o[h[0]],M=o[h[1]],E=o[h[2]],A=o[h[3]],I=o[h[4]],w=o[h[5]],D=o[h[6]],O=o[h[7]],R=(m=l[0],l[1]),b=(V=1-(st=l[2]))*(k=1-R)*(g=1-m),F=V*k*m,C=V*R*g,N=V*R*m,B=st*k*g,G=st*k*m,U=st*R*g,Y=st*R*m;for(c=0;c&lt;$;)n[u]=b*L[c]+F*M[c]+C*E[c]+N*A[c]+B*I[c]+G*w[c]+U*D[c]+Y*O[c],++c,n[u+1]=b*L[c]+F*M[c]+C*E[c]+N*A[c]+B*I[c]+G*w[c]+U*D[c]+Y*O[c],++c,u+=_&#125;else if(4==a)&#123;var k,V,X=o[h[0]],z=o[h[1]],H=o[h[2]],W=o[h[3]],j=o[h[4]],q=o[h[5]],J=o[h[6]],Q=o[h[7]],Z=o[h[8]],K=o[h[9]],tt=o[h[10]],et=o[h[11]],it=o[h[12]],rt=o[h[13]],ot=o[h[14]],nt=o[h[15]],st=(m=l[0],R=l[1],l[2]),_t=l[3],at=1-_t,ht=at*(V=1-st)*(k=1-R)*(g=1-m),lt=at*V*k*m,$t=at*V*R*g,ut=at*V*R*m,pt=at*st*k*g,ct=at*st*k*m,ft=at*st*R*g,gt=at*st*R*m,yt=_t*V*k*g,dt=_t*V*k*m,mt=_t*V*R*g,Tt=_t*V*R*m,Pt=_t*st*k*g,St=_t*st*k*m,vt=_t*st*R*g,Lt=_t*st*R*m;for(c=0;c&lt;$;)n[u]=ht*X[c]+lt*z[c]+$t*H[c]+ut*W[c]+pt*j[c]+ct*q[c]+ft*J[c]+gt*Q[c]+yt*Z[c]+dt*K[c]+mt*tt[c]+Tt*et[c]+Pt*it[c]+St*rt[c]+vt*ot[c]+Lt*nt[c],++c,n[u+1]=ht*X[c]+lt*z[c]+$t*H[c]+ut*W[c]+pt*j[c]+ct*q[c]+ft*J[c]+gt*Q[c]+yt*Z[c]+dt*K[c]+mt*tt[c]+Tt*et[c]+Pt*it[c]+St*rt[c]+vt*ot[c]+Lt*nt[c],++c,u+=_&#125;else&#123;for(var Mt=1&lt;&lt;a,Et=new Float32Array(Mt),At=0;At&lt;Mt;At++)&#123;for(var xt=At,It=1,wt=0;wt&lt;a;wt++)It*=xt%2==0?1-l[wt]:l[wt],xt/=2;Et[At]=It&#125;for(var Dt=new Float32Array(Mt),Ot=0;Ot&lt;Mt;Ot++)Dt[Ot]=o[h[Ot]];for(c=0;c&lt;$;)&#123;var Rt=0,bt=0,Ft=c+1;for(Ot=0;Ot&lt;Mt;Ot++)Rt+=Et[Ot]*Dt[Ot][c],bt+=Et[Ot]*Dt[Ot][Ft];c+=2,n[u]=Rt,n[u+1]=bt,u+=_&#125;&#125;&#125;,v.prototype._$HT=function(t,e)&#123;this.x=t,this.y=e&#125;,v.prototype._$HT=function(t)&#123;this.x=t.x,this.y=t.y&#125;,L._$ur=-2,L._$ES=500,L._$wb=2,L._$8S=3,L._$52=L._$ES,L._$R2=L._$ES,L._$or=function()&#123;return L._$52&#125;,L._$Pr=function()&#123;return L._$R2&#125;,L.prototype.convertClipIDForV2_11=function(t)&#123;var e=[];return null==t?null:0==t.length?null:/,/.test(t)?e=t.id.split(&quot;,&quot;):(e.push(t.id),e)&#125;,L.prototype._$F0=function(t)&#123;this._$gP=t._$nP(),this._$dr=t._$nP(),this._$GS=t._$nP(),this._$qb=t._$6L(),this._$Lb=t._$cS(),this._$mS=t._$Tb(),t.getFormatVersion()&gt;=G._$T7?(this.clipID=t._$nP(),this.clipIDList=this.convertClipIDForV2_11(this.clipID)):this.clipIDList=[],this._$MS(this._$Lb)&#125;,L.prototype.getClipIDList=function()&#123;return this.clipIDList&#125;,L.prototype.init=function(t)&#123;&#125;,L.prototype._$Nr=function(t,e)&#123;if(e._$IS[0]=!1,e._$Us=S._$Z2(t,this._$GS,e._$IS,this._$Lb),_t._$Zs);else if(e._$IS[0])return;e._$7s=S._$br(t,this._$GS,e._$IS,this._$mS)&#125;,L.prototype._$2b=function(t,e)&#123;&#125;,L.prototype.getDrawDataID=function()&#123;return this._$gP&#125;,L.prototype._$j2=function(t)&#123;this._$gP=t&#125;,L.prototype.getOpacity=function(t,e)&#123;return e._$7s&#125;,L.prototype._$zS=function(t,e)&#123;return e._$Us&#125;,L.prototype._$MS=function(t)&#123;for(var e=t.length-1;e&gt;=0;--e)&#123;var i=t[e];i&lt;L._$52?L._$52=i:i&gt;L._$R2&amp;&amp;(L._$R2=i)&#125;&#125;,L.prototype.getTargetBaseDataID=function()&#123;return this._$dr&#125;,L.prototype._$gs=function(t)&#123;this._$dr=t&#125;,L.prototype._$32=function()&#123;return null!=this._$dr&amp;&amp;this._$dr!=yt._$2o()&#125;,L.prototype.preDraw=function(t,e,i)&#123;&#125;,L.prototype.draw=function(t,e,i)&#123;&#125;,L.prototype.getType=function()&#123;&#125;,L.prototype._$B2=function(t,e,i)&#123;&#125;,M._$ps=32,M.CLIPPING_PROCESS_NONE=0,M.CLIPPING_PROCESS_OVERWRITE_ALPHA=1,M.CLIPPING_PROCESS_MULTIPLY_ALPHA=2,M.CLIPPING_PROCESS_DRAW=3,M.CLIPPING_PROCESS_CLEAR_ALPHA=4,M.prototype.setChannelFlagAsColor=function(t,e)&#123;this.CHANNEL_COLORS[t]=e&#125;,M.prototype.getChannelFlagAsColor=function(t)&#123;return this.CHANNEL_COLORS[t]&#125;,M.prototype._$ZT=function()&#123;&#125;,M.prototype._$Uo=function(t,e,i,r,o,n,s)&#123;&#125;,M.prototype._$Rs=function()&#123;return-1&#125;,M.prototype._$Ds=function(t)&#123;&#125;,M.prototype.setBaseColor=function(t,e,i,r)&#123;t&lt;0?t=0:t&gt;1&amp;&amp;(t=1),e&lt;0?e=0:e&gt;1&amp;&amp;(e=1),i&lt;0?i=0:i&gt;1&amp;&amp;(i=1),r&lt;0?r=0:r&gt;1&amp;&amp;(r=1),this._$lT=t,this._$C0=e,this._$tT=i,this._$WL=r&#125;,M.prototype._$WP=function(t)&#123;this.culling=t&#125;,M.prototype.setMatrix=function(t)&#123;for(var e=0;e&lt;16;e++)this.matrix4x4[e]=t[e]&#125;,M.prototype._$IT=function()&#123;return this.matrix4x4&#125;,M.prototype.setPremultipliedAlpha=function(t)&#123;this.premultipliedAlpha=t&#125;,M.prototype.isPremultipliedAlpha=function()&#123;return this.premultipliedAlpha&#125;,M.prototype.setAnisotropy=function(t)&#123;this.anisotropy=t&#125;,M.prototype.getAnisotropy=function()&#123;return this.anisotropy&#125;,M.prototype.getClippingProcess=function()&#123;return this.clippingProcess&#125;,M.prototype.setClippingProcess=function(t)&#123;this.clippingProcess=t&#125;,M.prototype.setClipBufPre_clipContextForMask=function(t)&#123;this.clipBufPre_clipContextMask=t&#125;,M.prototype.getClipBufPre_clipContextMask=function()&#123;return this.clipBufPre_clipContextMask&#125;,M.prototype.setClipBufPre_clipContextForDraw=function(t)&#123;this.clipBufPre_clipContextDraw=t&#125;,M.prototype.getClipBufPre_clipContextDraw=function()&#123;return this.clipBufPre_clipContextDraw&#125;,A._$ur=-2,A._$c2=1,A._$_b=2,A.prototype._$F0=function(t)&#123;this._$kP=t._$nP(),this._$dr=t._$nP()&#125;,A.prototype.readV2_opacity=function(t)&#123;t.getFormatVersion()&gt;=G.LIVE2D_FORMAT_VERSION_V2_10_SDK2&amp;&amp;(this._$mS=t._$Tb())&#125;,A.prototype.init=function(t)&#123;&#125;,A.prototype._$Nr=function(t,e)&#123;&#125;,A.prototype.interpolateOpacity=function(t,e,i,r)&#123;null==this._$mS?i.setInterpolatedOpacity(1):i.setInterpolatedOpacity(S._$br(t,e,r,this._$mS))&#125;,A.prototype._$2b=function(t,e)&#123;&#125;,A.prototype._$nb=function(t,e,i,r,o,n,s)&#123;&#125;,A.prototype.getType=function()&#123;&#125;,A.prototype._$gs=function(t)&#123;this._$dr=t&#125;,A.prototype._$a2=function(t)&#123;this._$kP=t&#125;,A.prototype.getTargetBaseDataID=function()&#123;return this._$dr&#125;,A.prototype.getBaseDataID=function()&#123;return this._$kP&#125;,A.prototype._$32=function()&#123;return null!=this._$dr&amp;&amp;this._$dr!=yt._$2o()&#125;,x._$W2=0,x._$CS=x._$W2,x._$Mo=function()&#123;return!0&#125;,x._$XP=function(t)&#123;try&#123;for(var e=getTimeMSec();getTimeMSec()-e&lt;t;);&#125;catch(t)&#123;t._$Rb()&#125;&#125;,x.getUserTimeMSec=function()&#123;return x._$CS==x._$W2?x.getSystemTimeMSec():x._$CS&#125;,x.setUserTimeMSec=function(t)&#123;x._$CS=t&#125;,x.updateUserTimeMSec=function()&#123;return x._$CS=x.getSystemTimeMSec()&#125;,x.getTimeMSec=function()&#123;return(new Date).getTime()&#125;,x.getSystemTimeMSec=function()&#123;return(new Date).getTime()&#125;,x._$Q=function(t)&#123;&#125;,x._$jT=function(t,e,i,r,o)&#123;for(var n=0;n&lt;o;n++)i[r+n]=t[e+n]&#125;,I._$ds=-2,I.prototype._$F0=function(t)&#123;this._$wL=t._$nP(),this._$VP=t._$6L(),this._$GP=t._$nP()&#125;,I.prototype.getParamIndex=function(t)&#123;return this._$2r!=t&amp;&amp;(this._$8o=I._$ds),this._$8o&#125;,I.prototype._$Pb=function(t,e)&#123;this._$8o=t,this._$2r=e&#125;,I.prototype.getParamID=function()&#123;return this._$wL&#125;,I.prototype._$yP=function(t)&#123;this._$wL=t&#125;,I.prototype._$N2=function()&#123;return this._$VP&#125;,I.prototype._$d2=function()&#123;return this._$GP&#125;,I.prototype._$t2=function(t,e)&#123;this._$VP=t,this._$GP=e&#125;,I.prototype._$Lr=function()&#123;return this._$O2&#125;,I.prototype._$wr=function(t)&#123;this._$O2=t&#125;,I.prototype._$SL=function()&#123;return this._$ri&#125;,I.prototype._$AL=function(t)&#123;this._$ri=t&#125;,w.startsWith=function(t,e,i)&#123;var r=e+i.length;if(r&gt;=t.length)return!1;for(var o=e;o&lt;r;o++)if(w.getChar(t,o)!=i.charAt(o-e))return!1;return!0&#125;,w.getChar=function(t,e)&#123;return String.fromCharCode(t.getUint8(e))&#125;,w.createString=function(t,e,i)&#123;for(var r=new ArrayBuffer(2*i),o=new Uint16Array(r),n=0;n&lt;i;n++)o[n]=t.getUint8(e+n);return String.fromCharCode.apply(null,o)&#125;,w._$LS=function(t,e,i,r)&#123;t instanceof ArrayBuffer&amp;&amp;(t=new DataView(t));var o=i,n=!1,s=!1,_=0,a=w.getChar(t,o);&quot;-&quot;==a&amp;&amp;(n=!0,o++);for(var h=!1;o&lt;e;o++)&#123;switch(a=w.getChar(t,o))&#123;case&quot;0&quot;:_*=10;break;case&quot;1&quot;:_=10*_+1;break;case&quot;2&quot;:_=10*_+2;break;case&quot;3&quot;:_=10*_+3;break;case&quot;4&quot;:_=10*_+4;break;case&quot;5&quot;:_=10*_+5;break;case&quot;6&quot;:_=10*_+6;break;case&quot;7&quot;:_=10*_+7;break;case&quot;8&quot;:_=10*_+8;break;case&quot;9&quot;:_=10*_+9;break;case&quot;.&quot;:s=!0,o++,h=!0;break;default:h=!0&#125;if(h)break&#125;if(s)for(var l=.1,$=!1;o&lt;e;o++)&#123;switch(a=w.getChar(t,o))&#123;case&quot;0&quot;:break;case&quot;1&quot;:_+=1*l;break;case&quot;2&quot;:_+=2*l;break;case&quot;3&quot;:_+=3*l;break;case&quot;4&quot;:_+=4*l;break;case&quot;5&quot;:_+=5*l;break;case&quot;6&quot;:_+=6*l;break;case&quot;7&quot;:_+=7*l;break;case&quot;8&quot;:_+=8*l;break;case&quot;9&quot;:_+=9*l;break;default:$=!0&#125;if(l*=.1,$)break&#125;return n&amp;&amp;(_=-_),r[0]=o,_&#125;,D.prototype._$zP=function()&#123;this._$Ob=new Array&#125;,D.prototype._$F0=function(t)&#123;this._$Ob=t._$nP()&#125;,D.prototype._$Ur=function(t)&#123;if(t._$WS())return!0;for(var e=t._$v2(),i=this._$Ob.length-1;i&gt;=0;--i)&#123;var r=this._$Ob[i].getParamIndex(e);if(r==I._$ds&amp;&amp;(r=t.getParamIndex(this._$Ob[i].getParamID())),t._$Xb(r))return!0&#125;return!1&#125;,D.prototype._$Q2=function(t,e)&#123;for(var i,r,o=this._$Ob.length,n=t._$v2(),s=0,_=0;_&lt;o;_++)&#123;var a=this._$Ob[_];if((i=a.getParamIndex(n))==I._$ds&amp;&amp;(i=t.getParamIndex(a.getParamID()),a._$Pb(i,n)),i&lt;0)throw new Exception(&quot;err 23242 : &quot;+a.getParamID());var h=i&lt;0?0:t.getParamFloat(i);r=a._$N2();var l,$,u=a._$d2(),p=-1,c=0;if(r&lt;1);else if(1==r)(l=u[0])-B._$J&lt;h&amp;&amp;h&lt;l+B._$J?(p=0,c=0):(p=0,e[0]=!0);else if(h&lt;(l=u[0])-B._$J)p=0,e[0]=!0;else if(h&lt;l+B._$J)p=0;else&#123;for(var f=!1,g=1;g&lt;r;++g)&#123;if(h&lt;($=u[g])+B._$J)&#123;$-B._$J&lt;h?p=g:(p=g-1,c=(h-l)/($-l),s++),f=!0;break&#125;l=$&#125;f||(p=r-1,c=0,e[0]=!0)&#125;a._$wr(p),a._$AL(c)&#125;return s&#125;,D.prototype._$zr=function(t,e,i)&#123;var r=1&lt;&lt;i;r+1&gt;B._$Qb&amp;&amp;console.log(&quot;err 23245\\n&quot;);for(var o=this._$Ob.length,n=1,s=1,_=0,a=0;a&lt;r;++a)t[a]=0;for(var h=0;h&lt;o;++h)&#123;var l=this._$Ob[h];if(0==l._$SL())&#123;if(($=l._$Lr()*n)&lt;0&amp;&amp;_t._$3T)throw new Exception(&quot;err 23246&quot;);for(a=0;a&lt;r;++a)t[a]+=$&#125;else&#123;var $=n*l._$Lr(),u=n*(l._$Lr()+1);for(a=0;a&lt;r;++a)t[a]+=(a/s|0)%2==0?$:u;e[_++]=l._$SL(),s*=2&#125;n*=l._$N2()&#125;t[r]=65535,e[_]=-1&#125;,D.prototype._$h2=function(t,e,i)&#123;for(var r=new Float32Array(e),o=0;o&lt;e;++o)r[o]=i[o];var n=new I;n._$yP(t),n._$t2(e,r),this._$Ob.push(n)&#125;,D.prototype._$J2=function(t)&#123;for(var e=t,i=this._$Ob.length,r=0;r&lt;i;++r)&#123;var o=this._$Ob[r],n=o._$N2(),s=e%o._$N2(),_=o._$d2()[s];console.log(&quot;%s[%d]=%7.2f / &quot;,o.getParamID(),s,_),e/=n&#125;console.log(&quot;\\n&quot;)&#125;,D.prototype.getParamCount=function()&#123;return this._$Ob.length&#125;,D.prototype._$zs=function()&#123;return this._$Ob&#125;,O.prototype.identity=function()&#123;for(var t=0;t&lt;16;t++)this.m[t]=t%5==0?1:0&#125;,O.prototype.getArray=function()&#123;return this.m&#125;,O.prototype.getCopyMatrix=function()&#123;return new Float32Array(this.m)&#125;,O.prototype.setMatrix=function(t)&#123;if(null!=t&amp;&amp;16==t.length)for(var e=0;e&lt;16;e++)this.m[e]=t[e]&#125;,O.prototype.mult=function(t,e,i)&#123;return null==e?null:(this==e?this.mult_safe(this.m,t.m,e.m,i):this.mult_fast(this.m,t.m,e.m,i),e)&#125;,O.prototype.mult_safe=function(t,e,i,r)&#123;if(t==i)&#123;var o=new Array(16);this.mult_fast(t,e,o,r);for(var n=15;n&gt;=0;--n)i[n]=o[n]&#125;else this.mult_fast(t,e,i,r)&#125;,O.prototype.mult_fast=function(t,e,i,r)&#123;r?(i[0]=t[0]*e[0]+t[4]*e[1]+t[8]*e[2],i[4]=t[0]*e[4]+t[4]*e[5]+t[8]*e[6],i[8]=t[0]*e[8]+t[4]*e[9]+t[8]*e[10],i[12]=t[0]*e[12]+t[4]*e[13]+t[8]*e[14]+t[12],i[1]=t[1]*e[0]+t[5]*e[1]+t[9]*e[2],i[5]=t[1]*e[4]+t[5]*e[5]+t[9]*e[6],i[9]=t[1]*e[8]+t[5]*e[9]+t[9]*e[10],i[13]=t[1]*e[12]+t[5]*e[13]+t[9]*e[14]+t[13],i[2]=t[2]*e[0]+t[6]*e[1]+t[10]*e[2],i[6]=t[2]*e[4]+t[6]*e[5]+t[10]*e[6],i[10]=t[2]*e[8]+t[6]*e[9]+t[10]*e[10],i[14]=t[2]*e[12]+t[6]*e[13]+t[10]*e[14]+t[14],i[3]=i[7]=i[11]=0,i[15]=1):(i[0]=t[0]*e[0]+t[4]*e[1]+t[8]*e[2]+t[12]*e[3],i[4]=t[0]*e[4]+t[4]*e[5]+t[8]*e[6]+t[12]*e[7],i[8]=t[0]*e[8]+t[4]*e[9]+t[8]*e[10]+t[12]*e[11],i[12]=t[0]*e[12]+t[4]*e[13]+t[8]*e[14]+t[12]*e[15],i[1]=t[1]*e[0]+t[5]*e[1]+t[9]*e[2]+t[13]*e[3],i[5]=t[1]*e[4]+t[5]*e[5]+t[9]*e[6]+t[13]*e[7],i[9]=t[1]*e[8]+t[5]*e[9]+t[9]*e[10]+t[13]*e[11],i[13]=t[1]*e[12]+t[5]*e[13]+t[9]*e[14]+t[13]*e[15],i[2]=t[2]*e[0]+t[6]*e[1]+t[10]*e[2]+t[14]*e[3],i[6]=t[2]*e[4]+t[6]*e[5]+t[10]*e[6]+t[14]*e[7],i[10]=t[2]*e[8]+t[6]*e[9]+t[10]*e[10]+t[14]*e[11],i[14]=t[2]*e[12]+t[6]*e[13]+t[10]*e[14]+t[14]*e[15],i[3]=t[3]*e[0]+t[7]*e[1]+t[11]*e[2]+t[15]*e[3],i[7]=t[3]*e[4]+t[7]*e[5]+t[11]*e[6]+t[15]*e[7],i[11]=t[3]*e[8]+t[7]*e[9]+t[11]*e[10]+t[15]*e[11],i[15]=t[3]*e[12]+t[7]*e[13]+t[11]*e[14]+t[15]*e[15])&#125;,O.prototype.translate=function(t,e,i)&#123;this.m[12]=this.m[0]*t+this.m[4]*e+this.m[8]*i+this.m[12],this.m[13]=this.m[1]*t+this.m[5]*e+this.m[9]*i+this.m[13],this.m[14]=this.m[2]*t+this.m[6]*e+this.m[10]*i+this.m[14],this.m[15]=this.m[3]*t+this.m[7]*e+this.m[11]*i+this.m[15]&#125;,O.prototype.scale=function(t,e,i)&#123;this.m[0]*=t,this.m[4]*=e,this.m[8]*=i,this.m[1]*=t,this.m[5]*=e,this.m[9]*=i,this.m[2]*=t,this.m[6]*=e,this.m[10]*=i,this.m[3]*=t,this.m[7]*=e,this.m[11]*=i&#125;,O.prototype.rotateX=function(t)&#123;var e=vt.fcos(t),i=vt._$9(t),r=this.m[4];this.m[4]=r*e+this.m[8]*i,this.m[8]=r*-i+this.m[8]*e,r=this.m[5],this.m[5]=r*e+this.m[9]*i,this.m[9]=r*-i+this.m[9]*e,r=this.m[6],this.m[6]=r*e+this.m[10]*i,this.m[10]=r*-i+this.m[10]*e,r=this.m[7],this.m[7]=r*e+this.m[11]*i,this.m[11]=r*-i+this.m[11]*e&#125;,O.prototype.rotateY=function(t)&#123;var e=vt.fcos(t),i=vt._$9(t),r=this.m[0];this.m[0]=r*e+this.m[8]*-i,this.m[8]=r*i+this.m[8]*e,r=this.m[1],this.m[1]=r*e+this.m[9]*-i,this.m[9]=r*i+this.m[9]*e,r=m[2],this.m[2]=r*e+this.m[10]*-i,this.m[10]=r*i+this.m[10]*e,r=m[3],this.m[3]=r*e+this.m[11]*-i,this.m[11]=r*i+this.m[11]*e&#125;,O.prototype.rotateZ=function(t)&#123;var e=vt.fcos(t),i=vt._$9(t),r=this.m[0];this.m[0]=r*e+this.m[4]*i,this.m[4]=r*-i+this.m[4]*e,r=this.m[1],this.m[1]=r*e+this.m[5]*i,this.m[5]=r*-i+this.m[5]*e,r=this.m[2],this.m[2]=r*e+this.m[6]*i,this.m[6]=r*-i+this.m[6]*e,r=this.m[3],this.m[3]=r*e+this.m[7]*i,this.m[7]=r*-i+this.m[7]*e&#125;,R.prototype=new it,R._$tP=new Object,R._$27=function()&#123;R._$tP.clear()&#125;,R.getID=function(t)&#123;var e=R._$tP[t];return null==e&amp;&amp;(e=new R(t),R._$tP[t]=e),e&#125;,R.prototype._$3s=function()&#123;return new R&#125;,b._$kS=-1,b._$pS=0,b._$hb=1,b.STATE_IDENTITY=0,b._$gb=1,b._$fo=2,b._$go=4,b.prototype.transform=function(t,e,i)&#123;var r,o,n,s,_,a,h=0,l=0;switch(this._$hi)&#123;default:return;case b._$go|b._$fo|b._$gb:for(r=this._$7,o=this._$H,n=this._$k,s=this._$f,_=this._$g,a=this._$w;--i&gt;=0;)&#123;var $=t[h++],u=t[h++];e[l++]=r*$+o*u+n,e[l++]=s*$+_*u+a&#125;return;case b._$go|b._$fo:for(r=this._$7,o=this._$H,s=this._$f,_=this._$g;--i&gt;=0;)&#123;$=t[h++],u=t[h++];e[l++]=r*$+o*u,e[l++]=s*$+_*u&#125;return;case b._$go|b._$gb:for(o=this._$H,n=this._$k,s=this._$f,a=this._$w;--i&gt;=0;)&#123;$=t[h++];e[l++]=o*t[h++]+n,e[l++]=s*$+a&#125;return;case b._$go:for(o=this._$H,s=this._$f;--i&gt;=0;)&#123;$=t[h++];e[l++]=o*t[h++],e[l++]=s*$&#125;return;case b._$fo|b._$gb:for(r=this._$7,n=this._$k,_=this._$g,a=this._$w;--i&gt;=0;)e[l++]=r*t[h++]+n,e[l++]=_*t[h++]+a;return;case b._$fo:for(r=this._$7,_=this._$g;--i&gt;=0;)e[l++]=r*t[h++],e[l++]=_*t[h++];return;case b._$gb:for(n=this._$k,a=this._$w;--i&gt;=0;)e[l++]=t[h++]+n,e[l++]=t[h++]+a;return;case b.STATE_IDENTITY:return void(t==e&amp;&amp;h==l||x._$jT(t,h,e,l,2*i))&#125;&#125;,b.prototype.update=function()&#123;0==this._$H&amp;&amp;0==this._$f?1==this._$7&amp;&amp;1==this._$g?0==this._$k&amp;&amp;0==this._$w?(this._$hi=b.STATE_IDENTITY,this._$Z=b._$pS):(this._$hi=b._$gb,this._$Z=b._$hb):0==this._$k&amp;&amp;0==this._$w?(this._$hi=b._$fo,this._$Z=b._$kS):(this._$hi=b._$fo|b._$gb,this._$Z=b._$kS):0==this._$7&amp;&amp;0==this._$g?0==this._$k&amp;&amp;0==this._$w?(this._$hi=b._$go,this._$Z=b._$kS):(this._$hi=b._$go|b._$gb,this._$Z=b._$kS):0==this._$k&amp;&amp;0==this._$w?(this._$hi=b._$go|b._$fo,this._$Z=b._$kS):(this._$hi=b._$go|b._$fo|b._$gb,this._$Z=b._$kS)&#125;,b.prototype._$RT=function(t)&#123;this._$IT(t);var e=t[0],i=t[2],r=t[1],o=t[3],n=Math.sqrt(e*e+r*r),s=e*o-i*r;0==n?_t._$so&amp;&amp;console.log(&quot;affine._$RT() / rt==0&quot;):(t[0]=n,t[1]=s/n,t[2]=(r*o+e*i)/s,t[3]=Math.atan2(r,e))&#125;,b.prototype._$ho=function(t,e,i,r)&#123;var o=new Float32Array(6),n=new Float32Array(6);t._$RT(o),e._$RT(n);var s=new Float32Array(6);s[0]=o[0]+(n[0]-o[0])*i,s[1]=o[1]+(n[1]-o[1])*i,s[2]=o[2]+(n[2]-o[2])*i,s[3]=o[3]+(n[3]-o[3])*i,s[4]=o[4]+(n[4]-o[4])*i,s[5]=o[5]+(n[5]-o[5])*i,r._$CT(s)&#125;,b.prototype._$CT=function(t)&#123;var e=Math.cos(t[3]),i=Math.sin(t[3]);this._$7=t[0]*e,this._$f=t[0]*i,this._$H=t[1]*(t[2]*e-i),this._$g=t[1]*(t[2]*i+e),this._$k=t[4],this._$w=t[5],this.update()&#125;,b.prototype._$IT=function(t)&#123;t[0]=this._$7,t[1]=this._$f,t[2]=this._$H,t[3]=this._$g,t[4]=this._$k,t[5]=this._$w&#125;,F.prototype=new s,F._$cs=&quot;VISIBLE:&quot;,F._$ar=&quot;LAYOUT:&quot;,F._$Co=0,F._$D2=[],F._$1T=1,F.loadMotion=function(t)&#123;var e=new F,i=[0],r=t.length;e._$yT=0;for(var o=0;o&lt;r;++o)&#123;var n=255&amp;t[o];if(&quot;\\n&quot;!=n&amp;&amp;&quot;\\r&quot;!=n)if(&quot;#&quot;!=n)if(&quot;$&quot;!=n)&#123;if(&quot;a&quot;&lt;=n&amp;&amp;n&lt;=&quot;z&quot;||&quot;A&quot;&lt;=n&amp;&amp;n&lt;=&quot;Z&quot;||&quot;_&quot;==n)&#123;for(h=o,l=-1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=255&amp;t[o])&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;=&quot;==n)&#123;l=o;break&#125;if(l&gt;=0)&#123;var s=new N;w.startsWith(t,h,F._$cs)?(s._$RP=N._$hs,s._$4P=new String(t,h,l-h)):w.startsWith(t,h,F._$ar)?(s._$4P=new String(t,h+7,l-h-7),w.startsWith(t,h+7,&quot;ANCHOR_X&quot;)?s._$RP=N._$xs:w.startsWith(t,h+7,&quot;ANCHOR_Y&quot;)?s._$RP=N._$us:w.startsWith(t,h+7,&quot;SCALE_X&quot;)?s._$RP=N._$qs:w.startsWith(t,h+7,&quot;SCALE_Y&quot;)?s._$RP=N._$Ys:w.startsWith(t,h+7,&quot;X&quot;)?s._$RP=N._$ws:w.startsWith(t,h+7,&quot;Y&quot;)&amp;&amp;(s._$RP=N._$Ns)):(s._$RP=N._$Fr,s._$4P=new String(t,h,l-h)),e.motions.push(s);var _=0;for(F._$D2.clear(),o=l+1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=255&amp;t[o])&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;,&quot;!=n&amp;&amp;&quot; &quot;!=n&amp;&amp;&quot;\\t&quot;!=n)&#123;u=w._$LS(t,r,o,i);if(i[0]&gt;0)&#123;F._$D2.push(u),_++;var a=i[0];if(a&lt;o)&#123;console.log(&quot;_$n0 _$hi . @Live2DMotion loadMotion()\\n&quot;);break&#125;o=a&#125;&#125;s._$I0=F._$D2._$BL(),_&gt;e._$yT&amp;&amp;(e._$yT=_)&#125;&#125;&#125;else&#123;for(var h=o,l=-1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=255&amp;t[o])&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;=&quot;==n)&#123;l=o;break&#125;var $=!1;if(l&gt;=0)for(l==h+4&amp;&amp;&quot;f&quot;==t[h+1]&amp;&amp;&quot;p&quot;==t[h+2]&amp;&amp;&quot;s&quot;==t[h+3]&amp;&amp;($=!0),o=l+1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=255&amp;t[o])&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;,&quot;!=n&amp;&amp;&quot; &quot;!=n&amp;&amp;&quot;\\t&quot;!=n)&#123;var u=w._$LS(t,r,o,i);i[0]&gt;0&amp;&amp;$&amp;&amp;5&lt;u&amp;&amp;u&lt;121&amp;&amp;(e._$D0=u),o=i[0]&#125;for(;o&lt;r&amp;&amp;(&quot;\\n&quot;!=t[o]&amp;&amp;&quot;\\r&quot;!=t[o]);++o);&#125;else for(;o&lt;r&amp;&amp;(&quot;\\n&quot;!=t[o]&amp;&amp;&quot;\\r&quot;!=t[o]);++o);&#125;return e._$AS=1e3*e._$yT/e._$D0|0,e&#125;,F.prototype.getDurationMSec=function()&#123;return this._$AS&#125;,F.prototype.dump=function()&#123;for(var t=0;t&lt;this.motions.length;t++)&#123;var e=this.motions[t];console.log(&quot;_$wL[%s] [%d]. &quot;,e._$4P,e._$I0.length);for(var i=0;i&lt;e._$I0.length&amp;&amp;i&lt;10;i++)console.log(&quot;%5.2f ,&quot;,e._$I0[i]);console.log(&quot;\\n&quot;)&#125;&#125;,F.prototype.updateParamExe=function(t,e,i,r)&#123;for(var o=(e-r._$z2)*this._$D0/1e3,n=0|o,s=o-n,_=0;_&lt;this.motions.length;_++)&#123;var a=this.motions[_],h=a._$I0.length,l=a._$4P;if(a._$RP==N._$hs)&#123;var $=a._$I0[n&gt;=h?h-1:n];t.setParamFloat(l,$)&#125;else if(N._$ws&lt;=a._$RP&amp;&amp;a._$RP&lt;=N._$Ys);else&#123;var u=t.getParamFloat(l),p=a._$I0[n&gt;=h?h-1:n],c=u+(p+(a._$I0[n+1&gt;=h?h-1:n+1]-p)*s-u)*i;t.setParamFloat(l,c)&#125;&#125;n&gt;=this._$yT&amp;&amp;(this._$E?(r._$z2=e,this.loopFadeIn&amp;&amp;(r._$bs=e)):r._$9L=!0)&#125;,F.prototype._$r0=function()&#123;return this._$E&#125;,F.prototype._$aL=function(t)&#123;this._$E=t&#125;,F.prototype.isLoopFadeIn=function()&#123;return this.loopFadeIn&#125;,F.prototype.setLoopFadeIn=function(t)&#123;this.loopFadeIn=t&#125;,C.prototype.clear=function()&#123;this.size=0&#125;,C.prototype.add=function(t)&#123;if(this._$P.length&lt;=this.size)&#123;var e=new Float32Array(2*this.size);x._$jT(this._$P,0,e,0,this.size),this._$P=e&#125;this._$P[this.size++]=t&#125;,C.prototype._$BL=function()&#123;var t=new Float32Array(this.size);return x._$jT(this._$P,0,t,0,this.size),t&#125;,N._$Fr=0,N._$hs=1,N._$ws=100,N._$Ns=101,N._$xs=102,N._$us=103,N._$qs=104,N._$Ys=105,B._$Ms=1,B._$Qs=2,B._$i2=0,B._$No=2,B._$do=B._$Ms,B._$Ls=!0,B._$1r=5,B._$Qb=65,B._$J=1e-4,B._$FT=.001,B._$Ss=3,G._$o7=6,G._$S7=7,G._$s7=8,G._$77=9,G.LIVE2D_FORMAT_VERSION_V2_10_SDK2=10,G.LIVE2D_FORMAT_VERSION_V2_11_SDK2_1=11,G._$T7=G.LIVE2D_FORMAT_VERSION_V2_11_SDK2_1,G._$Is=-2004318072,G._$h0=0,G._$4L=23,G._$7P=33,G._$uT=function(t)&#123;console.log(&quot;_$bo :: _$6 _$mo _$E0 : %d\\n&quot;,t)&#125;,G._$9o=function(t)&#123;if(t&lt;40)return G._$uT(t),null;if(t&lt;50)return G._$uT(t),null;if(t&lt;60)return G._$uT(t),null;if(t&lt;100)switch(t)&#123;case 65:return new Z;case 66:return new D;case 67:return new I;case 68:return new z;case 69:return new d;case 70:return new lt;default:return G._$uT(t),null&#125;else if(t&lt;150)switch(t)&#123;case 131:return new nt;case 133:return new tt;case 136:return new $;case 137:return new rt;case 142:return new j&#125;return G._$uT(t),null&#125;,U._$HP=0,U._$_0=!0,U._$V2=-1,U._$W0=-1,U._$jr=!1,U._$ZS=!0,U._$tr=-1e6,U._$lr=1e6,U._$is=32,U._$e=!1,U.prototype.getDrawDataIndex=function(t)&#123;for(var e=this._$aS.length-1;e&gt;=0;--e)if(null!=this._$aS[e]&amp;&amp;this._$aS[e].getDrawDataID()==t)return e;return-1&#125;,U.prototype.getDrawData=function(t)&#123;if(t instanceof R)&#123;if(null==this._$Bo)&#123;this._$Bo=new Object;for(var e=this._$aS.length,i=0;i&lt;e;i++)&#123;var r=this._$aS[i],o=r.getDrawDataID();null!=o&amp;&amp;(this._$Bo[o]=r)&#125;&#125;return this._$Bo[id]&#125;return t&lt;this._$aS.length?this._$aS[t]:null&#125;,U.prototype.release=function()&#123;this._$3S.clear(),this._$aS.clear(),this._$F2.clear(),null!=this._$Bo&amp;&amp;this._$Bo.clear(),this._$db.clear(),this._$8b.clear(),this._$Hr.clear()&#125;,U.prototype.init=function()&#123;this._$co++,this._$F2.length&gt;0&amp;&amp;this.release();for(var t=this._$Ri.getModelImpl(),e=t._$Xr(),i=e.length,r=new Array,n=new Array,s=0;s&lt;i;++s)&#123;var _=e[s];this._$F2.push(_),this._$Hr.push(_.init(this));for(var a=_.getBaseData(),h=a.length,l=0;l&lt;h;++l)r.push(a[l]);for(l=0;l&lt;h;++l)&#123;var $=a[l].init(this);$._$l2(s),n.push($)&#125;var u=_.getDrawData(),p=u.length;for(l=0;l&lt;p;++l)&#123;var c=u[l],f=c.init(this);f._$IP=s,this._$aS.push(c),this._$8b.push(f)&#125;&#125;for(var g=r.length,y=yt._$2o();;)&#123;var d=!1;for(s=0;s&lt;g;++s)&#123;var m=r[s];if(null!=m)&#123;var T=m.getTargetBaseDataID();(null==T||T==y||this.getBaseDataIndex(T)&gt;=0)&amp;&amp;(this._$3S.push(m),this._$db.push(n[s]),r[s]=null,d=!0)&#125;&#125;if(!d)break&#125;var P=t._$E2();if(null!=P)&#123;var S=P._$1s();if(null!=S)&#123;var v=S.length;for(s=0;s&lt;v;++s)&#123;var L=S[s];null!=L&amp;&amp;this._$02(L.getParamID(),L.getDefaultValue(),L.getMinValue(),L.getMaxValue())&#125;&#125;&#125;this.clipManager=new o(this.dp_webgl),this.clipManager.init(this,this._$aS,this._$8b),this._$QT=!0&#125;,U.prototype.update=function()&#123;U._$e&amp;&amp;_.start(&quot;_$zL&quot;);for(var t=this._$_2.length,e=0;e&lt;t;e++)this._$_2[e]!=this._$vr[e]&amp;&amp;(this._$Js[e]=U._$ZS,this._$vr[e]=this._$_2[e]);var i=this._$3S.length,r=this._$aS.length,o=W._$or(),n=W._$Pr()-o+1;(null==this._$Ws||this._$Ws.length&lt;n)&amp;&amp;(this._$Ws=new Int16Array(n),this._$Vs=new Int16Array(n));for(e=0;e&lt;n;e++)this._$Ws[e]=U._$V2,this._$Vs[e]=U._$V2;(null==this._$Er||this._$Er.length&lt;r)&amp;&amp;(this._$Er=new Int16Array(r));for(e=0;e&lt;r;e++)this._$Er[e]=U._$W0;U._$e&amp;&amp;_.dump(&quot;_$zL&quot;),U._$e&amp;&amp;_.start(&quot;_$UL&quot;);for(var s=null,a=0;a&lt;i;++a)&#123;var h=this._$3S[a],l=this._$db[a];try&#123;h._$Nr(this,l),h._$2b(this,l)&#125;catch(t)&#123;null==s&amp;&amp;(s=t)&#125;&#125;null!=s&amp;&amp;U._$_0&amp;&amp;_._$Rb(s),U._$e&amp;&amp;_.dump(&quot;_$UL&quot;),U._$e&amp;&amp;_.start(&quot;_$DL&quot;);for(var $=null,u=0;u&lt;r;++u)&#123;var p=this._$aS[u],c=this._$8b[u];try&#123;if(p._$Nr(this,c),c._$u2())continue;p._$2b(this,c);var f,g=Math.floor(p._$zS(this,c)-o);try&#123;f=this._$Vs[g]&#125;catch(t)&#123;console.log(&quot;_$li :: %s / %s        @@_$fS\\n&quot;,t.toString(),p.getDrawDataID().toString()),g=Math.floor(p._$zS(this,c)-o);continue&#125;f==U._$V2?this._$Ws[g]=u:this._$Er[f]=u,this._$Vs[g]=u&#125;catch(t)&#123;null==$&amp;&amp;($=t,_t._$sT(_t._$H7))&#125;&#125;null!=$&amp;&amp;U._$_0&amp;&amp;_._$Rb($),U._$e&amp;&amp;_.dump(&quot;_$DL&quot;),U._$e&amp;&amp;_.start(&quot;_$eL&quot;);for(e=this._$Js.length-1;e&gt;=0;e--)this._$Js[e]=U._$jr;return this._$QT=!1,U._$e&amp;&amp;_.dump(&quot;_$eL&quot;),!1&#125;,U.prototype.preDraw=function(t)&#123;null!=this.clipManager&amp;&amp;(t._$ZT(),this.clipManager.setupClip(this,t))&#125;,U.prototype.draw=function(t)&#123;if(null!=this._$Ws)&#123;var e=this._$Ws.length;t._$ZT();for(var i=0;i&lt;e;++i)&#123;var r=this._$Ws[i];if(r!=U._$V2)for(;;)&#123;var o=this._$aS[r],n=this._$8b[r];if(n._$yo())&#123;var s=n._$IP,a=this._$Hr[s];n._$VS=a.getPartsOpacity(),o.draw(t,this,n)&#125;var h=this._$Er[r];if(h&lt;=r||h==U._$W0)break;r=h&#125;&#125;&#125;else _._$li(&quot;call _$Ri.update() before _$Ri.draw() &quot;)&#125;,U.prototype.getParamIndex=function(t)&#123;for(var e=this._$pb.length-1;e&gt;=0;--e)if(this._$pb[e]==t)return e;return this._$02(t,0,U._$tr,U._$lr)&#125;,U.prototype._$BS=function(t)&#123;return this.getBaseDataIndex(t)&#125;,U.prototype.getBaseDataIndex=function(t)&#123;for(var e=this._$3S.length-1;e&gt;=0;--e)if(null!=this._$3S[e]&amp;&amp;this._$3S[e].getBaseDataID()==t)return e;return-1&#125;,U.prototype._$UT=function(t,e)&#123;var i=new Float32Array(e);return x._$jT(t,0,i,0,t.length),i&#125;,U.prototype._$02=function(t,e,i,r)&#123;if(this._$qo&gt;=this._$pb.length)&#123;var o=this._$pb.length,n=new Array(2*o);x._$jT(this._$pb,0,n,0,o),this._$pb=n,this._$_2=this._$UT(this._$_2,2*o),this._$vr=this._$UT(this._$vr,2*o),this._$Rr=this._$UT(this._$Rr,2*o),this._$Or=this._$UT(this._$Or,2*o);var s=new Array;x._$jT(this._$Js,0,s,0,o),this._$Js=s&#125;return this._$pb[this._$qo]=t,this._$_2[this._$qo]=e,this._$vr[this._$qo]=e,this._$Rr[this._$qo]=i,this._$Or[this._$qo]=r,this._$Js[this._$qo]=U._$ZS,this._$qo++&#125;,U.prototype._$Zo=function(t,e)&#123;this._$3S[t]=e&#125;,U.prototype.setParamFloat=function(t,e)&#123;e&lt;this._$Rr[t]&amp;&amp;(e=this._$Rr[t]),e&gt;this._$Or[t]&amp;&amp;(e=this._$Or[t]),this._$_2[t]=e&#125;,U.prototype.loadParam=function()&#123;var t=this._$_2.length;t&gt;this._$fs.length&amp;&amp;(t=this._$fs.length),x._$jT(this._$fs,0,this._$_2,0,t)&#125;,U.prototype.saveParam=function()&#123;var t=this._$_2.length;t&gt;this._$fs.length&amp;&amp;(this._$fs=new Float32Array(t)),x._$jT(this._$_2,0,this._$fs,0,t)&#125;,U.prototype._$v2=function()&#123;return this._$co&#125;,U.prototype._$WS=function()&#123;return this._$QT&#125;,U.prototype._$Xb=function(t)&#123;return this._$Js[t]==U._$ZS&#125;,U.prototype._$vs=function()&#123;return this._$Es&#125;,U.prototype._$Tr=function()&#123;return this._$ZP&#125;,U.prototype.getBaseData=function(t)&#123;return this._$3S[t]&#125;,U.prototype.getParamFloat=function(t)&#123;return this._$_2[t]&#125;,U.prototype.getParamMax=function(t)&#123;return this._$Or[t]&#125;,U.prototype.getParamMin=function(t)&#123;return this._$Rr[t]&#125;,U.prototype.setPartsOpacity=function(t,e)&#123;this._$Hr[t].setPartsOpacity(e)&#125;,U.prototype.getPartsOpacity=function(t)&#123;return this._$Hr[t].getPartsOpacity()&#125;,U.prototype.getPartsDataIndex=function(t)&#123;for(var e=this._$F2.length-1;e&gt;=0;--e)if(null!=this._$F2[e]&amp;&amp;this._$F2[e]._$p2()==t)return e;return-1&#125;,U.prototype._$q2=function(t)&#123;return this._$db[t]&#125;,U.prototype._$C2=function(t)&#123;return this._$8b[t]&#125;,U.prototype._$Bb=function(t)&#123;return this._$Hr[t]&#125;,U.prototype._$5s=function(t,e)&#123;for(var i=this._$Ws.length,r=t,o=0;o&lt;i;++o)&#123;var n=this._$Ws[o];if(n!=U._$V2)for(;;)&#123;var s=this._$8b[n];s._$yo()&amp;&amp;(s._$GT()._$B2(this,s,r),r+=e);var _=this._$Er[n];if(_&lt;=n||_==U._$W0)break;n=_&#125;&#125;&#125;,U.prototype.setDrawParam=function(t)&#123;this.dp_webgl=t&#125;,U.prototype.getDrawParam=function()&#123;return this.dp_webgl&#125;,Y._$0T=function(t)&#123;return Y._$0T(new _$5(t))&#125;,Y._$0T=function(t)&#123;if(!t.exists())throw new _$ls(t._$3b());for(var e,i=t.length(),r=new Int8Array(i),o=new _$Xs(new _$kb(t),8192),n=0;(e=o.read(r,n,i-n))&gt;0;)n+=e;return r&#125;,Y._$C=function(t)&#123;var e=null,i=null;try&#123;e=t instanceof Array?t:new _$Xs(t,8192),i=new _$js;for(var r,o=new Int8Array(1e3);(r=e.read(o))&gt;0;)i.write(o,0,r);return i._$TS()&#125;finally&#123;null!=t&amp;&amp;t.close(),null!=i&amp;&amp;(i.flush(),i.close())&#125;&#125;,k.prototype._$T2=function()&#123;return x.getUserTimeMSec()+Math._$10()*(2*this._$Br-1)&#125;,k.prototype._$uo=function(t)&#123;this._$Br=t&#125;,k.prototype._$QS=function(t,e,i)&#123;this._$Dr=t,this._$Cb=e,this._$mr=i&#125;,k.prototype._$7T=function(t)&#123;var e,i=x.getUserTimeMSec(),r=0;switch(this._$_L)&#123;case STATE_CLOSING:(r=(i-this._$bb)/this._$Dr)&gt;=1&amp;&amp;(r=1,this._$_L=V.STATE_CLOSED,this._$bb=i),e=1-r;break;case STATE_CLOSED:(r=(i-this._$bb)/this._$Cb)&gt;=1&amp;&amp;(this._$_L=V.STATE_OPENING,this._$bb=i),e=0;break;case STATE_OPENING:(r=(i-this._$bb)/this._$mr)&gt;=1&amp;&amp;(r=1,this._$_L=V.STATE_INTERVAL,this._$12=this._$T2()),e=r;break;case STATE_INTERVAL:this._$12&lt;i&amp;&amp;(this._$_L=V.STATE_CLOSING,this._$bb=i),e=1;break;case STATE_FIRST:default:this._$_L=V.STATE_INTERVAL,this._$12=this._$T2(),e=1&#125;this._$jo||(e=-e),t.setParamFloat(this._$iL,e),t.setParamFloat(this._$0L,e)&#125;;var V=function()&#123;&#125;;function X()&#123;i||(M.prototype.constructor.call(this),this._$sb=new Int32Array(X._$As),this._$U2=new Array,this.transform=null,this.gl=null,null==X._$NT&amp;&amp;(X._$NT=X._$9r(256),X._$vS=X._$9r(256),X._$no=X._$vb(256)))&#125;function z()&#123;i||(A.prototype.constructor.call(this),this._$GS=null,this._$Y0=null)&#125;function H(t)&#123;st.prototype.constructor.call(this,t),this._$8r=A._$ur,this._$Yr=null,this._$Wr=null&#125;function W()&#123;i||(L.prototype.constructor.call(this),this._$gP=null,this._$dr=null,this._$GS=null,this._$qb=null,this._$Lb=null,this._$mS=null)&#125;function j()&#123;i||(this._$NL=null,this._$3S=null,this._$aS=null,j._$42++)&#125;function q()&#123;i||(r.prototype.constructor.call(this),this._$zo=new X)&#125;function J()&#123;i||(s.prototype.constructor.call(this),this.motions=new Array,this._$o2=null,this._$7r=J._$Co++,this._$D0=30,this._$yT=0,this._$E=!1,this.loopFadeIn=!0,this._$rr=-1,this._$eP=0)&#125;function Q(t,e)&#123;return String.fromCharCode(t.getUint8(e))&#125;function C()&#123;this._$P=new Float32Array(100),this.size=0&#125;function N()&#123;this._$4P=null,this._$I0=null,this._$RP=null&#125;function Z()&#123;i||(A.prototype.constructor.call(this),this._$o=0,this._$A=0,this._$GS=null,this._$Eo=null)&#125;function K(t)&#123;st.prototype.constructor.call(this,t),this._$8r=A._$ur,this._$Cr=null,this._$hr=null&#125;function tt()&#123;i||(this.visible=!0,this._$g0=!1,this._$NL=null,this._$3S=null,this._$aS=null,tt._$42++)&#125;function et(t)&#123;this._$VS=null,this._$e0=null,this._$e0=t&#125;function it(t)&#123;i||(this.id=t)&#125;function rt()&#123;i||(this._$4S=null)&#125;function ot(t,e)&#123;this.canvas=t,this.context=e,this.viewport=new Array(0,0,t.width,t.height),this._$6r=1,this._$xP=0,this._$3r=1,this._$uP=0,this._$Qo=-1,this.cacheImages=&#123;&#125;&#125;function nt()&#123;i||(this._$TT=null,this._$LT=null,this._$FS=null,this._$wL=null)&#125;function st(t)&#123;i||(this._$e0=null,this._$IP=null,this._$JS=!1,this._$AT=!0,this._$e0=t,this.totalScale=1,this._$7s=1,this.totalOpacity=1)&#125;function _t()&#123;&#125;function at()&#123;&#125;function ht(t)&#123;i||(this._$ib=t)&#125;function lt()&#123;i||(W.prototype.constructor.call(this),this._$LP=-1,this._$d0=0,this._$Yo=0,this._$JP=null,this._$5P=null,this._$BP=null,this._$Eo=null,this._$Qi=null,this._$6s=lt._$ms,this.culling=!0,this.gl_cacheImage=null,this.instanceNo=lt._$42++)&#125;function $t(t)&#123;Lt.prototype.constructor.call(this,t),this._$8r=W._$ur,this._$Cr=null,this._$hr=null&#125;function ut()&#123;i||(this.x=null,this.y=null)&#125;function pt(t)&#123;i||(r.prototype.constructor.call(this),this.drawParamWebGL=new dt(t),this.drawParamWebGL.setGL(_t.getGL(t)))&#125;function ct()&#123;i||(this.motions=null,this._$eb=!1,this.motions=new Array)&#125;function ft()&#123;this._$w0=null,this._$AT=!0,this._$9L=!1,this._$z2=-1,this._$bs=-1,this._$Do=-1,this._$sr=null,this._$sr=ft._$Gs++&#125;function gt()&#123;this.m=new Array(1,0,0,0,1,0,0,0,1)&#125;function yt(t)&#123;i||it.prototype.constructor.call(this,t)&#125;function dt(t)&#123;i||(M.prototype.constructor.call(this),this.textures=new Array,this.transform=null,this.gl=null,this.glno=t,this.firstDraw=!0,this.anisotropyExt=null,this.maxAnisotropy=0,this._$As=32,this._$Gr=!1,this._$NT=null,this._$vS=null,this._$no=null,this.vertShader=null,this.fragShader=null,this.vertShaderOff=null,this.fragShaderOff=null)&#125;function mt(t,e,i)&#123;return null==e&amp;&amp;(e=t.createBuffer()),t.bindBuffer(t.ARRAY_BUFFER,e),t.bufferData(t.ARRAY_BUFFER,i,t.DYNAMIC_DRAW),e&#125;function Tt(t,e,i)&#123;return null==e&amp;&amp;(e=t.createBuffer()),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e),t.bufferData(t.ELEMENT_ARRAY_BUFFER,i,t.DYNAMIC_DRAW),e&#125;function Pt(t)&#123;i||(this._$P=new Int8Array(8),this._$R0=new DataView(this._$P.buffer),this._$3i=new Int8Array(1e3),this._$hL=0,this._$v0=0,this._$S2=0,this._$Ko=new Array,this._$T=t,this._$F=0)&#125;V.STATE_FIRST=&quot;STATE_FIRST&quot;,V.STATE_INTERVAL=&quot;STATE_INTERVAL&quot;,V.STATE_CLOSING=&quot;STATE_CLOSING&quot;,V.STATE_CLOSED=&quot;STATE_CLOSED&quot;,V.STATE_OPENING=&quot;STATE_OPENING&quot;,X.prototype=new M,X._$As=32,X._$Gr=!1,X._$NT=null,X._$vS=null,X._$no=null,X._$9r=function(t)&#123;return new Float32Array(t)&#125;,X._$vb=function(t)&#123;return new Int16Array(t)&#125;,X._$cr=function(t,e)&#123;return null==t||t._$yL()&lt;e.length?((t=X._$9r(2*e.length)).put(e),t._$oT(0)):(t.clear(),t.put(e),t._$oT(0)),t&#125;,X._$mb=function(t,e)&#123;return null==t||t._$yL()&lt;e.length?((t=X._$vb(2*e.length)).put(e),t._$oT(0)):(t.clear(),t.put(e),t._$oT(0)),t&#125;,X._$Hs=function()&#123;return X._$Gr&#125;,X._$as=function(t)&#123;X._$Gr=t&#125;,X.prototype.setGL=function(t)&#123;this.gl=t&#125;,X.prototype.setTransform=function(t)&#123;this.transform=t&#125;,X.prototype._$ZT=function()&#123;&#125;,X.prototype._$Uo=function(t,e,i,r,o,n,s,_)&#123;if(!(n&lt;.01))&#123;var a=this._$U2[t],h=n&gt;.9?_t.EXPAND_W:0;this.gl.drawElements(a,i,r,o,n,h,this.transform,_)&#125;&#125;,X.prototype._$Rs=function()&#123;throw new Error(&quot;_$Rs&quot;)&#125;,X.prototype._$Ds=function(t)&#123;throw new Error(&quot;_$Ds&quot;)&#125;,X.prototype._$K2=function()&#123;for(var t=0;t&lt;this._$sb.length;t++)&#123;0!=this._$sb[t]&amp;&amp;(this.gl._$Sr(1,this._$sb,t),this._$sb[t]=0)&#125;&#125;,X.prototype.setTexture=function(t,e)&#123;this._$sb.length&lt;t+1&amp;&amp;this._$nS(t),this._$sb[t]=e&#125;,X.prototype.setTexture=function(t,e)&#123;this._$sb.length&lt;t+1&amp;&amp;this._$nS(t),this._$U2[t]=e&#125;,X.prototype._$nS=function(t)&#123;var e=Math.max(2*this._$sb.length,t+1+10),i=new Int32Array(e);x._$jT(this._$sb,0,i,0,this._$sb.length),this._$sb=i;var r=new Array;x._$jT(this._$U2,0,r,0,this._$U2.length),this._$U2=r&#125;,z.prototype=new A,z._$Xo=new Float32Array(2),z._$io=new Float32Array(2),z._$0o=new Float32Array(2),z._$Lo=new Float32Array(2),z._$To=new Float32Array(2),z._$Po=new Float32Array(2),z._$gT=new Array,z.prototype._$zP=function()&#123;this._$GS=new D,this._$GS._$zP(),this._$Y0=new Array&#125;,z.prototype.getType=function()&#123;return A._$c2&#125;,z.prototype._$F0=function(t)&#123;A.prototype._$F0.call(this,t),this._$GS=t._$nP(),this._$Y0=t._$nP(),A.prototype.readV2_opacity.call(this,t)&#125;,z.prototype.init=function(t)&#123;var e=new H(this);return e._$Yr=new d,this._$32()&amp;&amp;(e._$Wr=new d),e&#125;,z.prototype._$Nr=function(t,e)&#123;this!=e._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;);var i=e;if(this._$GS._$Ur(t))&#123;var r=z._$gT;r[0]=!1;var o=this._$GS._$Q2(t,r);e._$Ib(r[0]),this.interpolateOpacity(t,this._$GS,e,r);var n=t._$vs(),s=t._$Tr();if(this._$GS._$zr(n,s,o),o&lt;=0)&#123;var _=this._$Y0[n[0]];i._$Yr.init(_)&#125;else if(1==o)&#123;_=this._$Y0[n[0]];var a=this._$Y0[n[1]],h=s[0];i._$Yr._$fL=_._$fL+(a._$fL-_._$fL)*h,i._$Yr._$gL=_._$gL+(a._$gL-_._$gL)*h,i._$Yr._$B0=_._$B0+(a._$B0-_._$B0)*h,i._$Yr._$z0=_._$z0+(a._$z0-_._$z0)*h,i._$Yr._$qT=_._$qT+(a._$qT-_._$qT)*h&#125;else if(2==o)&#123;_=this._$Y0[n[0]],a=this._$Y0[n[1]];var l=this._$Y0[n[2]],$=this._$Y0[n[3]],u=(h=s[0],s[1]),p=_._$fL+(a._$fL-_._$fL)*h,c=l._$fL+($._$fL-l._$fL)*h;i._$Yr._$fL=p+(c-p)*u,p=_._$gL+(a._$gL-_._$gL)*h,c=l._$gL+($._$gL-l._$gL)*h,i._$Yr._$gL=p+(c-p)*u,p=_._$B0+(a._$B0-_._$B0)*h,c=l._$B0+($._$B0-l._$B0)*h,i._$Yr._$B0=p+(c-p)*u,p=_._$z0+(a._$z0-_._$z0)*h,c=l._$z0+($._$z0-l._$z0)*h,i._$Yr._$z0=p+(c-p)*u,p=_._$qT+(a._$qT-_._$qT)*h,c=l._$qT+($._$qT-l._$qT)*h,i._$Yr._$qT=p+(c-p)*u&#125;else if(3==o)&#123;var f=this._$Y0[n[0]],g=this._$Y0[n[1]],y=this._$Y0[n[2]],d=this._$Y0[n[3]],m=this._$Y0[n[4]],T=this._$Y0[n[5]],P=this._$Y0[n[6]],S=this._$Y0[n[7]],v=(h=s[0],u=s[1],s[2]),L=(p=f._$fL+(g._$fL-f._$fL)*h,c=y._$fL+(d._$fL-y._$fL)*h,m._$fL+(T._$fL-m._$fL)*h),M=P._$fL+(S._$fL-P._$fL)*h;i._$Yr._$fL=(1-v)*(p+(c-p)*u)+v*(L+(M-L)*u),p=f._$gL+(g._$gL-f._$gL)*h,c=y._$gL+(d._$gL-y._$gL)*h,L=m._$gL+(T._$gL-m._$gL)*h,M=P._$gL+(S._$gL-P._$gL)*h,i._$Yr._$gL=(1-v)*(p+(c-p)*u)+v*(L+(M-L)*u),p=f._$B0+(g._$B0-f._$B0)*h,c=y._$B0+(d._$B0-y._$B0)*h,L=m._$B0+(T._$B0-m._$B0)*h,M=P._$B0+(S._$B0-P._$B0)*h,i._$Yr._$B0=(1-v)*(p+(c-p)*u)+v*(L+(M-L)*u),p=f._$z0+(g._$z0-f._$z0)*h,c=y._$z0+(d._$z0-y._$z0)*h,L=m._$z0+(T._$z0-m._$z0)*h,M=P._$z0+(S._$z0-P._$z0)*h,i._$Yr._$z0=(1-v)*(p+(c-p)*u)+v*(L+(M-L)*u),p=f._$qT+(g._$qT-f._$qT)*h,c=y._$qT+(d._$qT-y._$qT)*h,L=m._$qT+(T._$qT-m._$qT)*h,M=P._$qT+(S._$qT-P._$qT)*h,i._$Yr._$qT=(1-v)*(p+(c-p)*u)+v*(L+(M-L)*u)&#125;else if(4==o)&#123;var E=this._$Y0[n[0]],A=this._$Y0[n[1]],x=this._$Y0[n[2]],I=this._$Y0[n[3]],w=this._$Y0[n[4]],D=this._$Y0[n[5]],O=this._$Y0[n[6]],R=this._$Y0[n[7]],b=this._$Y0[n[8]],F=this._$Y0[n[9]],C=this._$Y0[n[10]],N=this._$Y0[n[11]],B=this._$Y0[n[12]],G=this._$Y0[n[13]],U=this._$Y0[n[14]],Y=this._$Y0[n[15]],k=(h=s[0],u=s[1],v=s[2],s[3]),V=(p=E._$fL+(A._$fL-E._$fL)*h,c=x._$fL+(I._$fL-x._$fL)*h,L=w._$fL+(D._$fL-w._$fL)*h,M=O._$fL+(R._$fL-O._$fL)*h,b._$fL+(F._$fL-b._$fL)*h),X=C._$fL+(N._$fL-C._$fL)*h,H=B._$fL+(G._$fL-B._$fL)*h,W=U._$fL+(Y._$fL-U._$fL)*h;i._$Yr._$fL=(1-k)*((1-v)*(p+(c-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$gL+(A._$gL-E._$gL)*h,c=x._$gL+(I._$gL-x._$gL)*h,L=w._$gL+(D._$gL-w._$gL)*h,M=O._$gL+(R._$gL-O._$gL)*h,V=b._$gL+(F._$gL-b._$gL)*h,X=C._$gL+(N._$gL-C._$gL)*h,H=B._$gL+(G._$gL-B._$gL)*h,W=U._$gL+(Y._$gL-U._$gL)*h,i._$Yr._$gL=(1-k)*((1-v)*(p+(c-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$B0+(A._$B0-E._$B0)*h,c=x._$B0+(I._$B0-x._$B0)*h,L=w._$B0+(D._$B0-w._$B0)*h,M=O._$B0+(R._$B0-O._$B0)*h,V=b._$B0+(F._$B0-b._$B0)*h,X=C._$B0+(N._$B0-C._$B0)*h,H=B._$B0+(G._$B0-B._$B0)*h,W=U._$B0+(Y._$B0-U._$B0)*h,i._$Yr._$B0=(1-k)*((1-v)*(p+(c-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$z0+(A._$z0-E._$z0)*h,c=x._$z0+(I._$z0-x._$z0)*h,L=w._$z0+(D._$z0-w._$z0)*h,M=O._$z0+(R._$z0-O._$z0)*h,V=b._$z0+(F._$z0-b._$z0)*h,X=C._$z0+(N._$z0-C._$z0)*h,H=B._$z0+(G._$z0-B._$z0)*h,W=U._$z0+(Y._$z0-U._$z0)*h,i._$Yr._$z0=(1-k)*((1-v)*(p+(c-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u)),p=E._$qT+(A._$qT-E._$qT)*h,c=x._$qT+(I._$qT-x._$qT)*h,L=w._$qT+(D._$qT-w._$qT)*h,M=O._$qT+(R._$qT-O._$qT)*h,V=b._$qT+(F._$qT-b._$qT)*h,X=C._$qT+(N._$qT-C._$qT)*h,H=B._$qT+(G._$qT-B._$qT)*h,W=U._$qT+(Y._$qT-U._$qT)*h,i._$Yr._$qT=(1-k)*((1-v)*(p+(c-p)*u)+v*(L+(M-L)*u))+k*((1-v)*(V+(X-V)*u)+v*(H+(W-H)*u))&#125;else&#123;for(var j=0|Math.pow(2,o),q=new Float32Array(j),J=0;J&lt;j;J++)&#123;for(var Q=J,Z=1,K=0;K&lt;o;K++)Z*=Q%2==0?1-s[K]:s[K],Q/=2;q[J]=Z&#125;for(var tt=new Array,et=0;et&lt;j;et++)tt[et]=this._$Y0[n[et]];var it=0,rt=0,ot=0,nt=0,st=0;for(et=0;et&lt;j;et++)it+=q[et]*tt[et]._$fL,rt+=q[et]*tt[et]._$gL,ot+=q[et]*tt[et]._$B0,nt+=q[et]*tt[et]._$z0,st+=q[et]*tt[et]._$qT;i._$Yr._$fL=it,i._$Yr._$gL=rt,i._$Yr._$B0=ot,i._$Yr._$z0=nt,i._$Yr._$qT=st&#125;_=this._$Y0[n[0]];i._$Yr.reflectX=_.reflectX,i._$Yr.reflectY=_.reflectY&#125;&#125;,z.prototype._$2b=function(t,e)&#123;this!=e._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;);var i=e;if(i._$hS(!0),this._$32())&#123;var r=this.getTargetBaseDataID();if(i._$8r==A._$ur&amp;&amp;(i._$8r=t.getBaseDataIndex(r)),i._$8r&lt;0)_t._$so&amp;&amp;_._$li(&quot;_$L _$0P _$G :: %s&quot;,r),i._$hS(!1);else&#123;var o=t.getBaseData(i._$8r);if(null!=o)&#123;var n=t._$q2(i._$8r),s=z._$Xo;s[0]=i._$Yr._$fL,s[1]=i._$Yr._$gL;var a=z._$io;a[0]=0,a[1]=-.1,n._$GT().getType()==A._$c2?a[1]=-10:a[1]=-.1;var h=z._$0o;this._$Jr(t,o,n,s,a,h);var l=vt._$92(a,h);o._$nb(t,n,s,s,1,0,2),i._$Wr._$fL=s[0],i._$Wr._$gL=s[1],i._$Wr._$B0=i._$Yr._$B0,i._$Wr._$z0=i._$Yr._$z0,i._$Wr._$qT=i._$Yr._$qT-l*vt._$NS;var $=n.getTotalScale();i.setTotalScale_notForClient($*i._$Wr._$B0);var u=n.getTotalOpacity();i.setTotalOpacity(u*i.getInterpolatedOpacity()),i._$Wr.reflectX=i._$Yr.reflectX,i._$Wr.reflectY=i._$Yr.reflectY,i._$hS(n._$yo())&#125;else i._$hS(!1)&#125;&#125;else i.setTotalScale_notForClient(i._$Yr._$B0),i.setTotalOpacity(i.getInterpolatedOpacity())&#125;,z.prototype._$nb=function(t,e,i,r,o,n,s)&#123;this!=e._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;);for(var _,a,h=e,l=null!=h._$Wr?h._$Wr:h._$Yr,$=Math.sin(vt._$bS*l._$qT),u=Math.cos(vt._$bS*l._$qT),p=h.getTotalScale(),c=l.reflectX?-1:1,f=l.reflectY?-1:1,g=u*p*c,y=-$*p*f,d=$*p*c,m=u*p*f,T=l._$fL,P=l._$gL,S=o*s,v=n;v&lt;S;v+=s)_=i[v],a=i[v+1],r[v]=g*_+y*a+T,r[v+1]=d*_+m*a+P&#125;,z.prototype._$Jr=function(t,e,i,r,o,n)&#123;e!=i._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;);var s=z._$Lo;z._$Lo[0]=r[0],z._$Lo[1]=r[1],e._$nb(t,i,s,s,1,0,2);for(var _=z._$To,a=z._$Po,h=1,l=0;l&lt;10;l++)&#123;if(a[0]=r[0]+h*o[0],a[1]=r[1]+h*o[1],e._$nb(t,i,a,_,1,0,2),_[0]-=s[0],_[1]-=s[1],0!=_[0]||0!=_[1])return n[0]=_[0],void(n[1]=_[1]);if(a[0]=r[0]-h*o[0],a[1]=r[1]-h*o[1],e._$nb(t,i,a,_,1,0,2),_[0]-=s[0],_[1]-=s[1],0!=_[0]||0!=_[1])return _[0]=-_[0],_[0]=-_[0],n[0]=_[0],void(n[1]=_[1]);h*=.1&#125;_t._$so&amp;&amp;console.log(&quot;_$L0 to transform _$SP\\n&quot;)&#125;,H.prototype=new st,W.prototype=new L,W._$ur=-2,W._$ES=500,W._$wb=2,W._$8S=3,W._$os=4,W._$52=W._$ES,W._$R2=W._$ES,W._$Sb=function(t)&#123;for(var e=t.length-1;e&gt;=0;--e)&#123;var i=t[e];i&lt;W._$52?W._$52=i:i&gt;W._$R2&amp;&amp;(W._$R2=i)&#125;&#125;,W._$or=function()&#123;return W._$52&#125;,W._$Pr=function()&#123;return W._$R2&#125;,W.prototype._$F0=function(t)&#123;this._$gP=t._$nP(),this._$dr=t._$nP(),this._$GS=t._$nP(),this._$qb=t._$6L(),this._$Lb=t._$cS(),this._$mS=t._$Tb(),t.getFormatVersion()&gt;=G._$T7?(this.clipID=t._$nP(),this.clipIDList=this.convertClipIDForV2_11(this.clipID)):this.clipIDList=null,W._$Sb(this._$Lb)&#125;,W.prototype.getClipIDList=function()&#123;return this.clipIDList&#125;,W.prototype._$Nr=function(t,e)&#123;if(e._$IS[0]=!1,e._$Us=S._$Z2(t,this._$GS,e._$IS,this._$Lb),_t._$Zs);else if(e._$IS[0])return;e._$7s=S._$br(t,this._$GS,e._$IS,this._$mS)&#125;,W.prototype._$2b=function(t)&#123;&#125;,W.prototype.getDrawDataID=function()&#123;return this._$gP&#125;,W.prototype._$j2=function(t)&#123;this._$gP=t&#125;,W.prototype.getOpacity=function(t,e)&#123;return e._$7s&#125;,W.prototype._$zS=function(t,e)&#123;return e._$Us&#125;,W.prototype.getTargetBaseDataID=function()&#123;return this._$dr&#125;,W.prototype._$gs=function(t)&#123;this._$dr=t&#125;,W.prototype._$32=function()&#123;return null!=this._$dr&amp;&amp;this._$dr!=yt._$2o()&#125;,W.prototype.getType=function()&#123;&#125;,j._$42=0,j.prototype._$1b=function()&#123;return this._$3S&#125;,j.prototype.getDrawDataList=function()&#123;return this._$aS&#125;,j.prototype._$F0=function(t)&#123;this._$NL=t._$nP(),this._$aS=t._$nP(),this._$3S=t._$nP()&#125;,j.prototype._$kr=function(t)&#123;t._$Zo(this._$3S),t._$xo(this._$aS),this._$3S=null,this._$aS=null&#125;,q.prototype=new r,q.loadModel=function(t)&#123;var e=new q;return r._$62(e,t),e&#125;,q.loadModel=function(t)&#123;var e=new q;return r._$62(e,t),e&#125;,q._$to=function()&#123;return new q&#125;,q._$er=function(t)&#123;var e=new _$5(&quot;../_$_r/_$t0/_$Ri/_$_P._$d&quot;);if(0==e.exists())throw new _$ls(&quot;_$t0 _$_ _$6 _$Ui :: &quot;+e._$PL());for(var i=[&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$CP._$1&quot;,&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$vP._$1&quot;,&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$EP._$1&quot;,&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$pP._$1&quot;],r=q.loadModel(e._$3b()),o=0;o&lt;i.length;o++)&#123;var n=new _$5(i[o]);if(0==n.exists())throw new _$ls(&quot;_$t0 _$_ _$6 _$Ui :: &quot;+n._$PL());r.setTexture(o,_$nL._$_o(t,n._$3b()))&#125;return r&#125;,q.prototype.setGL=function(t)&#123;this._$zo.setGL(t)&#125;,q.prototype.setTransform=function(t)&#123;this._$zo.setTransform(t)&#125;,q.prototype.draw=function()&#123;this._$5S.draw(this._$zo)&#125;,q.prototype._$K2=function()&#123;this._$zo._$K2()&#125;,q.prototype.setTexture=function(t,e)&#123;null==this._$zo&amp;&amp;_._$li(&quot;_$Yi for QT _$ki / _$XS() is _$6 _$ui!!&quot;),this._$zo.setTexture(t,e)&#125;,q.prototype.setTexture=function(t,e)&#123;null==this._$zo&amp;&amp;_._$li(&quot;_$Yi for QT _$ki / _$XS() is _$6 _$ui!!&quot;),this._$zo.setTexture(t,e)&#125;,q.prototype._$Rs=function()&#123;return this._$zo._$Rs()&#125;,q.prototype._$Ds=function(t)&#123;this._$zo._$Ds(t)&#125;,q.prototype.getDrawParam=function()&#123;return this._$zo&#125;,J.prototype=new s,J._$cs=&quot;VISIBLE:&quot;,J._$ar=&quot;LAYOUT:&quot;,J.MTN_PREFIX_FADEIN=&quot;FADEIN:&quot;,J.MTN_PREFIX_FADEOUT=&quot;FADEOUT:&quot;,J._$Co=0,J._$1T=1,J.loadMotion=function(t)&#123;var e=Y._$C(t);return J.loadMotion(e)&#125;,J.loadMotion=function(t)&#123;t instanceof ArrayBuffer&amp;&amp;(t=new DataView(t));var e=new J,i=[0],r=t.byteLength;e._$yT=0;for(var o=0;o&lt;r;++o)&#123;var n=Q(t,o),s=n.charCodeAt(0);if(&quot;\\n&quot;!=n&amp;&amp;&quot;\\r&quot;!=n)if(&quot;#&quot;!=n)if(&quot;$&quot;!=n)&#123;if(97&lt;=s&amp;&amp;s&lt;=122||65&lt;=s&amp;&amp;s&lt;=90||&quot;_&quot;==n)&#123;for($=o,u=-1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=Q(t,o))&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;=&quot;==n)&#123;u=o;break&#125;if(u&gt;=0)&#123;var _=new N;w.startsWith(t,$,J._$cs)?(_._$RP=N._$hs,_._$4P=w.createString(t,$,u-$)):w.startsWith(t,$,J._$ar)?(_._$4P=w.createString(t,$+7,u-$-7),w.startsWith(t,$+7,&quot;ANCHOR_X&quot;)?_._$RP=N._$xs:w.startsWith(t,$+7,&quot;ANCHOR_Y&quot;)?_._$RP=N._$us:w.startsWith(t,$+7,&quot;SCALE_X&quot;)?_._$RP=N._$qs:w.startsWith(t,$+7,&quot;SCALE_Y&quot;)?_._$RP=N._$Ys:w.startsWith(t,$+7,&quot;X&quot;)?_._$RP=N._$ws:w.startsWith(t,$+7,&quot;Y&quot;)&amp;&amp;(_._$RP=N._$Ns)):(_._$RP=N._$Fr,_._$4P=w.createString(t,$,u-$)),e.motions.push(_);var a=0,h=[];for(o=u+1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=Q(t,o))&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;,&quot;!=n&amp;&amp;&quot; &quot;!=n&amp;&amp;&quot;\\t&quot;!=n)&#123;c=w._$LS(t,r,o,i);if(i[0]&gt;0)&#123;h.push(c),a++;var l=i[0];if(l&lt;o)&#123;console.log(&quot;_$n0 _$hi . @Live2DMotion loadMotion()\\n&quot;);break&#125;o=l-1&#125;&#125;_._$I0=new Float32Array(h),a&gt;e._$yT&amp;&amp;(e._$yT=a)&#125;&#125;&#125;else&#123;for(var $=o,u=-1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=Q(t,o))&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;=&quot;==n)&#123;u=o;break&#125;var p=!1;if(u&gt;=0)for(u==$+4&amp;&amp;&quot;f&quot;==Q(t,$+1)&amp;&amp;&quot;p&quot;==Q(t,$+2)&amp;&amp;&quot;s&quot;==Q(t,$+3)&amp;&amp;(p=!0),o=u+1;o&lt;r&amp;&amp;(&quot;\\r&quot;!=(n=Q(t,o))&amp;&amp;&quot;\\n&quot;!=n);++o)if(&quot;,&quot;!=n&amp;&amp;&quot; &quot;!=n&amp;&amp;&quot;\\t&quot;!=n)&#123;var c=w._$LS(t,r,o,i);i[0]&gt;0&amp;&amp;p&amp;&amp;5&lt;c&amp;&amp;c&lt;121&amp;&amp;(e._$D0=c),o=i[0]&#125;for(;o&lt;r&amp;&amp;(&quot;\\n&quot;!=Q(t,o)&amp;&amp;&quot;\\r&quot;!=Q(t,o));++o);&#125;else for(;o&lt;r&amp;&amp;(&quot;\\n&quot;!=Q(t,o)&amp;&amp;&quot;\\r&quot;!=Q(t,o));++o);&#125;return e._$rr=1e3*e._$yT/e._$D0|0,e&#125;,J.prototype.getDurationMSec=function()&#123;return this._$E?-1:this._$rr&#125;,J.prototype.getLoopDurationMSec=function()&#123;return this._$rr&#125;,J.prototype.dump=function()&#123;for(var t=0;t&lt;this.motions.length;t++)&#123;var e=this.motions[t];console.log(&quot;_$wL[%s] [%d]. &quot;,e._$4P,e._$I0.length);for(var i=0;i&lt;e._$I0.length&amp;&amp;i&lt;10;i++)console.log(&quot;%5.2f ,&quot;,e._$I0[i]);console.log(&quot;\\n&quot;)&#125;&#125;,J.prototype.updateParamExe=function(t,e,i,r)&#123;for(var o=(e-r._$z2)*this._$D0/1e3,n=0|o,s=o-n,_=0;_&lt;this.motions.length;_++)&#123;var a=this.motions[_],h=a._$I0.length,l=a._$4P;if(a._$RP==N._$hs)&#123;var $=a._$I0[n&gt;=h?h-1:n];t.setParamFloat(l,$)&#125;else if(N._$ws&lt;=a._$RP&amp;&amp;a._$RP&lt;=N._$Ys);else&#123;var u=t.getParamIndex(l),p=t.getModelContext(),c=.4*(p.getParamMax(u)-p.getParamMin(u)),f=p.getParamFloat(u),g=a._$I0[n&gt;=h?h-1:n],y=a._$I0[n+1&gt;=h?h-1:n+1],d=f+((g&lt;y&amp;&amp;y-g&gt;c||g&gt;y&amp;&amp;g-y&gt;c?g:g+(y-g)*s)-f)*i;t.setParamFloat(l,d)&#125;&#125;n&gt;=this._$yT&amp;&amp;(this._$E?(r._$z2=e,this.loopFadeIn&amp;&amp;(r._$bs=e)):r._$9L=!0),this._$eP=i&#125;,J.prototype._$r0=function()&#123;return this._$E&#125;,J.prototype._$aL=function(t)&#123;this._$E=t&#125;,J.prototype._$S0=function()&#123;return this._$D0&#125;,J.prototype._$U0=function(t)&#123;this._$D0=t&#125;,J.prototype.isLoopFadeIn=function()&#123;return this.loopFadeIn&#125;,J.prototype.setLoopFadeIn=function(t)&#123;this.loopFadeIn=t&#125;,C.prototype.clear=function()&#123;this.size=0&#125;,C.prototype.add=function(t)&#123;if(this._$P.length&lt;=this.size)&#123;var e=new Float32Array(2*this.size);x._$jT(this._$P,0,e,0,this.size),this._$P=e&#125;this._$P[this.size++]=t&#125;,C.prototype._$BL=function()&#123;var t=new Float32Array(this.size);return x._$jT(this._$P,0,t,0,this.size),t&#125;,N._$Fr=0,N._$hs=1,N._$ws=100,N._$Ns=101,N._$xs=102,N._$us=103,N._$qs=104,N._$Ys=105,Z.prototype=new A,Z._$gT=new Array,Z.prototype._$zP=function()&#123;this._$GS=new D,this._$GS._$zP()&#125;,Z.prototype._$F0=function(t)&#123;A.prototype._$F0.call(this,t),this._$A=t._$6L(),this._$o=t._$6L(),this._$GS=t._$nP(),this._$Eo=t._$nP(),A.prototype.readV2_opacity.call(this,t)&#125;,Z.prototype.init=function(t)&#123;var e=new K(this),i=(this._$o+1)*(this._$A+1);return null!=e._$Cr&amp;&amp;(e._$Cr=null),e._$Cr=new Float32Array(2*i),null!=e._$hr&amp;&amp;(e._$hr=null),this._$32()?e._$hr=new Float32Array(2*i):e._$hr=null,e&#125;,Z.prototype._$Nr=function(t,e)&#123;var i=e;if(this._$GS._$Ur(t))&#123;var r=this._$VT(),o=Z._$gT;o[0]=!1,S._$Vr(t,this._$GS,o,r,this._$Eo,i._$Cr,0,2),e._$Ib(o[0]),this.interpolateOpacity(t,this._$GS,e,o)&#125;&#125;,Z.prototype._$2b=function(t,e)&#123;var i=e;if(i._$hS(!0),this._$32())&#123;var r=this.getTargetBaseDataID();if(i._$8r==A._$ur&amp;&amp;(i._$8r=t.getBaseDataIndex(r)),i._$8r&lt;0)_t._$so&amp;&amp;_._$li(&quot;_$L _$0P _$G :: %s&quot;,r),i._$hS(!1);else&#123;var o=t.getBaseData(i._$8r),n=t._$q2(i._$8r);if(null!=o&amp;&amp;n._$yo())&#123;var s=n.getTotalScale();i.setTotalScale_notForClient(s);var a=n.getTotalOpacity();i.setTotalOpacity(a*i.getInterpolatedOpacity()),o._$nb(t,n,i._$Cr,i._$hr,this._$VT(),0,2),i._$hS(!0)&#125;else i._$hS(!1)&#125;&#125;else i.setTotalOpacity(i.getInterpolatedOpacity())&#125;,Z.prototype._$nb=function(t,e,i,r,o,n,s)&#123;var _=e,a=null!=_._$hr?_._$hr:_._$Cr;Z.transformPoints_sdk2(i,r,o,n,s,a,this._$o,this._$A)&#125;,Z.transformPoints_sdk2=function(e,i,r,o,n,s,_,a)&#123;for(var h,l,$,u=r*n,p=0,c=0,f=0,g=0,y=0,d=0,m=!1,T=o;T&lt;u;T+=n)&#123;var P,S,v,L;if(v=e[T],S=(L=e[T+1])*a,(P=v*_)&lt;0||S&lt;0||_&lt;=P||a&lt;=S)&#123;var M=_+1;if(!m)&#123;m=!0,p=.25*(s[2*(0+0*M)]+s[2*(_+0*M)]+s[2*(0+a*M)]+s[2*(_+a*M)]),c=.25*(s[2*(0+0*M)+1]+s[2*(_+0*M)+1]+s[2*(0+a*M)+1]+s[2*(_+a*M)+1]);var E=s[2*(_+a*M)]-s[2*(0+0*M)],A=s[2*(_+a*M)+1]-s[2*(0+0*M)+1],x=s[2*(_+0*M)]-s[2*(0+a*M)],I=s[2*(_+0*M)+1]-s[2*(0+a*M)+1];p-=.5*((f=.5*(E+x))+(y=.5*(E-x))),c-=.5*((g=.5*(A+I))+(d=.5*(A-I)))&#125;if(-2&lt;v&amp;&amp;v&lt;3&amp;&amp;-2&lt;L&amp;&amp;L&lt;3)if(v&lt;=0)if(L&lt;=0)&#123;var w=s[2*(0+0*M)],D=s[2*(0+0*M)+1],O=p-2*f,R=c-2*g,b=p-2*y,F=c-2*d,C=p-2*f-2*y,N=c-2*g-2*d;(B=.5*(v- -2))+(G=.5*(L- -2))&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else if(L&gt;=1)&#123;b=s[2*(0+a*M)],F=s[2*(0+a*M)+1],C=p-2*f+1*y,N=c-2*g+1*d,w=p+3*y,D=c+3*d,O=p-2*f+3*y,R=c-2*g+3*d;(B=.5*(v- -2))+(G=.5*(L-1))&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else&#123;(k=0|S)==a&amp;&amp;(k=a-1);var B=.5*(v- -2),G=S-k,U=k/a,Y=(k+1)/a;b=s[2*(0+k*M)],F=s[2*(0+k*M)+1],w=s[2*(0+(k+1)*M)],D=s[2*(0+(k+1)*M)+1],C=p-2*f+U*y,N=c-2*g+U*d,O=p-2*f+Y*y,R=c-2*g+Y*d;B+G&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else if(1&lt;=v)if(L&lt;=0)&#123;O=s[2*(_+0*M)],R=s[2*(_+0*M)+1],w=p+3*f,D=c+3*g,C=p+1*f-2*y,N=c+1*g-2*d,b=p+3*f-2*y,F=c+3*g-2*d;(B=.5*(v-1))+(G=.5*(L- -2))&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else if(L&gt;=1)&#123;C=s[2*(_+a*M)],N=s[2*(_+a*M)+1],b=p+3*f+1*y,F=c+3*g+1*d,O=p+1*f+3*y,R=c+1*g+3*d,w=p+3*f+3*y,D=c+3*g+3*d;(B=.5*(v-1))+(G=.5*(L-1))&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else&#123;var k;(k=0|S)==a&amp;&amp;(k=a-1);B=.5*(v-1),G=S-k,U=k/a,Y=(k+1)/a,C=s[2*(_+k*M)],N=s[2*(_+k*M)+1],O=s[2*(_+(k+1)*M)],R=s[2*(_+(k+1)*M)+1],b=p+3*f+U*y,F=c+3*g+U*d,w=p+3*f+Y*y,D=c+3*g+Y*d;B+G&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else if(L&lt;=0)&#123;(z=0|P)==_&amp;&amp;(z=_-1);B=P-z,G=.5*(L- -2);var V=z/_,X=(z+1)/_;O=s[2*(z+0*M)],R=s[2*(z+0*M)+1],w=s[2*(z+1+0*M)],D=s[2*(z+1+0*M)+1],C=p+V*f-2*y,N=c+V*g-2*d,b=p+X*f-2*y,F=c+X*g-2*d;B+G&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else if(L&gt;=1)&#123;var z;(z=0|P)==_&amp;&amp;(z=_-1);B=P-z,G=.5*(L-1),V=z/_,X=(z+1)/_,C=s[2*(z+a*M)],N=s[2*(z+a*M)+1],b=s[2*(z+1+a*M)],F=s[2*(z+1+a*M)+1],O=p+V*f+3*y,R=c+V*g+3*d,w=p+X*f+3*y,D=c+X*g+3*d;B+G&lt;=1?(i[T]=C+(b-C)*B+(O-C)*G,i[T+1]=N+(F-N)*B+(R-N)*G):(i[T]=w+(O-w)*(1-B)+(b-w)*(1-G),i[T+1]=D+(R-D)*(1-B)+(F-D)*(1-G))&#125;else t.err.printf(&quot;_$li calc : %.4f , %.4f          @@BDBoxGrid\\n&quot;,v,L);else i[T]=p+v*f+L*y,i[T+1]=c+v*g+L*d&#125;else h=2*((0|P)+(0|S)*(_+1)),(l=P-(0|P))+($=S-(0|S))&lt;1?(i[T]=s[h]*(1-l-$)+s[h+2]*l+s[h+2*(_+1)]*$,i[T+1]=s[h+1]*(1-l-$)+s[h+3]*l+s[h+2*(_+1)+1]*$):(i[T]=s[h+2*(_+1)+2]*(l-1+$)+s[h+2*(_+1)]*(1-l)+s[h+2]*(1-$),i[T+1]=s[h+2*(_+1)+3]*(l-1+$)+s[h+2*(_+1)+1]*(1-l)+s[h+3]*(1-$))&#125;&#125;,Z.prototype.transformPoints_sdk1=function(t,e,i,r,o,n,s)&#123;for(var _,a,h,l,$,u,p,c=e,f=this._$o,g=this._$A,y=o*s,d=null!=c._$hr?c._$hr:c._$Cr,m=n;m&lt;y;m+=s)_t._$ts?(_=i[m],a=i[m+1],_&lt;0?_=0:_&gt;1&amp;&amp;(_=1),a&lt;0?a=0:a&gt;1&amp;&amp;(a=1),l=0|(a*=g),(h=0|(_*=f))&gt;f-1&amp;&amp;(h=f-1),l&gt;g-1&amp;&amp;(l=g-1),u=_-h,p=a-l,$=2*(h+l*(f+1))):(u=(_=i[m]*f)-(0|_),p=(a=i[m+1]*g)-(0|a),$=2*((0|_)+(0|a)*(f+1))),u+p&lt;1?(r[m]=d[$]*(1-u-p)+d[$+2]*u+d[$+2*(f+1)]*p,r[m+1]=d[$+1]*(1-u-p)+d[$+3]*u+d[$+2*(f+1)+1]*p):(r[m]=d[$+2*(f+1)+2]*(u-1+p)+d[$+2*(f+1)]*(1-u)+d[$+2]*(1-p),r[m+1]=d[$+2*(f+1)+3]*(u-1+p)+d[$+2*(f+1)+1]*(1-u)+d[$+3]*(1-p))&#125;,Z.prototype._$VT=function()&#123;return(this._$o+1)*(this._$A+1)&#125;,Z.prototype.getType=function()&#123;return A._$_b&#125;,K.prototype=new st,tt._$42=0,tt.prototype._$zP=function()&#123;this._$3S=new Array,this._$aS=new Array&#125;,tt.prototype._$F0=function(t)&#123;this._$g0=t._$8L(),this.visible=t._$8L(),this._$NL=t._$nP(),this._$3S=t._$nP(),this._$aS=t._$nP()&#125;,tt.prototype.init=function(t)&#123;var e=new et(this);return e.setPartsOpacity(this.isVisible()?1:0),e&#125;,tt.prototype._$6o=function(t)&#123;if(null==this._$3S)throw new Error(&quot;_$3S _$6 _$Wo@_$6o&quot;);this._$3S.push(t)&#125;,tt.prototype._$3o=function(t)&#123;if(null==this._$aS)throw new Error(&quot;_$aS _$6 _$Wo@_$3o&quot;);this._$aS.push(t)&#125;,tt.prototype._$Zo=function(t)&#123;this._$3S=t&#125;,tt.prototype._$xo=function(t)&#123;this._$aS=t&#125;,tt.prototype.isVisible=function()&#123;return this.visible&#125;,tt.prototype._$uL=function()&#123;return this._$g0&#125;,tt.prototype._$KP=function(t)&#123;this.visible=t&#125;,tt.prototype._$ET=function(t)&#123;this._$g0=t&#125;,tt.prototype.getBaseData=function()&#123;return this._$3S&#125;,tt.prototype.getDrawData=function()&#123;return this._$aS&#125;,tt.prototype._$p2=function()&#123;return this._$NL&#125;,tt.prototype._$ob=function(t)&#123;this._$NL=t&#125;,tt.prototype.getPartsID=function()&#123;return this._$NL&#125;,tt.prototype._$MP=function(t)&#123;this._$NL=t&#125;,et.prototype=new function()&#123;&#125;,et.prototype.getPartsOpacity=function()&#123;return this._$VS&#125;,et.prototype.setPartsOpacity=function(t)&#123;this._$VS=t&#125;,it._$L7=function()&#123;l._$27(),yt._$27(),R._$27(),h._$27()&#125;,it.prototype.toString=function()&#123;return this.id&#125;,rt.prototype._$1s=function()&#123;return this._$4S&#125;,rt.prototype._$zP=function()&#123;this._$4S=new Array&#125;,rt.prototype._$F0=function(t)&#123;this._$4S=t._$nP()&#125;,rt.prototype._$Ks=function(t)&#123;this._$4S.push(t)&#125;,ot.tr=new gt,ot._$50=new gt,ot._$Ti=new Array(0,0),ot._$Pi=new Array(0,0),ot._$B=new Array(0,0),ot.prototype._$lP=function(t,e,i,r)&#123;this.viewport=new Array(t,e,i,r)&#125;,ot.prototype._$bL=function()&#123;this.context.save();var t=this.viewport;null!=t&amp;&amp;(this.context.beginPath(),this.context._$Li(t[0],t[1],t[2],t[3]),this.context.clip())&#125;,ot.prototype._$ei=function()&#123;this.context.restore()&#125;,ot.prototype.drawElements=function(t,e,i,r,o,n,s,a)&#123;try&#123;o!=this._$Qo&amp;&amp;(this._$Qo=o,this.context.globalAlpha=o);for(var h=e.length,l=t.width,$=t.height,u=this.context,p=this._$xP,c=this._$uP,f=this._$6r,g=this._$3r,y=ot.tr,d=ot._$Ti,m=ot._$Pi,P=ot._$B,S=0;S&lt;h;S+=3)&#123;u.save();var v=e[S],L=e[S+1],M=e[S+2],E=p+f*i[2*v],A=c+g*i[2*v+1],x=p+f*i[2*L],I=c+g*i[2*L+1],w=p+f*i[2*M],D=c+g*i[2*M+1];s&amp;&amp;(s._$PS(E,A,P),E=P[0],A=P[1],s._$PS(x,I,P),x=P[0],I=P[1],s._$PS(w,D,P),w=P[0],D=P[1]);var O=l*r[2*v],R=$-$*r[2*v+1],b=l*r[2*L],F=$-$*r[2*L+1],C=l*r[2*M],N=$-$*r[2*M+1],B=Math.atan2(F-R,b-O),G=Math.atan2(I-A,x-E),U=x-E,Y=I-A,k=Math.sqrt(U*U+Y*Y),V=b-O,X=F-R,z=k/Math.sqrt(V*V+X*X);T._$ni(C,N,O,R,b-O,F-R,-(F-R),b-O,d),T._$ni(w,D,E,A,x-E,I-A,-(I-A),x-E,m);var H=(m[0]-d[0])/d[1],W=Math.min(O,b,C),j=Math.max(O,b,C),q=Math.min(R,F,N),J=Math.max(R,F,N),Q=Math.floor(W),Z=Math.floor(q),K=Math.ceil(j),tt=Math.ceil(J);y.identity(),y.translate(E,A),y.rotate(G),y.scale(1,m[1]/d[1]),y.shear(H,0),y.scale(z,z),y.rotate(-B),y.translate(-O,-R),y.setContext(u);if(n||(n=1.2),_t.IGNORE_EXPAND&amp;&amp;(n=0),_t.USE_CACHED_POLYGON_IMAGE)&#123;var et=a._$e0;if(et.gl_cacheImage=et.gl_cacheImage||&#123;&#125;,!et.gl_cacheImage[S])&#123;var it=ot.createCanvas(K-Q,tt-Z);_t.DEBUG_DATA.LDGL_CANVAS_MB=_t.DEBUG_DATA.LDGL_CANVAS_MB||0,_t.DEBUG_DATA.LDGL_CANVAS_MB+=(K-Q)*(tt-Z)*4;var rt=it.getContext(&quot;2d&quot;);rt.translate(-Q,-Z),ot.clip(rt,y,n,k,O,R,b,F,C,N,E,A,x,I,w,D),rt.drawImage(t,0,0),et.gl_cacheImage[S]=&#123;cacheCanvas:it,cacheContext:rt&#125;&#125;u.drawImage(et.gl_cacheImage[S].cacheCanvas,Q,Z)&#125;else _t.IGNORE_CLIP||ot.clip(u,y,n,k,O,R,b,F,C,N,E,A,x,I,w,D),_t.USE_ADJUST_TRANSLATION&amp;&amp;(W=0,j=l,q=0,J=$),u.drawImage(t,W,q,j-W,J-q,W,q,j-W,J-q);u.restore()&#125;&#125;catch(t)&#123;_._$Rb(t)&#125;&#125;,ot.clip=function(t,e,i,r,o,n,s,_,a,h,l,$,u,p,c,f)&#123;i&gt;.02?ot.expandClip(t,e,i,r,l,$,u,p,c,f):ot.clipWithTransform(t,null,o,n,s,_,a,h)&#125;,ot.expandClip=function(t,e,i,r,o,n,s,_,a,h)&#123;var l=s-o,$=_-n,u=a-o,p=h-n,c=l*p-$*u&gt;0?i:-i,f=-$,g=l,y=a-s,d=h-_,m=-d,T=y,P=Math.sqrt(y*y+d*d),S=-p,v=u,L=Math.sqrt(u*u+p*p),M=o-c*f/r,E=n-c*g/r,A=s-c*f/r,x=_-c*g/r,I=s-c*m/P,w=_-c*T/P,D=a-c*m/P,O=h-c*T/P,R=o+c*S/L,b=n+c*v/L,F=a+c*S/L,C=h+c*v/L,N=ot._$50;return null!=e._$P2(N)&amp;&amp;(ot.clipWithTransform(t,N,M,E,A,x,I,w,D,O,F,C,R,b),!0)&#125;,ot.clipWithTransform=function(t,e,i,r,o,n,s,a)&#123;if(arguments.length&lt;7)_._$li(&quot;err : @LDGL.clip()&quot;);else if(arguments[1]instanceof gt)&#123;var h=ot._$B,l=e,$=arguments;if(t.beginPath(),l)&#123;l._$PS($[2],$[3],h),t.moveTo(h[0],h[1]);for(var u=4;u&lt;$.length;u+=2)l._$PS($[u],$[u+1],h),t.lineTo(h[0],h[1])&#125;else&#123;t.moveTo($[2],$[3]);for(u=4;u&lt;$.length;u+=2)t.lineTo($[u],$[u+1])&#125;t.clip()&#125;else _._$li(&quot;err : a[0] is _$6 LDTransform @LDGL.clip()&quot;)&#125;,ot.createCanvas=function(t,e)&#123;var i=document.createElement(&quot;canvas&quot;);return i.setAttribute(&quot;width&quot;,t),i.setAttribute(&quot;height&quot;,e),i||_._$li(&quot;err : &quot;+i),i&#125;,ot.dumpValues=function()&#123;for(var t=&quot;&quot;,e=0;e&lt;arguments.length;e++)t+=&quot;[&quot;+e+&quot;]= &quot;+arguments[e].toFixed(3)+&quot; , &quot;;console.log(t)&#125;,nt.prototype._$F0=function(t)&#123;this._$TT=t._$_T(),this._$LT=t._$_T(),this._$FS=t._$_T(),this._$wL=t._$nP()&#125;,nt.prototype.getMinValue=function()&#123;return this._$TT&#125;,nt.prototype.getMaxValue=function()&#123;return this._$LT&#125;,nt.prototype.getDefaultValue=function()&#123;return this._$FS&#125;,nt.prototype.getParamID=function()&#123;return this._$wL&#125;,st.prototype._$yo=function()&#123;return this._$AT&amp;&amp;!this._$JS&#125;,st.prototype._$hS=function(t)&#123;this._$AT=t&#125;,st.prototype._$GT=function()&#123;return this._$e0&#125;,st.prototype._$l2=function(t)&#123;this._$IP=t&#125;,st.prototype.getPartsIndex=function()&#123;return this._$IP&#125;,st.prototype._$x2=function()&#123;return this._$JS&#125;,st.prototype._$Ib=function(t)&#123;this._$JS=t&#125;,st.prototype.getTotalScale=function()&#123;return this.totalScale&#125;,st.prototype.setTotalScale_notForClient=function(t)&#123;this.totalScale=t&#125;,st.prototype.getInterpolatedOpacity=function()&#123;return this._$7s&#125;,st.prototype.setInterpolatedOpacity=function(t)&#123;this._$7s=t&#125;,st.prototype.getTotalOpacity=function(t)&#123;return this.totalOpacity&#125;,st.prototype.setTotalOpacity=function(t)&#123;this.totalOpacity=t&#125;,_t._$2s=&quot;2.1.00_1&quot;,_t._$Kr=201001e3,_t._$sP=!0,_t._$so=!0,_t._$cb=!1,_t._$3T=!0,_t._$Ts=!0,_t._$fb=!0,_t._$ts=!0,_t.L2D_DEFORMER_EXTEND=!0,_t._$Wb=!1,_t._$yr=!1,_t._$Zs=!1,_t.L2D_NO_ERROR=0,_t._$i7=1e3,_t._$9s=1001,_t._$es=1100,_t._$r7=2e3,_t._$07=2001,_t._$b7=2002,_t._$H7=4e3,_t.L2D_COLOR_BLEND_MODE_MULT=0,_t.L2D_COLOR_BLEND_MODE_ADD=1,_t.L2D_COLOR_BLEND_MODE_INTERPOLATE=2,_t._$6b=!0,_t._$cT=0,_t.clippingMaskBufferSize=256,_t.glContext=new Array,_t.frameBuffers=new Array,_t.fTexture=new Array,_t.IGNORE_CLIP=!1,_t.IGNORE_EXPAND=!1,_t.EXPAND_W=2,_t.USE_ADJUST_TRANSLATION=!0,_t.USE_CANVAS_TRANSFORM=!0,_t.USE_CACHED_POLYGON_IMAGE=!1,_t.DEBUG_DATA=&#123;&#125;,_t.PROFILE_IOS_SPEED=&#123;PROFILE_NAME:&quot;iOS Speed&quot;,USE_ADJUST_TRANSLATION:!0,USE_CACHED_POLYGON_IMAGE:!0,EXPAND_W:4&#125;,_t.PROFILE_IOS_QUALITY=&#123;PROFILE_NAME:&quot;iOS HiQ&quot;,USE_ADJUST_TRANSLATION:!0,USE_CACHED_POLYGON_IMAGE:!1,EXPAND_W:2&#125;,_t.PROFILE_IOS_DEFAULT=_t.PROFILE_IOS_QUALITY,_t.PROFILE_ANDROID=&#123;PROFILE_NAME:&quot;Android&quot;,USE_ADJUST_TRANSLATION:!1,USE_CACHED_POLYGON_IMAGE:!1,EXPAND_W:2&#125;,_t.PROFILE_DESKTOP=&#123;PROFILE_NAME:&quot;Desktop&quot;,USE_ADJUST_TRANSLATION:!1,USE_CACHED_POLYGON_IMAGE:!1,EXPAND_W:2&#125;,_t.initProfile=function()&#123;Mt.isIOS()?_t.setupProfile(_t.PROFILE_IOS_DEFAULT):Mt.isAndroid()?_t.setupProfile(_t.PROFILE_ANDROID):_t.setupProfile(_t.PROFILE_DESKTOP)&#125;,_t.setupProfile=function(t,e)&#123;if(&quot;number&quot;==typeof t)switch(t)&#123;case 9901:t=_t.PROFILE_IOS_SPEED;break;case 9902:t=_t.PROFILE_IOS_QUALITY;break;case 9903:t=_t.PROFILE_IOS_DEFAULT;break;case 9904:t=_t.PROFILE_ANDROID;break;case 9905:t=_t.PROFILE_DESKTOP;break;default:alert(&quot;profile _$6 _$Ui : &quot;+t)&#125;for(var i in arguments.length&lt;2&amp;&amp;(e=!0),e&amp;&amp;console.log(&quot;profile : &quot;+t.PROFILE_NAME),t)_t[i]=t[i],e&amp;&amp;console.log(&quot;  [&quot;+i+&quot;] = &quot;+t[i])&#125;,_t.init=function()&#123;if(_t._$6b)&#123;console.log(&quot;Live2D %s&quot;,_t._$2s),_t._$6b=!1;!0,_t.initProfile()&#125;&#125;,_t.getVersionStr=function()&#123;return _t._$2s&#125;,_t.getVersionNo=function()&#123;return _t._$Kr&#125;,_t._$sT=function(t)&#123;_t._$cT=t&#125;,_t.getError=function()&#123;var t=_t._$cT;return _t._$cT=0,t&#125;,_t.dispose=function()&#123;_t.glContext=[],_t.frameBuffers=[],_t.fTexture=[]&#125;,_t.setGL=function(t,e)&#123;var i=e||0;_t.glContext[i]=t&#125;,_t.getGL=function(t)&#123;return _t.glContext[t]&#125;,_t.setClippingMaskBufferSize=function(t)&#123;_t.clippingMaskBufferSize=t&#125;,_t.getClippingMaskBufferSize=function()&#123;return _t.clippingMaskBufferSize&#125;,_t.deleteBuffer=function(t)&#123;_t.getGL(t).deleteFramebuffer(_t.frameBuffers[t].framebuffer),delete _t.frameBuffers[t],delete _t.glContext[t]&#125;,at._$r2=function(t)&#123;return t&lt;0?0:t&gt;1?1:.5-.5*Math.cos(t*vt.PI_F)&#125;,ht._$fr=-1,ht.prototype.toString=function()&#123;return this._$ib&#125;,lt.prototype=new W,lt._$42=0,lt._$Os=30,lt._$ms=0,lt._$ns=1,lt._$_s=2,lt._$gT=new Array,lt.prototype._$_S=function(t)&#123;this._$LP=t&#125;,lt.prototype.getTextureNo=function()&#123;return this._$LP&#125;,lt.prototype._$ZL=function()&#123;return this._$Qi&#125;,lt.prototype._$H2=function()&#123;return this._$JP&#125;,lt.prototype.getNumPoints=function()&#123;return this._$d0&#125;,lt.prototype.getType=function()&#123;return W._$wb&#125;,lt.prototype._$B2=function(t,e,i)&#123;var r=e,o=null!=r._$hr?r._$hr:r._$Cr;switch(B._$do)&#123;default:case B._$Ms:throw new Error(&quot;_$L _$ro &quot;);case B._$Qs:for(var n=this._$d0-1;n&gt;=0;--n)&#123;o[n*B._$No+4]=i&#125;&#125;&#125;,lt.prototype._$zP=function()&#123;this._$GS=new D,this._$GS._$zP()&#125;,lt.prototype._$F0=function(t)&#123;W.prototype._$F0.call(this,t),this._$LP=t._$6L(),this._$d0=t._$6L(),this._$Yo=t._$6L();var e=t._$nP();this._$BP=new Int16Array(3*this._$Yo);for(var i=3*this._$Yo-1;i&gt;=0;--i)this._$BP[i]=e[i];if(this._$Eo=t._$nP(),this._$Qi=t._$nP(),t.getFormatVersion()&gt;=G._$s7)&#123;if(this._$JP=t._$6L(),0!=this._$JP)&#123;if(0!=(1&amp;this._$JP))&#123;var r=t._$6L();null==this._$5P&amp;&amp;(this._$5P=new Object),this._$5P._$Hb=parseInt(r)&#125;0!=(this._$JP&amp;lt._$Os)?this._$6s=(this._$JP&amp;lt._$Os)&gt;&gt;1:this._$6s=lt._$ms,0!=(32&amp;this._$JP)&amp;&amp;(this.culling=!1)&#125;&#125;else this._$JP=0&#125;,lt.prototype.init=function(t)&#123;var e=new $t(this),i=this._$d0*B._$No,r=this._$32();switch(null!=e._$Cr&amp;&amp;(e._$Cr=null),e._$Cr=new Float32Array(i),null!=e._$hr&amp;&amp;(e._$hr=null),e._$hr=r?new Float32Array(i):null,B._$do)&#123;default:case B._$Ms:if(B._$Ls)for(var o=this._$d0-1;o&gt;=0;--o)&#123;var n=o&lt;&lt;1;this._$Qi[n+1]=1-this._$Qi[n+1]&#125;break;case B._$Qs:for(o=this._$d0-1;o&gt;=0;--o)&#123;n=o&lt;&lt;1;var s=o*B._$No,_=this._$Qi[n],a=this._$Qi[n+1];e._$Cr[s]=_,e._$Cr[s+1]=a,e._$Cr[s+4]=0,r&amp;&amp;(e._$hr[s]=_,e._$hr[s+1]=a,e._$hr[s+4]=0)&#125;&#125;return e&#125;,lt.prototype._$Nr=function(t,e)&#123;var i=e;if(this!=i._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;),this._$GS._$Ur(t)&amp;&amp;(W.prototype._$Nr.call(this,t,i),!i._$IS[0]))&#123;var r=lt._$gT;r[0]=!1,S._$Vr(t,this._$GS,r,this._$d0,this._$Eo,i._$Cr,B._$i2,B._$No)&#125;&#125;,lt.prototype._$2b=function(t,e)&#123;try&#123;this!=e._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;);var i=!1;e._$IS[0]&amp;&amp;(i=!0);var r=e;if(!i&amp;&amp;(W.prototype._$2b.call(this,t),this._$32()))&#123;var o=this.getTargetBaseDataID();if(r._$8r==W._$ur&amp;&amp;(r._$8r=t.getBaseDataIndex(o)),r._$8r&lt;0)_t._$so&amp;&amp;_._$li(&quot;_$L _$0P _$G :: %s&quot;,o);else&#123;var n=t.getBaseData(r._$8r),s=t._$q2(r._$8r);null==n||s._$x2()?r._$AT=!1:(n._$nb(t,s,r._$Cr,r._$hr,this._$d0,B._$i2,B._$No),r._$AT=!0),r.baseOpacity=s.getTotalOpacity()&#125;&#125;&#125;catch(t)&#123;throw t&#125;&#125;,lt.prototype.draw=function(t,e,i)&#123;if(this!=i._$GT()&amp;&amp;console.log(&quot;### assert!! ### &quot;),!i._$IS[0])&#123;var r=i,o=this._$LP;o&lt;0&amp;&amp;(o=1);var n=this.getOpacity(e,r)*i._$VS*i.baseOpacity,s=null!=r._$hr?r._$hr:r._$Cr;t.setClipBufPre_clipContextForDraw(i.clipBufPre_clipContext),t._$WP(this.culling),t._$Uo(o,3*this._$Yo,this._$BP,s,this._$Qi,n,this._$6s,r)&#125;&#125;,lt.prototype.dump=function()&#123;console.log(&quot;  _$yi( %d ) , _$d0( %d ) , _$Yo( %d ) \\n&quot;,this._$LP,this._$d0,this._$Yo),console.log(&quot;  _$Oi _$di = &#123; &quot;);for(var t=0;t&lt;this._$BP.length;t++)console.log(&quot;%5d ,&quot;,this._$BP[t]);console.log(&quot;\\n  _$5i _$30&quot;);for(t=0;t&lt;this._$Eo.length;t++)&#123;console.log(&quot;\\n    _$30[%d] = &quot;,t);for(var e=this._$Eo[t],i=0;i&lt;e.length;i++)console.log(&quot;%6.2f, &quot;,e[i])&#125;console.log(&quot;\\n&quot;)&#125;,lt.prototype._$72=function(t)&#123;return null==this._$5P?null:this._$5P[t]&#125;,lt.prototype.getIndexArray=function()&#123;return this._$BP&#125;,$t.prototype=new Lt,$t.prototype.getTransformedPoints=function()&#123;return null!=this._$hr?this._$hr:this._$Cr&#125;,ut.prototype._$HT=function(t)&#123;this.x=t.x,this.y=t.y&#125;,ut.prototype._$HT=function(t,e)&#123;this.x=t,this.y=e&#125;,pt.prototype=new r,pt.loadModel=function(t)&#123;var e=new pt;return r._$62(e,t),e&#125;,pt.loadModel=function(t,e)&#123;var i=new pt(e||0);return r._$62(i,t),i&#125;,pt._$to=function()&#123;return new pt&#125;,pt._$er=function(t)&#123;var e=new _$5(&quot;../_$_r/_$t0/_$Ri/_$_P._$d&quot;);if(0==e.exists())throw new _$ls(&quot;_$t0 _$_ _$6 _$Ui :: &quot;+e._$PL());for(var i=[&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$CP._$1&quot;,&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$vP._$1&quot;,&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$EP._$1&quot;,&quot;../_$_r/_$t0/_$Ri/_$_P.512/_$pP._$1&quot;],r=pt.loadModel(e._$3b()),o=0;o&lt;i.length;o++)&#123;var n=new _$5(i[o]);if(0==n.exists())throw new _$ls(&quot;_$t0 _$_ _$6 _$Ui :: &quot;+n._$PL());r.setTexture(o,_$nL._$_o(t,n._$3b()))&#125;return r&#125;,pt.prototype.setGL=function(t)&#123;_t.setGL(t)&#125;,pt.prototype.setTransform=function(t)&#123;this.drawParamWebGL.setTransform(t)&#125;,pt.prototype.update=function()&#123;this._$5S.update(),this._$5S.preDraw(this.drawParamWebGL)&#125;,pt.prototype.draw=function()&#123;this._$5S.draw(this.drawParamWebGL)&#125;,pt.prototype._$K2=function()&#123;this.drawParamWebGL._$K2()&#125;,pt.prototype.setTexture=function(t,e)&#123;null==this.drawParamWebGL&amp;&amp;_._$li(&quot;_$Yi for QT _$ki / _$XS() is _$6 _$ui!!&quot;),this.drawParamWebGL.setTexture(t,e)&#125;,pt.prototype.setTexture=function(t,e)&#123;null==this.drawParamWebGL&amp;&amp;_._$li(&quot;_$Yi for QT _$ki / _$XS() is _$6 _$ui!!&quot;),this.drawParamWebGL.setTexture(t,e)&#125;,pt.prototype._$Rs=function()&#123;return this.drawParamWebGL._$Rs()&#125;,pt.prototype._$Ds=function(t)&#123;this.drawParamWebGL._$Ds(t)&#125;,pt.prototype.getDrawParam=function()&#123;return this.drawParamWebGL&#125;,pt.prototype.setMatrix=function(t)&#123;this.drawParamWebGL.setMatrix(t)&#125;,pt.prototype.setPremultipliedAlpha=function(t)&#123;this.drawParamWebGL.setPremultipliedAlpha(t)&#125;,pt.prototype.isPremultipliedAlpha=function()&#123;return this.drawParamWebGL.isPremultipliedAlpha()&#125;,pt.prototype.setAnisotropy=function(t)&#123;this.drawParamWebGL.setAnisotropy(t)&#125;,pt.prototype.getAnisotropy=function()&#123;return this.drawParamWebGL.getAnisotropy()&#125;,ct.prototype._$tb=function()&#123;return this.motions&#125;,ct.prototype.startMotion=function(t,e)&#123;for(var i=null,r=this.motions.length,o=0;o&lt;r;++o)null!=(i=this.motions[o])&amp;&amp;(i._$qS(i._$w0.getFadeOut()),this._$eb&amp;&amp;_._$Ji(&quot;MotionQueueManager[size:%2d]-&gt;startMotion() / start _$K _$3 (m%d)\\n&quot;,r,i._$sr));if(null==t)return-1;(i=new ft)._$w0=t,this.motions.push(i);var n=i._$sr;return this._$eb&amp;&amp;_._$Ji(&quot;MotionQueueManager[size:%2d]-&gt;startMotion() / new _$w0 (m%d)\\n&quot;,r,n),n&#125;,ct.prototype.updateParam=function(t)&#123;try&#123;for(var e=!1,i=0;i&lt;this.motions.length;i++)&#123;var r=this.motions[i];if(null!=r)&#123;var o=r._$w0;null!=o?(o.updateParam(t,r),e=!0,r.isFinished()&amp;&amp;(this._$eb&amp;&amp;_._$Ji(&quot;MotionQueueManager[size:%2d]-&gt;updateParam() / _$T0 _$w0 (m%d)\\n&quot;,this.motions.length-1,r._$sr),this.motions.splice(i,1),i--)):(this.motions=this.motions.splice(i,1),i--)&#125;else this.motions.splice(i,1),i--&#125;return e&#125;catch(t)&#123;return _._$li(t),!0&#125;&#125;,ct.prototype.isFinished=function(t)&#123;if(arguments.length&gt;=1)&#123;for(var e=0;e&lt;this.motions.length;e++)&#123;if(null!=(i=this.motions[e])&amp;&amp;(i._$sr==t&amp;&amp;!i.isFinished()))return!1&#125;return!0&#125;for(e=0;e&lt;this.motions.length;e++)&#123;var i;if(null!=(i=this.motions[e]))if(null!=i._$w0)&#123;if(!i.isFinished())return!1&#125;else this.motions.splice(e,1),e--;else this.motions.splice(e,1),e--&#125;return!0&#125;,ct.prototype.stopAllMotions=function()&#123;for(var t=0;t&lt;this.motions.length;t++)&#123;var e=this.motions[t];if(null!=e)&#123;e._$w0;this.motions.splice(t,1),t--&#125;else this.motions.splice(t,1),t--&#125;&#125;,ct.prototype._$Zr=function(t)&#123;this._$eb=t&#125;,ct.prototype._$e=function()&#123;console.log(&quot;-- _$R --\\n&quot;);for(var t=0;t&lt;this.motions.length;t++)&#123;var e=this.motions[t]._$w0;console.log(&quot;MotionQueueEnt[%d] :: %s\\n&quot;,this.motions.length,e.toString())&#125;&#125;,ft._$Gs=0,ft.prototype.isFinished=function()&#123;return this._$9L&#125;,ft.prototype._$qS=function(t)&#123;var e=x.getUserTimeMSec()+t;(this._$Do&lt;0||e&lt;this._$Do)&amp;&amp;(this._$Do=e)&#125;,ft.prototype._$Bs=function()&#123;return this._$sr&#125;,gt.prototype.setContext=function(t)&#123;var e=this.m;t.transform(e[0],e[1],e[3],e[4],e[6],e[7])&#125;,gt.prototype.toString=function()&#123;for(var t=&quot;LDTransform &#123; &quot;,e=0;e&lt;9;e++)t+=this.m[e].toFixed(2)+&quot; ,&quot;;return t+=&quot; &#125;&quot;&#125;,gt.prototype.identity=function()&#123;var t=this.m;t[0]=t[4]=t[8]=1,t[1]=t[2]=t[3]=t[5]=t[6]=t[7]=0&#125;,gt.prototype._$PS=function(t,e,i)&#123;null==i&amp;&amp;(i=new Array(0,0));var r=this.m;return i[0]=r[0]*t+r[3]*e+r[6],i[1]=r[1]*t+r[4]*e+r[7],i&#125;,gt.prototype._$P2=function(t)&#123;t||(t=new gt);var e=this.m,i=e[0],r=e[1],o=e[2],n=e[3],s=e[4],_=e[5],a=e[6],h=e[7],l=e[8],$=i*s*l+r*_*a+o*n*h-i*_*h-o*s*a-r*n*l;if(0==$)return null;var u=1/$;return t.m[0]=u*(s*l-h*_),t.m[1]=u*(h*o-r*l),t.m[2]=u*(r*_-s*o),t.m[3]=u*(a*_-n*l),t.m[4]=u*(i*l-a*o),t.m[5]=u*(n*o-i*_),t.m[6]=u*(n*h-a*s),t.m[7]=u*(a*r-i*h),t.m[8]=u*(i*s-n*r),t&#125;,gt.prototype.transform=function(t,e,i)&#123;null==i&amp;&amp;(i=new Array(0,0));var r=this.m;return i[0]=r[0]*t+r[3]*e+r[6],i[1]=r[1]*t+r[4]*e+r[7],i&#125;,gt.prototype.translate=function(t,e)&#123;var i=this.m;i[6]=i[0]*t+i[3]*e+i[6],i[7]=i[1]*t+i[4]*e+i[7],i[8]=i[2]*t+i[5]*e+i[8]&#125;,gt.prototype.scale=function(t,e)&#123;var i=this.m;i[0]*=t,i[1]*=t,i[2]*=t,i[3]*=e,i[4]*=e,i[5]*=e&#125;,gt.prototype.shear=function(t,e)&#123;var i=this.m,r=i[0]+i[3]*e,o=i[1]+i[4]*e,n=i[2]+i[5]*e;i[3]=i[0]*t+i[3],i[4]=i[1]*t+i[4],i[5]=i[2]*t+i[5],i[0]=r,i[1]=o,i[2]=n&#125;,gt.prototype.rotate=function(t)&#123;var e=this.m,i=Math.cos(t),r=Math.sin(t),o=e[0]*i+e[3]*r,n=e[1]*i+e[4]*r,s=e[2]*i+e[5]*r;e[3]=-e[0]*r+e[3]*i,e[4]=-e[1]*r+e[4]*i,e[5]=-e[2]*r+e[5]*i,e[0]=o,e[1]=n,e[2]=s&#125;,gt.prototype.concatenate=function(t)&#123;var e=this.m,i=t.m,r=e[0]*i[0]+e[3]*i[1]+e[6]*i[2],o=e[1]*i[0]+e[4]*i[1]+e[7]*i[2],n=e[2]*i[0]+e[5]*i[1]+e[8]*i[2],s=e[0]*i[3]+e[3]*i[4]+e[6]*i[5],_=e[1]*i[3]+e[4]*i[4]+e[7]*i[5],a=e[2]*i[3]+e[5]*i[4]+e[8]*i[5],h=e[0]*i[6]+e[3]*i[7]+e[6]*i[8],l=e[1]*i[6]+e[4]*i[7]+e[7]*i[8],$=e[2]*i[6]+e[5]*i[7]+e[8]*i[8];m[0]=r,m[1]=o,m[2]=n,m[3]=s,m[4]=_,m[5]=a,m[6]=h,m[7]=l,m[8]=$&#125;,yt.prototype=new it,yt._$eT=null,yt._$tP=new Object,yt._$2o=function()&#123;return null==yt._$eT&amp;&amp;(yt._$eT=yt.getID(&quot;DST_BASE&quot;)),yt._$eT&#125;,yt._$27=function()&#123;yt._$tP.clear(),yt._$eT=null&#125;,yt.getID=function(t)&#123;var e=yt._$tP[t];return null==e&amp;&amp;(e=new yt(t),yt._$tP[t]=e),e&#125;,yt.prototype._$3s=function()&#123;return new yt&#125;,dt.prototype=new M,dt._$9r=function(t)&#123;return new Float32Array(t)&#125;,dt._$vb=function(t)&#123;return new Int16Array(t)&#125;,dt._$cr=function(t,e)&#123;return null==t||t._$yL()&lt;e.length?((t=dt._$9r(2*e.length)).put(e),t._$oT(0)):(t.clear(),t.put(e),t._$oT(0)),t&#125;,dt._$mb=function(t,e)&#123;return null==t||t._$yL()&lt;e.length?((t=dt._$vb(2*e.length)).put(e),t._$oT(0)):(t.clear(),t.put(e),t._$oT(0)),t&#125;,dt._$Hs=function()&#123;return this._$Gr&#125;,dt._$as=function(t)&#123;this._$Gr=t&#125;,dt.prototype.getGL=function()&#123;return this.gl&#125;,dt.prototype.setGL=function(t)&#123;this.gl=t&#125;,dt.prototype.setTransform=function(t)&#123;this.transform=t&#125;,dt.prototype._$ZT=function()&#123;var t=this.gl;this.firstDraw&amp;&amp;(this.initShader(),this.firstDraw=!1,this.anisotropyExt=t.getExtension(&quot;EXT_texture_filter_anisotropic&quot;)||t.getExtension(&quot;WEBKIT_EXT_texture_filter_anisotropic&quot;)||t.getExtension(&quot;MOZ_EXT_texture_filter_anisotropic&quot;),this.anisotropyExt&amp;&amp;(this.maxAnisotropy=t.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT))),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.DEPTH_TEST),t.frontFace(t.CW),t.enable(t.BLEND),t.colorMask(1,1,1,1),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)&#125;,dt.prototype._$Uo=function(t,e,i,r,o,n,s,_)&#123;if(!(n&lt;.01&amp;&amp;null==this.clipBufPre_clipContextMask))&#123;n&gt;.9&amp;&amp;_t.EXPAND_W;var a=this.gl;if(null==this.gl)throw new Error(&quot;gl is null&quot;);var h,l,$,u,p=1*this._$C0*n,c=1*this._$tT*n,f=1*this._$WL*n,g=this._$lT*n;if(null!=this.clipBufPre_clipContextMask)&#123;a.frontFace(a.CCW),a.useProgram(this.shaderProgram),this._$vS=mt(a,this._$vS,r),this._$no=Tt(a,this._$no,i),a.enableVertexAttribArray(this.a_position_Loc),a.vertexAttribPointer(this.a_position_Loc,2,a.FLOAT,!1,0,0),this._$NT=mt(a,this._$NT,o),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this.textures[t]),a.uniform1i(this.s_texture0_Loc,1),a.enableVertexAttribArray(this.a_texCoord_Loc),a.vertexAttribPointer(this.a_texCoord_Loc,2,a.FLOAT,!1,0,0),a.uniformMatrix4fv(this.u_matrix_Loc,!1,this.getClipBufPre_clipContextMask().matrixForMask);var y=this.getClipBufPre_clipContextMask().layoutChannelNo,d=this.getChannelFlagAsColor(y);a.uniform4f(this.u_channelFlag,d.r,d.g,d.b,d.a);var m=this.getClipBufPre_clipContextMask().layoutBounds;a.uniform4f(this.u_baseColor_Loc,2*m.x-1,2*m.y-1,2*m._$EL()-1,2*m._$5T()-1),a.uniform1i(this.u_maskFlag_Loc,!0)&#125;else if(null!=this.getClipBufPre_clipContextDraw())&#123;a.useProgram(this.shaderProgramOff),this._$vS=mt(a,this._$vS,r),this._$no=Tt(a,this._$no,i),a.enableVertexAttribArray(this.a_position_Loc_Off),a.vertexAttribPointer(this.a_position_Loc_Off,2,a.FLOAT,!1,0,0),this._$NT=mt(a,this._$NT,o),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this.textures[t]),a.uniform1i(this.s_texture0_Loc_Off,1),a.enableVertexAttribArray(this.a_texCoord_Loc_Off),a.vertexAttribPointer(this.a_texCoord_Loc_Off,2,a.FLOAT,!1,0,0),a.uniformMatrix4fv(this.u_clipMatrix_Loc_Off,!1,this.getClipBufPre_clipContextDraw().matrixForDraw),a.uniformMatrix4fv(this.u_matrix_Loc_Off,!1,this.matrix4x4),a.activeTexture(a.TEXTURE2),a.bindTexture(a.TEXTURE_2D,_t.fTexture[this.glno]),a.uniform1i(this.s_texture1_Loc_Off,2);y=this.getClipBufPre_clipContextDraw().layoutChannelNo,d=this.getChannelFlagAsColor(y);a.uniform4f(this.u_channelFlag_Loc_Off,d.r,d.g,d.b,d.a),a.uniform4f(this.u_baseColor_Loc_Off,p,c,f,g)&#125;else a.useProgram(this.shaderProgram),this._$vS=mt(a,this._$vS,r),this._$no=Tt(a,this._$no,i),a.enableVertexAttribArray(this.a_position_Loc),a.vertexAttribPointer(this.a_position_Loc,2,a.FLOAT,!1,0,0),this._$NT=mt(a,this._$NT,o),a.activeTexture(a.TEXTURE1),a.bindTexture(a.TEXTURE_2D,this.textures[t]),a.uniform1i(this.s_texture0_Loc,1),a.enableVertexAttribArray(this.a_texCoord_Loc),a.vertexAttribPointer(this.a_texCoord_Loc,2,a.FLOAT,!1,0,0),a.uniformMatrix4fv(this.u_matrix_Loc,!1,this.matrix4x4),a.uniform4f(this.u_baseColor_Loc,p,c,f,g),a.uniform1i(this.u_maskFlag_Loc,!1);if(this.culling?this.gl.enable(a.CULL_FACE):this.gl.disable(a.CULL_FACE),this.gl.enable(a.BLEND),null!=this.clipBufPre_clipContextMask)h=a.ONE,l=a.ONE_MINUS_SRC_ALPHA,$=a.ONE,u=a.ONE_MINUS_SRC_ALPHA;else switch(s)&#123;case lt._$ms:h=a.ONE,l=a.ONE_MINUS_SRC_ALPHA,$=a.ONE,u=a.ONE_MINUS_SRC_ALPHA;break;case lt._$ns:h=a.ONE,l=a.ONE,$=a.ZERO,u=a.ONE;break;case lt._$_s:h=a.DST_COLOR,l=a.ONE_MINUS_SRC_ALPHA,$=a.ZERO,u=a.ONE&#125;a.blendEquationSeparate(a.FUNC_ADD,a.FUNC_ADD),a.blendFuncSeparate(h,l,$,u),this.anisotropyExt&amp;&amp;a.texParameteri(a.TEXTURE_2D,this.anisotropyExt.TEXTURE_MAX_ANISOTROPY_EXT,this.maxAnisotropy);var T=i.length;a.drawElements(a.TRIANGLES,T,a.UNSIGNED_SHORT,0),a.bindTexture(a.TEXTURE_2D,null)&#125;&#125;,dt.prototype._$Rs=function()&#123;throw new Error(&quot;_$Rs&quot;)&#125;,dt.prototype._$Ds=function(t)&#123;throw new Error(&quot;_$Ds&quot;)&#125;,dt.prototype._$K2=function()&#123;for(var t=0;t&lt;this.textures.length;t++)&#123;0!=this.textures[t]&amp;&amp;(this.gl._$K2(1,this.textures,t),this.textures[t]=null)&#125;&#125;,dt.prototype.setTexture=function(t,e)&#123;this.textures[t]=e&#125;,dt.prototype.initShader=function()&#123;var t=this.gl;this.loadShaders2(),this.a_position_Loc=t.getAttribLocation(this.shaderProgram,&quot;a_position&quot;),this.a_texCoord_Loc=t.getAttribLocation(this.shaderProgram,&quot;a_texCoord&quot;),this.u_matrix_Loc=t.getUniformLocation(this.shaderProgram,&quot;u_mvpMatrix&quot;),this.s_texture0_Loc=t.getUniformLocation(this.shaderProgram,&quot;s_texture0&quot;),this.u_channelFlag=t.getUniformLocation(this.shaderProgram,&quot;u_channelFlag&quot;),this.u_baseColor_Loc=t.getUniformLocation(this.shaderProgram,&quot;u_baseColor&quot;),this.u_maskFlag_Loc=t.getUniformLocation(this.shaderProgram,&quot;u_maskFlag&quot;),this.a_position_Loc_Off=t.getAttribLocation(this.shaderProgramOff,&quot;a_position&quot;),this.a_texCoord_Loc_Off=t.getAttribLocation(this.shaderProgramOff,&quot;a_texCoord&quot;),this.u_matrix_Loc_Off=t.getUniformLocation(this.shaderProgramOff,&quot;u_mvpMatrix&quot;),this.u_clipMatrix_Loc_Off=t.getUniformLocation(this.shaderProgramOff,&quot;u_ClipMatrix&quot;),this.s_texture0_Loc_Off=t.getUniformLocation(this.shaderProgramOff,&quot;s_texture0&quot;),this.s_texture1_Loc_Off=t.getUniformLocation(this.shaderProgramOff,&quot;s_texture1&quot;),this.u_channelFlag_Loc_Off=t.getUniformLocation(this.shaderProgramOff,&quot;u_channelFlag&quot;),this.u_baseColor_Loc_Off=t.getUniformLocation(this.shaderProgramOff,&quot;u_baseColor&quot;)&#125;,dt.prototype.disposeShader=function()&#123;var t=this.gl;this.shaderProgram&amp;&amp;(t.deleteProgram(this.shaderProgram),this.shaderProgram=null),this.shaderProgramOff&amp;&amp;(t.deleteProgram(this.shaderProgramOff),this.shaderProgramOff=null)&#125;,dt.prototype.compileShader=function(t,e)&#123;var i=this.gl,r=e,o=i.createShader(t);if(null==o)return _._$Ji(&quot;_$L0 to create shader&quot;),null;if(i.shaderSource(o,r),i.compileShader(o),!i.getShaderParameter(o,i.COMPILE_STATUS))&#123;var n=i.getShaderInfoLog(o);return _._$Ji(&quot;_$L0 to compile shader : &quot;+n),i.deleteShader(o),null&#125;return o&#125;,dt.prototype.loadShaders2=function()&#123;var t=this.gl;if(this.shaderProgram=t.createProgram(),!this.shaderProgram)return!1;if(this.shaderProgramOff=t.createProgram(),!this.shaderProgramOff)return!1;if(this.vertShader=this.compileShader(t.VERTEX_SHADER,&quot;attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform mat4       u_mvpMatrix;void main()&#123;    gl_Position = u_mvpMatrix * a_position;    v_ClipPos = u_mvpMatrix * a_position;    v_texCoord = a_texCoord;&#125;&quot;),!this.vertShader)return _._$Ji(&quot;Vertex shader compile _$li!&quot;),!1;if(this.vertShaderOff=this.compileShader(t.VERTEX_SHADER,&quot;attribute vec4     a_position;attribute vec2     a_texCoord;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform mat4       u_mvpMatrix;uniform mat4       u_ClipMatrix;void main()&#123;    gl_Position = u_mvpMatrix * a_position;    v_ClipPos = u_ClipMatrix * a_position;    v_texCoord = a_texCoord ;&#125;&quot;),!this.vertShaderOff)return _._$Ji(&quot;OffVertex shader compile _$li!&quot;),!1;if(this.fragShader=this.compileShader(t.FRAGMENT_SHADER,&quot;precision mediump float;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform sampler2D  s_texture0;uniform vec4       u_channelFlag;uniform vec4       u_baseColor;uniform bool       u_maskFlag;void main()&#123;    vec4 smpColor;     if(u_maskFlag)&#123;        float isInside =             step(u_baseColor.x, v_ClipPos.x/v_ClipPos.w)          * step(u_baseColor.y, v_ClipPos.y/v_ClipPos.w)          * step(v_ClipPos.x/v_ClipPos.w, u_baseColor.z)          * step(v_ClipPos.y/v_ClipPos.w, u_baseColor.w);        smpColor = u_channelFlag * texture2D(s_texture0 , v_texCoord).a * isInside;    &#125;else&#123;        smpColor = texture2D(s_texture0 , v_texCoord) * u_baseColor;    &#125;    gl_FragColor = smpColor;&#125;&quot;),!this.fragShader)return _._$Ji(&quot;Fragment shader compile _$li!&quot;),!1;if(this.fragShaderOff=this.compileShader(t.FRAGMENT_SHADER,&quot;precision mediump float ;varying vec2       v_texCoord;varying vec4       v_ClipPos;uniform sampler2D  s_texture0;uniform sampler2D  s_texture1;uniform vec4       u_channelFlag;uniform vec4       u_baseColor ;void main()&#123;    vec4 col_formask = texture2D(s_texture0, v_texCoord) * u_baseColor;    vec4 clipMask = texture2D(s_texture1, v_ClipPos.xy / v_ClipPos.w) * u_channelFlag;    float maskVal = clipMask.r + clipMask.g + clipMask.b + clipMask.a;    col_formask = col_formask * maskVal;    gl_FragColor = col_formask;&#125;&quot;),!this.fragShaderOff)return _._$Ji(&quot;OffFragment shader compile _$li!&quot;),!1;if(t.attachShader(this.shaderProgram,this.vertShader),t.attachShader(this.shaderProgram,this.fragShader),t.attachShader(this.shaderProgramOff,this.vertShaderOff),t.attachShader(this.shaderProgramOff,this.fragShaderOff),t.linkProgram(this.shaderProgram),t.linkProgram(this.shaderProgramOff),!t.getProgramParameter(this.shaderProgram,t.LINK_STATUS))&#123;var e=t.getProgramInfoLog(this.shaderProgram);return _._$Ji(&quot;_$L0 to link program: &quot;+e),this.vertShader&amp;&amp;(t.deleteShader(this.vertShader),this.vertShader=0),this.fragShader&amp;&amp;(t.deleteShader(this.fragShader),this.fragShader=0),this.shaderProgram&amp;&amp;(t.deleteProgram(this.shaderProgram),this.shaderProgram=0),this.vertShaderOff&amp;&amp;(t.deleteShader(this.vertShaderOff),this.vertShaderOff=0),this.fragShaderOff&amp;&amp;(t.deleteShader(this.fragShaderOff),this.fragShaderOff=0),this.shaderProgramOff&amp;&amp;(t.deleteProgram(this.shaderProgramOff),this.shaderProgramOff=0),!1&#125;return!0&#125;,dt.prototype.createFramebuffer=function()&#123;var t=this.gl,e=_t.clippingMaskBufferSize,i=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,i);var r=t.createRenderbuffer();t.bindRenderbuffer(t.RENDERBUFFER,r),t.renderbufferStorage(t.RENDERBUFFER,t.RGBA4,e,e),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,r);var o=t.createTexture();return t.bindTexture(t.TEXTURE_2D,o),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,e,e,0,t.RGBA,t.UNSIGNED_BYTE,null),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,o,0),t.bindTexture(t.TEXTURE_2D,null),t.bindRenderbuffer(t.RENDERBUFFER,null),t.bindFramebuffer(t.FRAMEBUFFER,null),_t.fTexture[this.glno]=o,&#123;framebuffer:i,renderbuffer:r,texture:_t.fTexture[this.glno]&#125;&#125;,Pt.prototype._$fP=function()&#123;var t,e,i,r=this._$ST();if(0==(128&amp;r))return 255&amp;r;if(0==(128&amp;(t=this._$ST())))return(127&amp;r)&lt;&lt;7|127&amp;t;if(0==(128&amp;(e=this._$ST())))return(127&amp;r)&lt;&lt;14|(127&amp;t)&lt;&lt;7|255&amp;e;if(0==(128&amp;(i=this._$ST())))return(127&amp;r)&lt;&lt;21|(127&amp;t)&lt;&lt;14|(127&amp;e)&lt;&lt;7|255&amp;i;throw new ht(&quot;_$L _$0P  _&quot;)&#125;,Pt.prototype.getFormatVersion=function()&#123;return this._$S2&#125;,Pt.prototype._$gr=function(t)&#123;this._$S2=t&#125;,Pt.prototype._$3L=function()&#123;return this._$fP()&#125;,Pt.prototype._$mP=function()&#123;return this._$zT(),this._$F+=8,this._$T.getFloat64(this._$F-8)&#125;,Pt.prototype._$_T=function()&#123;return this._$zT(),this._$F+=4,this._$T.getFloat32(this._$F-4)&#125;,Pt.prototype._$6L=function()&#123;return this._$zT(),this._$F+=4,this._$T.getInt32(this._$F-4)&#125;,Pt.prototype._$ST=function()&#123;return this._$zT(),this._$T.getInt8(this._$F++)&#125;,Pt.prototype._$9T=function()&#123;return this._$zT(),this._$F+=2,this._$T.getInt16(this._$F-2)&#125;,Pt.prototype._$2T=function()&#123;throw this._$zT(),this._$F+=8,new ht(&quot;_$L _$q read long&quot;)&#125;,Pt.prototype._$po=function()&#123;return this._$zT(),0!=this._$T.getInt8(this._$F++)&#125;;var St=!0;function vt()&#123;&#125;function Lt(t)&#123;i||(this._$e0=null,this._$IP=null,this._$Us=null,this._$7s=null,this._$IS=[!1],this._$VS=null,this._$AT=!0,this.baseOpacity=1,this.clipBufPre_clipContext=null,this._$e0=t)&#125;function Mt()&#123;&#125;Pt.prototype._$bT=function()&#123;this._$zT();var t=this._$3L(),e=null;if(St)try&#123;var i=new ArrayBuffer(2*t);e=new Uint16Array(i);for(var r=0;r&lt;t;++r)e[r]=this._$T.getUint8(this._$F++);return String.fromCharCode.apply(null,e)&#125;catch(t)&#123;St=!1&#125;try&#123;var o=new Array;if(null==e)for(r=0;r&lt;t;++r)o[r]=this._$T.getUint8(this._$F++);else for(r=0;r&lt;t;++r)o[r]=e[r];return String.fromCharCode.apply(null,o)&#125;catch(t)&#123;console.log(&quot;read utf8 / _$rT _$L0 !! : &quot;+t)&#125;&#125;,Pt.prototype._$cS=function()&#123;this._$zT();for(var t=this._$3L(),e=new Int32Array(t),i=0;i&lt;t;i++)e[i]=this._$T.getInt32(this._$F),this._$F+=4;return e&#125;,Pt.prototype._$Tb=function()&#123;this._$zT();for(var t=this._$3L(),e=new Float32Array(t),i=0;i&lt;t;i++)e[i]=this._$T.getFloat32(this._$F),this._$F+=4;return e&#125;,Pt.prototype._$5b=function()&#123;this._$zT();for(var t=this._$3L(),e=new Float64Array(t),i=0;i&lt;t;i++)e[i]=this._$T.getFloat64(this._$F),this._$F+=8;return e&#125;,Pt.prototype._$nP=function()&#123;return this._$Jb(-1)&#125;,Pt.prototype._$Jb=function(t)&#123;if(this._$zT(),t&lt;0&amp;&amp;(t=this._$3L()),t==G._$7P)&#123;var e=this._$6L();if(0&lt;=e&amp;&amp;e&lt;this._$Ko.length)return this._$Ko[e];throw new ht(&quot;_$sL _$4i @_$m0&quot;)&#125;var i=this._$4b(t);return this._$Ko.push(i),i&#125;,Pt.prototype._$4b=function(t)&#123;if(0==t)return null;if(50==t)&#123;var e=this._$bT();return n=R.getID(e)&#125;if(51==t)&#123;e=this._$bT();return n=yt.getID(e)&#125;if(134==t)&#123;e=this._$bT();return n=h.getID(e)&#125;if(60==t)&#123;e=this._$bT();return n=l.getID(e)&#125;if(t&gt;=48)&#123;var r=G._$9o(t);return null!=r?(r._$F0(this),r):null&#125;switch(t)&#123;case 1:return this._$bT();case 10:return new function()&#123;i||(this.color=null)&#125;(this._$6L(),!0);case 11:return new P(this._$mP(),this._$mP(),this._$mP(),this._$mP());case 12:return new P(this._$_T(),this._$_T(),this._$_T(),this._$_T());case 13:return new v(this._$mP(),this._$mP());case 14:return new v(this._$_T(),this._$_T());case 15:for(var o=this._$3L(),n=new Array(o),s=0;s&lt;o;s++)n[s]=this._$nP();return n;case 17:return n=new b(this._$mP(),this._$mP(),this._$mP(),this._$mP(),this._$mP(),this._$mP());case 21:return new a(this._$6L(),this._$6L(),this._$6L(),this._$6L());case 22:return new ut(this._$6L(),this._$6L());case 23:throw new Error(&quot;_$L _$ro &quot;);case 16:case 25:return this._$cS();case 26:return this._$5b();case 27:return this._$Tb();case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 18:case 19:case 20:case 24:case 28:throw new ht(&quot;_$6 _$q : _$nP() of 2-9 ,18,19,20,24,28 : &quot;+t);default:throw new ht(&quot;_$6 _$q : _$nP() NO _$i : &quot;+t)&#125;&#125;,Pt.prototype._$8L=function()&#123;return 0==this._$hL?this._$v0=this._$ST():8==this._$hL&amp;&amp;(this._$v0=this._$ST(),this._$hL=0),1==(this._$v0&gt;&gt;7-this._$hL++&amp;1)&#125;,Pt.prototype._$zT=function()&#123;0!=this._$hL&amp;&amp;(this._$hL=0)&#125;,vt._$2S=Math.PI/180,vt._$bS=Math.PI/180,vt._$wS=180/Math.PI,vt._$NS=180/Math.PI,vt.PI_F=Math.PI,vt._$kT=[0,.012368,.024734,.037097,.049454,.061803,.074143,.086471,.098786,.111087,.12337,.135634,.147877,.160098,.172295,.184465,.196606,.208718,.220798,.232844,.244854,.256827,.268761,.280654,.292503,.304308,.316066,.327776,.339436,.351044,.362598,.374097,.385538,.396921,.408243,.419502,.430697,.441826,.452888,.463881,.474802,.485651,.496425,.507124,.517745,.528287,.538748,.549126,.559421,.56963,.579752,.589785,.599728,.609579,.619337,.629,.638567,.648036,.657406,.666676,.675843,.684908,.693867,.70272,.711466,.720103,.72863,.737045,.745348,.753536,.76161,.769566,.777405,.785125,.792725,.800204,.807561,.814793,.821901,.828884,.835739,.842467,.849066,.855535,.861873,.868079,.874153,.880093,.885898,.891567,.897101,.902497,.907754,.912873,.917853,.922692,.92739,.931946,.936359,.940629,.944755,.948737,.952574,.956265,.959809,.963207,.966457,.96956,.972514,.97532,.977976,.980482,.982839,.985045,.987101,.989006,.990759,.992361,.993811,.995109,.996254,.997248,.998088,.998776,.999312,.999694,.999924,1],vt._$92=function(t,e)&#123;var i=Math.atan2(t[1],t[0]),r=Math.atan2(e[1],e[0]);return vt._$tS(i,r)&#125;,vt._$tS=function(t,e)&#123;for(var i=t-e;i&lt;-Math.PI;)i+=2*Math.PI;for(;i&gt;Math.PI;)i-=2*Math.PI;return i&#125;,vt._$9=function(t)&#123;return Math.sin(t)&#125;,vt.fcos=function(t)&#123;return Math.cos(t)&#125;,Lt.prototype._$u2=function()&#123;return this._$IS[0]&#125;,Lt.prototype._$yo=function()&#123;return this._$AT&amp;&amp;!this._$IS[0]&#125;,Lt.prototype._$GT=function()&#123;return this._$e0&#125;,Mt._$W2=0,Mt.SYSTEM_INFO=null,Mt.USER_AGENT=navigator.userAgent,Mt.isIPhone=function()&#123;return Mt.SYSTEM_INFO||Mt.setup(),Mt.SYSTEM_INFO._isIPhone&#125;,Mt.isIOS=function()&#123;return Mt.SYSTEM_INFO||Mt.setup(),Mt.SYSTEM_INFO._isIPhone||Mt.SYSTEM_INFO._isIPad&#125;,Mt.isAndroid=function()&#123;return Mt.SYSTEM_INFO||Mt.setup(),Mt.SYSTEM_INFO._isAndroid&#125;,Mt.getOSVersion=function()&#123;return Mt.SYSTEM_INFO||Mt.setup(),Mt.SYSTEM_INFO.version&#125;,Mt.getOS=function()&#123;return Mt.SYSTEM_INFO||Mt.setup(),Mt.SYSTEM_INFO._isIPhone||Mt.SYSTEM_INFO._isIPad?&quot;iOS&quot;:Mt.SYSTEM_INFO._isAndroid?&quot;Android&quot;:&quot;_$Q0 OS&quot;&#125;,Mt.setup=function()&#123;var t,e=Mt.USER_AGENT;function i(t,e)&#123;for(var i=t.substring(e).split(/[ _,;\\.]/),r=0,o=0;o&lt;=2&amp;&amp;!isNaN(i[o]);o++)&#123;var n=parseInt(i[o]);if(n&lt;0||n&gt;999)&#123;_._$li(&quot;err : &quot;+n+&quot; @UtHtml5.setup()&quot;),r=0;break&#125;r+=n*Math.pow(1e3,2-o)&#125;return r&#125;var r=Mt.SYSTEM_INFO=&#123;userAgent:e&#125;;if((t=e.indexOf(&quot;iPhone OS &quot;))&gt;=0)r.os=&quot;iPhone&quot;,r._isIPhone=!0,r.version=i(e,t+&quot;iPhone OS &quot;.length);else if((t=e.indexOf(&quot;iPad&quot;))&gt;=0)&#123;if((t=e.indexOf(&quot;CPU OS&quot;))&lt;0)return void _._$li(&quot; err : &quot;+e+&quot; @UtHtml5.setup()&quot;);r.os=&quot;iPad&quot;,r._isIPad=!0,r.version=i(e,t+&quot;CPU OS &quot;.length)&#125;else(t=e.indexOf(&quot;Android&quot;))&gt;=0?(r.os=&quot;Android&quot;,r._isAndroid=!0,r.version=i(e,t+&quot;Android &quot;.length)):(r.os=&quot;-&quot;,r.version=-1)&#125;,_t.init();i=!1;e.UtSystem=x,e.UtDebug=_,e.LDTransform=gt,e.LDGL=ot,e.Live2D=_t,e.Live2DModelWebGL=pt,e.Live2DModelJS=q,e.Live2DMotion=J,e.MotionQueueManager=ct,e.PhysicsHair=u,e.AMotion=s,e.PartsDataID=h,e.DrawDataID=R,e.BaseDataID=yt,e.ParamID=l&#125;).call(e,i(85))&#125;,81:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.L2DBaseModel=e.L2DExpressionMotion=e.L2DExpressionParam=e.L2DEyeBlink=e.EYE_STATE=e.L2DMatrix44=e.L2DModelMatrix=e.L2DMotionManager=e.L2DPhysics=e.L2DPartsParam=e.L2DPose=e.L2DViewMatrix=e.Live2DFramework=e.L2DTargetPoint=void 0;var r=i(80);function o()&#123;this.live2DModel=null,this.modelMatrix=null,this.eyeBlink=null,this.physics=null,this.pose=null,this.debugMode=!1,this.initialized=!1,this.updating=!1,this.alpha=1,this.accAlpha=0,this.lipSync=!1,this.lipSyncValue=0,this.accelX=0,this.accelY=0,this.accelZ=0,this.dragX=0,this.dragY=0,this.startTimeMSec=null,this.mainMotionManager=new u,this.expressionManager=new u,this.motions=&#123;&#125;,this.expressions=&#123;&#125;,this.isTexLoaded=!1&#125;var n=0;function s()&#123;r.AMotion.prototype.constructor.call(this),this.paramList=new Array&#125;function _()&#123;this.id=&quot;&quot;,this.type=-1,this.value=null&#125;function a()&#123;this.nextBlinkTime=null,this.stateStartTime=null,this.blinkIntervalMsec=null,this.eyeState=h.STATE_FIRST,this.blinkIntervalMsec=4e3,this.closingMotionMsec=100,this.closedMotionMsec=50,this.openingMotionMsec=150,this.closeIfZero=!0,this.eyeID_L=&quot;PARAM_EYE_L_OPEN&quot;,this.eyeID_R=&quot;PARAM_EYE_R_OPEN&quot;&#125;o.prototype.getModelMatrix=function()&#123;return this.modelMatrix&#125;,o.prototype.setAlpha=function(t)&#123;t&gt;.999&amp;&amp;(t=1),t&lt;.001&amp;&amp;(t=0),this.alpha=t&#125;,o.prototype.getAlpha=function()&#123;return this.alpha&#125;,o.prototype.isInitialized=function()&#123;return this.initialized&#125;,o.prototype.setInitialized=function(t)&#123;this.initialized=t&#125;,o.prototype.isUpdating=function()&#123;return this.updating&#125;,o.prototype.setUpdating=function(t)&#123;this.updating=t&#125;,o.prototype.getLive2DModel=function()&#123;return this.live2DModel&#125;,o.prototype.setLipSync=function(t)&#123;this.lipSync=t&#125;,o.prototype.setLipSyncValue=function(t)&#123;this.lipSyncValue=t&#125;,o.prototype.setAccel=function(t,e,i)&#123;this.accelX=t,this.accelY=e,this.accelZ=i&#125;,o.prototype.setDrag=function(t,e)&#123;this.dragX=t,this.dragY=e&#125;,o.prototype.getMainMotionManager=function()&#123;return this.mainMotionManager&#125;,o.prototype.getExpressionManager=function()&#123;return this.expressionManager&#125;,o.prototype.loadModelData=function(t,e)&#123;var i=d.getPlatformManager();this.debugMode&amp;&amp;i.log(&quot;Load model : &quot;+t);var o=this;i.loadLive2DModel(t,function(t)&#123;o.live2DModel=t,o.live2DModel.saveParam(),0==r.Live2D.getError()?(o.modelMatrix=new $(o.live2DModel.getCanvasWidth(),o.live2DModel.getCanvasHeight()),o.modelMatrix.setWidth(2),o.modelMatrix.setCenterPosition(0,0),e(o.live2DModel)):console.error(&quot;Error : Failed to loadModelData().&quot;)&#125;)&#125;,o.prototype.loadTexture=function(t,e,i)&#123;n++;var r=d.getPlatformManager();this.debugMode&amp;&amp;r.log(&quot;Load Texture : &quot;+e);var o=this;r.loadTexture(this.live2DModel,t,e,function()&#123;0==--n&amp;&amp;(o.isTexLoaded=!0),&quot;function&quot;==typeof i&amp;&amp;i()&#125;)&#125;,o.prototype.loadMotion=function(t,e,i)&#123;var o=d.getPlatformManager();this.debugMode&amp;&amp;o.log(&quot;Load Motion : &quot;+e);var n=null,s=this;o.loadBytes(e,function(e)&#123;n=r.Live2DMotion.loadMotion(e),null!=t&amp;&amp;(s.motions[t]=n),i(n)&#125;)&#125;,o.prototype.loadExpression=function(t,e,i)&#123;var r=d.getPlatformManager();this.debugMode&amp;&amp;r.log(&quot;Load Expression : &quot;+e);var o=this;r.loadBytes(e,function(e)&#123;null!=t&amp;&amp;(o.expressions[t]=s.loadJson(e)),&quot;function&quot;==typeof i&amp;&amp;i()&#125;)&#125;,o.prototype.loadPose=function(t,e)&#123;var i=d.getPlatformManager();this.debugMode&amp;&amp;i.log(&quot;Load Pose : &quot;+t);var r=this;try&#123;i.loadBytes(t,function(t)&#123;r.pose=c.load(t),&quot;function&quot;==typeof e&amp;&amp;e()&#125;)&#125;catch(t)&#123;console.warn(t)&#125;&#125;,o.prototype.loadPhysics=function(t)&#123;var e=d.getPlatformManager();this.debugMode&amp;&amp;e.log(&quot;Load Physics : &quot;+t);var i=this;try&#123;e.loadBytes(t,function(t)&#123;i.physics=p.load(t)&#125;)&#125;catch(t)&#123;console.warn(t)&#125;&#125;,o.prototype.hitTestSimple=function(t,e,i)&#123;if(null===this.live2DModel)return!1;var r=this.live2DModel.getDrawDataIndex(t);if(r&lt;0)return!1;for(var o=this.live2DModel.getTransformedPoints(r),n=this.live2DModel.getCanvasWidth(),s=0,_=this.live2DModel.getCanvasHeight(),a=0,h=0;h&lt;o.length;h+=2)&#123;var l=o[h],$=o[h+1];l&lt;n&amp;&amp;(n=l),l&gt;s&amp;&amp;(s=l),$&lt;_&amp;&amp;(_=$),$&gt;a&amp;&amp;(a=$)&#125;var u=this.modelMatrix.invertTransformX(e),p=this.modelMatrix.invertTransformY(i);return n&lt;=u&amp;&amp;u&lt;=s&amp;&amp;_&lt;=p&amp;&amp;p&lt;=a&#125;,s.prototype=new r.AMotion,s.EXPRESSION_DEFAULT=&quot;DEFAULT&quot;,s.TYPE_SET=0,s.TYPE_ADD=1,s.TYPE_MULT=2,s.loadJson=function(t)&#123;var e=new s,i=d.getPlatformManager().jsonParseFromBytes(t);if(e.setFadeIn(parseInt(i.fade_in)&gt;0?parseInt(i.fade_in):1e3),e.setFadeOut(parseInt(i.fade_out)&gt;0?parseInt(i.fade_out):1e3),null==i.params)return e;var r=i.params,o=r.length;e.paramList=[];for(var n=0;n&lt;o;n++)&#123;var a=r[n],h=a.id.toString(),l=parseFloat(a.val),$=s.TYPE_ADD,u=null!=a.calc?a.calc.toString():&quot;add&quot;;if(($=&quot;add&quot;===u?s.TYPE_ADD:&quot;mult&quot;===u?s.TYPE_MULT:&quot;set&quot;===u?s.TYPE_SET:s.TYPE_ADD)==s.TYPE_ADD)l-=p=null==a.def?0:parseFloat(a.def);else if($==s.TYPE_MULT)&#123;var p;0==(p=null==a.def?1:parseFloat(a.def))&amp;&amp;(p=1),l/=p&#125;var c=new _;c.id=h,c.type=$,c.value=l,e.paramList.push(c)&#125;return e&#125;,s.prototype.updateParamExe=function(t,e,i,r)&#123;for(var o=this.paramList.length-1;o&gt;=0;--o)&#123;var n=this.paramList[o];n.type==s.TYPE_ADD?t.addToParamFloat(n.id,n.value,i):n.type==s.TYPE_MULT?t.multParamFloat(n.id,n.value,i):n.type==s.TYPE_SET&amp;&amp;t.setParamFloat(n.id,n.value,i)&#125;&#125;,a.prototype.calcNextBlink=function()&#123;return r.UtSystem.getUserTimeMSec()+Math.random()*(2*this.blinkIntervalMsec-1)&#125;,a.prototype.setInterval=function(t)&#123;this.blinkIntervalMsec=t&#125;,a.prototype.setEyeMotion=function(t,e,i)&#123;this.closingMotionMsec=t,this.closedMotionMsec=e,this.openingMotionMsec=i&#125;,a.prototype.updateParam=function(t)&#123;var e,i=r.UtSystem.getUserTimeMSec(),o=0;switch(this.eyeState)&#123;case h.STATE_CLOSING:(o=(i-this.stateStartTime)/this.closingMotionMsec)&gt;=1&amp;&amp;(o=1,this.eyeState=h.STATE_CLOSED,this.stateStartTime=i),e=1-o;break;case h.STATE_CLOSED:(o=(i-this.stateStartTime)/this.closedMotionMsec)&gt;=1&amp;&amp;(this.eyeState=h.STATE_OPENING,this.stateStartTime=i),e=0;break;case h.STATE_OPENING:(o=(i-this.stateStartTime)/this.openingMotionMsec)&gt;=1&amp;&amp;(o=1,this.eyeState=h.STATE_INTERVAL,this.nextBlinkTime=this.calcNextBlink()),e=o;break;case h.STATE_INTERVAL:this.nextBlinkTime&lt;i&amp;&amp;(this.eyeState=h.STATE_CLOSING,this.stateStartTime=i),e=1;break;case h.STATE_FIRST:default:this.eyeState=h.STATE_INTERVAL,this.nextBlinkTime=this.calcNextBlink(),e=1&#125;this.closeIfZero||(e=-e),t.setParamFloat(this.eyeID_L,e),t.setParamFloat(this.eyeID_R,e)&#125;;var h=function()&#123;&#125;;function l()&#123;this.tr=new Float32Array(16),this.identity()&#125;function $(t,e)&#123;l.prototype.constructor.call(this),this.width=t,this.height=e&#125;function u()&#123;r.MotionQueueManager.prototype.constructor.call(this),this.currentPriority=null,this.reservePriority=null,this.super=r.MotionQueueManager.prototype&#125;function p()&#123;this.physicsList=new Array,this.startTimeMSec=r.UtSystem.getUserTimeMSec()&#125;function c()&#123;this.lastTime=0,this.lastModel=null,this.partsGroups=new Array&#125;function f(t)&#123;this.paramIndex=-1,this.partsIndex=-1,this.link=null,this.id=t&#125;function g()&#123;this.EPSILON=.01,this.faceTargetX=0,this.faceTargetY=0,this.faceX=0,this.faceY=0,this.faceVX=0,this.faceVY=0,this.lastTimeSec=0&#125;function y()&#123;l.prototype.constructor.call(this),this.screenLeft=null,this.screenRight=null,this.screenTop=null,this.screenBottom=null,this.maxLeft=null,this.maxRight=null,this.maxTop=null,this.maxBottom=null&#125;function d()&#123;&#125;h.STATE_FIRST=&quot;STATE_FIRST&quot;,h.STATE_INTERVAL=&quot;STATE_INTERVAL&quot;,h.STATE_CLOSING=&quot;STATE_CLOSING&quot;,h.STATE_CLOSED=&quot;STATE_CLOSED&quot;,h.STATE_OPENING=&quot;STATE_OPENING&quot;,l.mul=function(t,e,i)&#123;var r,o,n,s=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(r=0;r&lt;4;r++)for(o=0;o&lt;4;o++)for(n=0;n&lt;4;n++)s[r+4*o]+=t[r+4*n]*e[n+4*o];for(r=0;r&lt;16;r++)i[r]=s[r]&#125;,l.prototype.identity=function()&#123;for(var t=0;t&lt;16;t++)this.tr[t]=t%5==0?1:0&#125;,l.prototype.getArray=function()&#123;return this.tr&#125;,l.prototype.getCopyMatrix=function()&#123;return new Float32Array(this.tr)&#125;,l.prototype.setMatrix=function(t)&#123;if(null!=this.tr&amp;&amp;this.tr.length==this.tr.length)for(var e=0;e&lt;16;e++)this.tr[e]=t[e]&#125;,l.prototype.getScaleX=function()&#123;return this.tr[0]&#125;,l.prototype.getScaleY=function()&#123;return this.tr[5]&#125;,l.prototype.transformX=function(t)&#123;return this.tr[0]*t+this.tr[12]&#125;,l.prototype.transformY=function(t)&#123;return this.tr[5]*t+this.tr[13]&#125;,l.prototype.invertTransformX=function(t)&#123;return(t-this.tr[12])/this.tr[0]&#125;,l.prototype.invertTransformY=function(t)&#123;return(t-this.tr[13])/this.tr[5]&#125;,l.prototype.multTranslate=function(t,e)&#123;var i=[1,0,0,0,0,1,0,0,0,0,1,0,t,e,0,1];l.mul(i,this.tr,this.tr)&#125;,l.prototype.translate=function(t,e)&#123;this.tr[12]=t,this.tr[13]=e&#125;,l.prototype.translateX=function(t)&#123;this.tr[12]=t&#125;,l.prototype.translateY=function(t)&#123;this.tr[13]=t&#125;,l.prototype.multScale=function(t,e)&#123;var i=[t,0,0,0,0,e,0,0,0,0,1,0,0,0,0,1];l.mul(i,this.tr,this.tr)&#125;,l.prototype.scale=function(t,e)&#123;this.tr[0]=t,this.tr[5]=e&#125;,$.prototype=new l,$.prototype.setPosition=function(t,e)&#123;this.translate(t,e)&#125;,$.prototype.setCenterPosition=function(t,e)&#123;var i=this.width*this.getScaleX(),r=this.height*this.getScaleY();this.translate(t-i/2,e-r/2)&#125;,$.prototype.top=function(t)&#123;this.setY(t)&#125;,$.prototype.bottom=function(t)&#123;var e=this.height*this.getScaleY();this.translateY(t-e)&#125;,$.prototype.left=function(t)&#123;this.setX(t)&#125;,$.prototype.right=function(t)&#123;var e=this.width*this.getScaleX();this.translateX(t-e)&#125;,$.prototype.centerX=function(t)&#123;var e=this.width*this.getScaleX();this.translateX(t-e/2)&#125;,$.prototype.centerY=function(t)&#123;var e=this.height*this.getScaleY();this.translateY(t-e/2)&#125;,$.prototype.setX=function(t)&#123;this.translateX(t)&#125;,$.prototype.setY=function(t)&#123;this.translateY(t)&#125;,$.prototype.setHeight=function(t)&#123;var e=t/this.height,i=-e;this.scale(e,i)&#125;,$.prototype.setWidth=function(t)&#123;var e=t/this.width,i=-e;this.scale(e,i)&#125;,u.prototype=new r.MotionQueueManager,u.prototype.getCurrentPriority=function()&#123;return this.currentPriority&#125;,u.prototype.getReservePriority=function()&#123;return this.reservePriority&#125;,u.prototype.reserveMotion=function(t)&#123;return!(this.reservePriority&gt;=t)&amp;&amp;(!(this.currentPriority&gt;=t)&amp;&amp;(this.reservePriority=t,!0))&#125;,u.prototype.setReservePriority=function(t)&#123;this.reservePriority=t&#125;,u.prototype.updateParam=function(t)&#123;var e=r.MotionQueueManager.prototype.updateParam.call(this,t);return this.isFinished()&amp;&amp;(this.currentPriority=0),e&#125;,u.prototype.startMotionPrio=function(t,e)&#123;return e==this.reservePriority&amp;&amp;(this.reservePriority=0),this.currentPriority=e,this.startMotion(t,!1)&#125;,p.load=function(t)&#123;for(var e=new p,i=d.getPlatformManager().jsonParseFromBytes(t).physics_hair,o=i.length,n=0;n&lt;o;n++)&#123;var s=i[n],_=new r.PhysicsHair,a=s.setup,h=parseFloat(a.length),l=parseFloat(a.regist),$=parseFloat(a.mass);_.setup(h,l,$);for(var u=s.src,c=u.length,f=0;f&lt;c;f++)&#123;var g=u[f],y=g.id,m=r.PhysicsHair.Src.SRC_TO_X;&quot;x&quot;===(L=g.ptype)?m=r.PhysicsHair.Src.SRC_TO_X:&quot;y&quot;===L?m=r.PhysicsHair.Src.SRC_TO_Y:&quot;angle&quot;===L?m=r.PhysicsHair.Src.SRC_TO_G_ANGLE:r.UtDebug.error(&quot;live2d&quot;,&quot;Invalid parameter:PhysicsHair.Src&quot;);var T=parseFloat(g.scale),P=parseFloat(g.weight);_.addSrcParam(m,y,T,P)&#125;var S=s.targets,v=S.length;for(f=0;f&lt;v;f++)&#123;var L,M=S[f];y=M.id,m=r.PhysicsHair.Target.TARGET_FROM_ANGLE;&quot;angle&quot;===(L=M.ptype)?m=r.PhysicsHair.Target.TARGET_FROM_ANGLE:&quot;angle_v&quot;===L?m=r.PhysicsHair.Target.TARGET_FROM_ANGLE_V:r.UtDebug.error(&quot;live2d&quot;,&quot;Invalid parameter:PhysicsHair.Target&quot;);T=parseFloat(M.scale),P=parseFloat(M.weight);_.addTargetParam(m,y,T,P)&#125;e.physicsList.push(_)&#125;return e&#125;,p.prototype.updateParam=function(t)&#123;for(var e=r.UtSystem.getUserTimeMSec()-this.startTimeMSec,i=0;i&lt;this.physicsList.length;i++)this.physicsList[i].update(t,e)&#125;,c.load=function(t)&#123;for(var e=new c,i=d.getPlatformManager().jsonParseFromBytes(t).parts_visible,r=i.length,o=0;o&lt;r;o++)&#123;for(var n=i[o].group,s=n.length,_=new Array,a=0;a&lt;s;a++)&#123;var h=n[a],l=new f(h.id);if(_[a]=l,null!=h.link)&#123;var $=h.link,u=$.length;l.link=new Array;for(var p=0;p&lt;u;p++)&#123;var g=new f($[p]);l.link.push(g)&#125;&#125;&#125;e.partsGroups.push(_)&#125;return e&#125;,c.prototype.updateParam=function(t)&#123;if(null!=t)&#123;t!=this.lastModel&amp;&amp;this.initParam(t),this.lastModel=t;var e=r.UtSystem.getUserTimeMSec(),i=0==this.lastTime?0:(e-this.lastTime)/1e3;this.lastTime=e,i&lt;0&amp;&amp;(i=0);for(var o=0;o&lt;this.partsGroups.length;o++)this.normalizePartsOpacityGroup(t,this.partsGroups[o],i),this.copyOpacityOtherParts(t,this.partsGroups[o])&#125;&#125;,c.prototype.initParam=function(t)&#123;if(null!=t)for(var e=0;e&lt;this.partsGroups.length;e++)for(var i=this.partsGroups[e],r=0;r&lt;i.length;r++)&#123;i[r].initIndex(t);var o=i[r].partsIndex,n=i[r].paramIndex;if(!(o&lt;0))&#123;var s=0!=t.getParamFloat(n);if(t.setPartsOpacity(o,s?1:0),t.setParamFloat(n,s?1:0),null!=i[r].link)for(var _=0;_&lt;i[r].link.length;_++)i[r].link[_].initIndex(t)&#125;&#125;&#125;,c.prototype.normalizePartsOpacityGroup=function(t,e,i)&#123;for(var r=-1,o=1,n=0;n&lt;e.length;n++)&#123;var s=e[n].partsIndex,_=e[n].paramIndex;if(!(s&lt;0)&amp;&amp;0!=t.getParamFloat(_))&#123;if(r&gt;=0)break;r=n,o=t.getPartsOpacity(s),(o+=i/.5)&gt;1&amp;&amp;(o=1)&#125;&#125;r&lt;0&amp;&amp;(r=0,o=1);for(n=0;n&lt;e.length;n++)&#123;if(!((s=e[n].partsIndex)&lt;0))if(r==n)t.setPartsOpacity(s,o);else&#123;var a,h=t.getPartsOpacity(s);(1-(a=o&lt;.5?-.5*o/.5+1:.5*(1-o)/.5))*(1-o)&gt;.15&amp;&amp;(a=1-.15/(1-o)),h&gt;a&amp;&amp;(h=a),t.setPartsOpacity(s,h)&#125;&#125;&#125;,c.prototype.copyOpacityOtherParts=function(t,e)&#123;for(var i=0;i&lt;e.length;i++)&#123;var r=e[i];if(null!=r.link&amp;&amp;!(r.partsIndex&lt;0))for(var o=t.getPartsOpacity(r.partsIndex),n=0;n&lt;r.link.length;n++)&#123;var s=r.link[n];s.partsIndex&lt;0||t.setPartsOpacity(s.partsIndex,o)&#125;&#125;&#125;,f.prototype.initIndex=function(t)&#123;this.paramIndex=t.getParamIndex(&quot;VISIBLE:&quot;+this.id),this.partsIndex=t.getPartsDataIndex(r.PartsDataID.getID(this.id)),t.setParamFloat(this.paramIndex,1)&#125;,g.FRAME_RATE=60,g.prototype.setPoint=function(t,e)&#123;this.faceTargetX=t,this.faceTargetY=e&#125;,g.prototype.getX=function()&#123;return this.faceX&#125;,g.prototype.getY=function()&#123;return this.faceY&#125;,g.prototype.update=function()&#123;var t=40/7.5/g.FRAME_RATE;if(0!=this.lastTimeSec)&#123;var e=r.UtSystem.getUserTimeMSec(),i=(e-this.lastTimeSec)*g.FRAME_RATE/1e3;this.lastTimeSec=e;var o=i*t/(.15*g.FRAME_RATE),n=this.faceTargetX-this.faceX,s=this.faceTargetY-this.faceY;if(!(Math.abs(n)&lt;=this.EPSILON&amp;&amp;Math.abs(s)&lt;=this.EPSILON))&#123;var _=Math.sqrt(n*n+s*s),a=t*s/_,h=t*n/_-this.faceVX,l=a-this.faceVY,$=Math.sqrt(h*h+l*l);($&lt;-o||$&gt;o)&amp;&amp;(h*=o/$,l*=o/$,$=o),this.faceVX+=h,this.faceVY+=l;var u=.5*(Math.sqrt(o*o+16*o*_-8*o*_)-o),p=Math.sqrt(this.faceVX*this.faceVX+this.faceVY*this.faceVY);p&gt;u&amp;&amp;(this.faceVX*=u/p,this.faceVY*=u/p),this.faceX+=this.faceVX,this.faceY+=this.faceVY&#125;&#125;else this.lastTimeSec=r.UtSystem.getUserTimeMSec()&#125;,y.prototype=new l,y.prototype.adjustTranslate=function(t,e)&#123;this.tr[0]*this.maxLeft+(this.tr[12]+t)&gt;this.screenLeft&amp;&amp;(t=this.screenLeft-this.tr[0]*this.maxLeft-this.tr[12]),this.tr[0]*this.maxRight+(this.tr[12]+t)&lt;this.screenRight&amp;&amp;(t=this.screenRight-this.tr[0]*this.maxRight-this.tr[12]),this.tr[5]*this.maxTop+(this.tr[13]+e)&lt;this.screenTop&amp;&amp;(e=this.screenTop-this.tr[5]*this.maxTop-this.tr[13]),this.tr[5]*this.maxBottom+(this.tr[13]+e)&gt;this.screenBottom&amp;&amp;(e=this.screenBottom-this.tr[5]*this.maxBottom-this.tr[13]);var i=[1,0,0,0,0,1,0,0,0,0,1,0,t,e,0,1];l.mul(i,this.tr,this.tr)&#125;,y.prototype.adjustScale=function(t,e,i)&#123;this.tr[0];var r=[1,0,0,0,0,1,0,0,0,0,1,0,t,e,0,1],o=[i,0,0,0,0,i,0,0,0,0,1,0,0,0,0,1],n=[1,0,0,0,0,1,0,0,0,0,1,0,-t,-e,0,1];l.mul(n,this.tr,this.tr),l.mul(o,this.tr,this.tr),l.mul(r,this.tr,this.tr)&#125;,y.prototype.setScreenRect=function(t,e,i,r)&#123;this.screenLeft=t,this.screenRight=e,this.screenTop=r,this.screenBottom=i&#125;,y.prototype.setMaxScreenRect=function(t,e,i,r)&#123;this.maxLeft=t,this.maxRight=e,this.maxTop=r,this.maxBottom=i&#125;,y.prototype.getScreenLeft=function()&#123;return this.screenLeft&#125;,y.prototype.getScreenRight=function()&#123;return this.screenRight&#125;,y.prototype.getScreenBottom=function()&#123;return this.screenBottom&#125;,y.prototype.getScreenTop=function()&#123;return this.screenTop&#125;,y.prototype.getMaxLeft=function()&#123;return this.maxLeft&#125;,y.prototype.getMaxRight=function()&#123;return this.maxRight&#125;,y.prototype.getMaxBottom=function()&#123;return this.maxBottom&#125;,y.prototype.getMaxTop=function()&#123;return this.maxTop&#125;,d.platformManager=null,d.getPlatformManager=function()&#123;return d.platformManager&#125;,d.setPlatformManager=function(t)&#123;d.platformManager=t&#125;,e.L2DTargetPoint=g,e.Live2DFramework=d,e.L2DViewMatrix=y,e.L2DPose=c,e.L2DPartsParam=f,e.L2DPhysics=p,e.L2DMotionManager=u,e.L2DModelMatrix=$,e.L2DMatrix44=l,e.EYE_STATE=h,e.L2DEyeBlink=a,e.L2DExpressionParam=_,e.L2DExpressionMotion=s,e.L2DBaseModel=o&#125;,82:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;);e.cDefine=&#123;VIEW_LOGICAL_LEFT:-1,VIEW_LOGICAL_RIGHT:1,VIEW_LOGICAL_MAX_LEFT:-2,VIEW_LOGICAL_MAX_RIGHT:2,VIEW_LOGICAL_MAX_BOTTOM:-2,VIEW_LOGICAL_MAX_TOP:2,PRIORITY_NONE:0,PRIORITY_IDLE:1,PRIORITY_NORMAL:2,PRIORITY_FORCE:3,MOTION_GROUP_IDLE:&quot;idle&quot;,MOTION_GROUP_TAP_BODY:&quot;tap_body&quot;,MOTION_GROUP_FLICK_HEAD:&quot;flick_head&quot;,MOTION_GROUP_PINCH_IN:&quot;pinch_in&quot;,MOTION_GROUP_PINCH_OUT:&quot;pinch_out&quot;,MOTION_GROUP_SHAKE:&quot;shake&quot;,HIT_AREA_HEAD:&quot;head&quot;,HIT_AREA_BODY:&quot;body&quot;&#125;&#125;,83:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.currCanvas=e.currWebGL=e.createElement=void 0;var r=i(26),o=i(27),n=i(40),s=void 0,_=void 0;e.createElement=function()&#123;var t=document.getElementById(r.config.name.div);null!==t&amp;&amp;document.body.removeChild(t);var i=document.createElement(&quot;div&quot;);i.id=r.config.name.div,i.className=&quot;live2d-widget-container&quot;,i.style.setProperty(&quot;position&quot;,&quot;fixed&quot;),i.style.setProperty(r.config.display.position,r.config.display.hOffset+&quot;px&quot;),i.style.setProperty(&quot;bottom&quot;,r.config.display.vOffset+&quot;px&quot;),i.style.setProperty(&quot;width&quot;,r.config.display.width+&quot;px&quot;),i.style.setProperty(&quot;height&quot;,r.config.display.height+&quot;px&quot;),i.style.setProperty(&quot;z-index&quot;,99999),i.style.setProperty(&quot;opacity&quot;,r.config.react.opacity),i.style.setProperty(&quot;pointer-events&quot;,&quot;none&quot;),document.body.appendChild(i),o.L2Dwidget.emit(&quot;create-container&quot;,i),r.config.dialog.enable&amp;&amp;(0,n.createDialogElement)(i);var a=document.createElement(&quot;canvas&quot;);a.setAttribute(&quot;id&quot;,r.config.name.canvas),a.setAttribute(&quot;width&quot;,r.config.display.width*r.config.display.superSample),a.setAttribute(&quot;height&quot;,r.config.display.height*r.config.display.superSample),a.style.setProperty(&quot;position&quot;,&quot;absolute&quot;),a.style.setProperty(&quot;left&quot;,&quot;0px&quot;),a.style.setProperty(&quot;top&quot;,&quot;0px&quot;),a.style.setProperty(&quot;width&quot;,r.config.display.width+&quot;px&quot;),a.style.setProperty(&quot;height&quot;,r.config.display.height+&quot;px&quot;),r.config.dev.border&amp;&amp;a.style.setProperty(&quot;border&quot;,&quot;dashed 1px #CCC&quot;),i.appendChild(a),e.currCanvas=_=document.getElementById(r.config.name.canvas),o.L2Dwidget.emit(&quot;create-canvas&quot;,a),function()&#123;for(var t=[&quot;webgl2&quot;,&quot;webgl&quot;,&quot;experimental-webgl2&quot;,&quot;experimental-webgl&quot;,&quot;webkit-3d&quot;,&quot;moz-webgl&quot;],i=0;i&lt;t.length;i++)try&#123;var r=_.getContext(t[i],&#123;alpha:!0,antialias:!0,premultipliedAlpha:!0,failIfMajorPerformanceCaveat:!1&#125;);r&amp;&amp;(e.currWebGL=s=r)&#125;catch(t)&#123;&#125;s||(console.error(&quot;Live2D widgets: Failed to create WebGL context.&quot;),window.WebGLRenderingContext||console.error(&quot;Your browser may not support WebGL, check https://get.webgl.org/ for futher information.&quot;))&#125;()&#125;,e.currWebGL=s,e.currCanvas=_&#125;,84:function(t,e,i)&#123;&quot;use strict&quot;;function r()&#123;&#125;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.MatrixStack=r,r.matrixStack=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],r.depth=0,r.currentMatrix=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],r.tmp=new Array(16),r.reset=function()&#123;this.depth=0&#125;,r.loadIdentity=function()&#123;for(var t=0;t&lt;16;t++)this.currentMatrix[t]=t%5==0?1:0&#125;,r.push=function()&#123;var t=16*(this.depth+1);this.matrixStack.length&lt;t+16&amp;&amp;(this.matrixStack.length=t+16);for(var e=0;e&lt;16;e++)this.matrixStack[t+e]=this.currentMatrix[e];this.depth++&#125;,r.pop=function()&#123;this.depth--,this.depth&lt;0&amp;&amp;(myError(&quot;Invalid matrix stack.&quot;),this.depth=0);for(var t=16*this.depth,e=0;e&lt;16;e++)this.currentMatrix[e]=this.matrixStack[t+e]&#125;,r.getMatrix=function()&#123;return this.currentMatrix&#125;,r.multMatrix=function(t)&#123;var e,i,r;for(e=0;e&lt;16;e++)this.tmp[e]=0;for(e=0;e&lt;4;e++)for(i=0;i&lt;4;i++)for(r=0;r&lt;4;r++)this.tmp[e+4*i]+=this.currentMatrix[e+4*r]*t[r+4*i];for(e=0;e&lt;16;e++)this.currentMatrix[e]=this.tmp[e]&#125;&#125;,85:function(t,e)&#123;t.exports=&#123;import:function()&#123;throw new Error(&quot;System.import cannot be used indirectly&quot;)&#125;&#125;&#125;,86:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.cManager=void 0;var r=i(81),o=i(87),n=i(88),s=i(82);function _(t)&#123;this.eventemitter=t,this.models=[],this.count=-1,this.reloadFlg=!1,r.Live2DFramework.setPlatformManager(new o.PlatformManager)&#125;_.prototype.createModel=function()&#123;var t=new n.cModel;return this.models.push(t),t&#125;,_.prototype.changeModel=function(t,e)&#123;this.reloadFlg&amp;&amp;(this.reloadFlg=!1,this.releaseModel(0,t),this.createModel(),this.models[0].load(t,e))&#125;,_.prototype.getModel=function(t)&#123;return t&gt;=this.models.length?null:this.models[t]&#125;,_.prototype.releaseModel=function(t,e)&#123;this.models.length&lt;=t||(this.models[t].release(e),delete this.models[t],this.models.splice(t,1))&#125;,_.prototype.numModels=function()&#123;return this.models.length&#125;,_.prototype.setDrag=function(t,e)&#123;for(var i=0;i&lt;this.models.length;i++)this.models[i].setDrag(t,e)&#125;,_.prototype.tapEvent=function(t,e)&#123;s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;tapEvent view x:&quot;+t+&quot; y:&quot;+e);for(var i=0;i&lt;this.models.length;i++)this.models[i].hitTest(s.cDefine.HIT_AREA_HEAD,t,e)?(this.eventemitter.emit(&quot;tapface&quot;),s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;Tap face.&quot;),this.models[i].setRandomExpression()):this.models[i].hitTest(s.cDefine.HIT_AREA_BODY,t,e)&amp;&amp;(this.eventemitter.emit(&quot;tapbody&quot;),s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;Tap body. models[&quot;+i+&quot;]&quot;),this.models[i].startRandomMotion(s.cDefine.MOTION_GROUP_TAP_BODY,s.cDefine.PRIORITY_NORMAL));return!0&#125;,e.cManager=_&#125;,87:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.PlatformManager=n;var r=i(83),o=i(80);function n()&#123;&#125;n.prototype.loadBytes=function(t,e)&#123;var i=new XMLHttpRequest;i.open(&quot;GET&quot;,t,!0),i.responseType=&quot;arraybuffer&quot;,i.onload=function()&#123;switch(i.status)&#123;case 200:e(i.response);break;default:console.error(&quot;Failed to load (&quot;+i.status+&quot;) : &quot;+t)&#125;&#125;,i.send(null)&#125;,n.prototype.loadString=function(t)&#123;this.loadBytes(t,function(t)&#123;return t&#125;)&#125;,n.prototype.loadLive2DModel=function(t,e)&#123;var i=null;this.loadBytes(t,function(t)&#123;i=o.Live2DModelWebGL.loadModel(t),e(i)&#125;)&#125;,n.prototype.loadTexture=function(t,e,i,o)&#123;var n=new Image;n.crossOrigin=&quot;Anonymous&quot;,n.src=i,n.onload=onload,n.onerror=onerror,n.onload=function()&#123;var i=r.currWebGL,s=i.createTexture();if(!s)return console.error(&quot;Failed to generate gl texture name.&quot;),-1;t.isPremultipliedAlpha()||i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,1),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,1),i.activeTexture(i.TEXTURE0),i.bindTexture(i.TEXTURE_2D,s),i.texImage2D(i.TEXTURE_2D,0,i.RGBA,i.RGBA,i.UNSIGNED_BYTE,n),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR_MIPMAP_NEAREST),i.generateMipmap(i.TEXTURE_2D),t.setTexture(e,s),s=null,&quot;function&quot;==typeof o&amp;&amp;o()&#125;,n.onerror=function()&#123;console.error(&quot;Failed to load image : &quot;+i)&#125;&#125;,n.prototype.jsonParseFromBytes=function(t)&#123;var e,i=new Uint8Array(t,0,3);return e=239==i[0]&amp;&amp;187==i[1]&amp;&amp;191==i[2]?String.fromCharCode.apply(null,new Uint8Array(t,3)):String.fromCharCode.apply(null,new Uint8Array(t)),JSON.parse(e)&#125;,n.prototype.log=function(t)&#123;console.log(t)&#125;&#125;,88:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.cModel=a;var r=i(81),o=i(89),n=i(84),s=i(82),_=i(80);function a()&#123;r.L2DBaseModel.prototype.constructor.call(this),this.modelHomeDir=&quot;&quot;,this.modelSetting=null,this.tmpMatrix=[]&#125;a.prototype=new r.L2DBaseModel,a.prototype.load=function(t,e,i)&#123;this.setUpdating(!0),this.setInitialized(!1),this.modelHomeDir=e.substring(0,e.lastIndexOf(&quot;/&quot;)+1),this.modelSetting=new o.ModelSettingJson;var n=this;this.modelSetting.loadModelSetting(e,function()&#123;var t=n.modelHomeDir+n.modelSetting.getModelFile();n.loadModelData(t,function(t)&#123;for(var e=0;e&lt;n.modelSetting.getTextureNum();e++)&#123;if(/^https?:\\/\\/|^\\/\\//i.test(n.modelSetting.getTextureFile(e)))var o=n.modelSetting.getTextureFile(e);else o=n.modelHomeDir+n.modelSetting.getTextureFile(e);n.loadTexture(e,o,function()&#123;if(n.isTexLoaded)&#123;if(n.modelSetting.getExpressionNum()&gt;0)&#123;n.expressions=&#123;&#125;;for(var t=0;t&lt;n.modelSetting.getExpressionNum();t++)&#123;var e=n.modelSetting.getExpressionName(t),o=n.modelHomeDir+n.modelSetting.getExpressionFile(t);n.loadExpression(e,o)&#125;&#125;else n.expressionManager=null,n.expressions=&#123;&#125;;if(null==n.eyeBlink&amp;&amp;(n.eyeBlink=new r.L2DEyeBlink),null!=n.modelSetting.getPhysicsFile()?n.loadPhysics(n.modelHomeDir+n.modelSetting.getPhysicsFile()):n.physics=null,null!=n.modelSetting.getPoseFile()?n.loadPose(n.modelHomeDir+n.modelSetting.getPoseFile(),function()&#123;n.pose.updateParam(n.live2DModel)&#125;):n.pose=null,null!=n.modelSetting.getLayout())&#123;var _=n.modelSetting.getLayout();null!=_.width&amp;&amp;n.modelMatrix.setWidth(_.width),null!=_.height&amp;&amp;n.modelMatrix.setHeight(_.height),null!=_.x&amp;&amp;n.modelMatrix.setX(_.x),null!=_.y&amp;&amp;n.modelMatrix.setY(_.y),null!=_.center_x&amp;&amp;n.modelMatrix.centerX(_.center_x),null!=_.center_y&amp;&amp;n.modelMatrix.centerY(_.center_y),null!=_.top&amp;&amp;n.modelMatrix.top(_.top),null!=_.bottom&amp;&amp;n.modelMatrix.bottom(_.bottom),null!=_.left&amp;&amp;n.modelMatrix.left(_.left),null!=_.right&amp;&amp;n.modelMatrix.right(_.right)&#125;for(t=0;t&lt;n.modelSetting.getInitParamNum();t++)n.live2DModel.setParamFloat(n.modelSetting.getInitParamID(t),n.modelSetting.getInitParamValue(t));for(t=0;t&lt;n.modelSetting.getInitPartsVisibleNum();t++)n.live2DModel.setPartsOpacity(n.modelSetting.getInitPartsVisibleID(t),n.modelSetting.getInitPartsVisibleValue(t));n.live2DModel.saveParam(),n.preloadMotionGroup(s.cDefine.MOTION_GROUP_IDLE),n.mainMotionManager.stopAllMotions(),n.setUpdating(!1),n.setInitialized(!0),&quot;function&quot;==typeof i&amp;&amp;i()&#125;&#125;)&#125;&#125;)&#125;)&#125;,a.prototype.release=function(t)&#123;var e=r.Live2DFramework.getPlatformManager();t.deleteTexture(e.texture)&#125;,a.prototype.preloadMotionGroup=function(t)&#123;for(var e=this,i=0;i&lt;this.modelSetting.getMotionNum(t);i++)&#123;var r=this.modelSetting.getMotionFile(t,i);this.loadMotion(r,this.modelHomeDir+r,function(r)&#123;r.setFadeIn(e.modelSetting.getMotionFadeIn(t,i)),r.setFadeOut(e.modelSetting.getMotionFadeOut(t,i))&#125;)&#125;&#125;,a.prototype.update=function()&#123;if(null!=this.live2DModel)&#123;var t=2*((_.UtSystem.getUserTimeMSec()-this.startTimeMSec)/1e3)*Math.PI;this.mainMotionManager.isFinished()&amp;&amp;this.startRandomMotion(s.cDefine.MOTION_GROUP_IDLE,s.cDefine.PRIORITY_IDLE),this.live2DModel.loadParam(),this.mainMotionManager.updateParam(this.live2DModel)||null!=this.eyeBlink&amp;&amp;this.eyeBlink.updateParam(this.live2DModel),this.live2DModel.saveParam(),null==this.expressionManager||null==this.expressions||this.expressionManager.isFinished()||this.expressionManager.updateParam(this.live2DModel),this.live2DModel.addToParamFloat(&quot;PARAM_ANGLE_X&quot;,30*this.dragX,1),this.live2DModel.addToParamFloat(&quot;PARAM_ANGLE_Y&quot;,30*this.dragY,1),this.live2DModel.addToParamFloat(&quot;PARAM_ANGLE_Z&quot;,this.dragX*this.dragY*-30,1),this.live2DModel.addToParamFloat(&quot;PARAM_BODY_ANGLE_X&quot;,10*this.dragX,1),this.live2DModel.addToParamFloat(&quot;PARAM_EYE_BALL_X&quot;,this.dragX,1),this.live2DModel.addToParamFloat(&quot;PARAM_EYE_BALL_Y&quot;,this.dragY,1),this.live2DModel.addToParamFloat(&quot;PARAM_ANGLE_X&quot;,Number(15*Math.sin(t/6.5345)),.5),this.live2DModel.addToParamFloat(&quot;PARAM_ANGLE_Y&quot;,Number(8*Math.sin(t/3.5345)),.5),this.live2DModel.addToParamFloat(&quot;PARAM_ANGLE_Z&quot;,Number(10*Math.sin(t/5.5345)),.5),this.live2DModel.addToParamFloat(&quot;PARAM_BODY_ANGLE_X&quot;,Number(4*Math.sin(t/15.5345)),.5),this.live2DModel.setParamFloat(&quot;PARAM_BREATH&quot;,Number(.5+.5*Math.sin(t/3.2345)),1),null!=this.physics&amp;&amp;this.physics.updateParam(this.live2DModel),null==this.lipSync&amp;&amp;this.live2DModel.setParamFloat(&quot;PARAM_MOUTH_OPEN_Y&quot;,this.lipSyncValue),null!=this.pose&amp;&amp;this.pose.updateParam(this.live2DModel),this.live2DModel.update()&#125;else s.cDefine.DEBUG_LOG&amp;&amp;console.error(&quot;Failed to update.&quot;)&#125;,a.prototype.setRandomExpression=function()&#123;var t=[];for(var e in this.expressions)t.push(e);var i=parseInt(Math.random()*t.length);this.setExpression(t[i])&#125;,a.prototype.startRandomMotion=function(t,e)&#123;var i=this.modelSetting.getMotionNum(t),r=parseInt(Math.random()*i);this.startMotion(t,r,e)&#125;,a.prototype.startMotion=function(t,e,i)&#123;var r=this.modelSetting.getMotionFile(t,e);if(null!=r&amp;&amp;&quot;&quot;!=r)&#123;if(i==s.cDefine.PRIORITY_FORCE)this.mainMotionManager.setReservePriority(i);else if(!this.mainMotionManager.reserveMotion(i))return void(s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;Motion is running.&quot;));var o,n=this;null==this.motions[t]?this.loadMotion(t,this.modelHomeDir+r,function(r)&#123;o=r,n.setFadeInFadeOut(t,e,i,o)&#125;):(o=this.motions[t],n.setFadeInFadeOut(t,e,i,o))&#125;else s.cDefine.DEBUG_LOG&amp;&amp;console.error(&quot;Failed to motion.&quot;)&#125;,a.prototype.setFadeInFadeOut=function(t,e,i,r)&#123;var o=this.modelSetting.getMotionFile(t,e);if(r.setFadeIn(this.modelSetting.getMotionFadeIn(t,e)),r.setFadeOut(this.modelSetting.getMotionFadeOut(t,e)),s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;Start motion : &quot;+o),null==this.modelSetting.getMotionSound(t,e))this.mainMotionManager.startMotionPrio(r,i);else&#123;var n=this.modelSetting.getMotionSound(t,e),_=document.createElement(&quot;audio&quot;);_.src=this.modelHomeDir+n,s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;Start sound : &quot;+n),_.play(),this.mainMotionManager.startMotionPrio(r,i)&#125;&#125;,a.prototype.setExpression=function(t)&#123;var e=this.expressions[t];s.cDefine.DEBUG_LOG&amp;&amp;console.log(&quot;Expression : &quot;+t),this.expressionManager.startMotion(e,!1)&#125;,a.prototype.draw=function(t)&#123;n.MatrixStack.push(),n.MatrixStack.multMatrix(this.modelMatrix.getArray()),this.tmpMatrix=n.MatrixStack.getMatrix(),this.live2DModel.setMatrix(this.tmpMatrix),this.live2DModel.draw(),n.MatrixStack.pop()&#125;,a.prototype.hitTest=function(t,e,i)&#123;for(var r=this.modelSetting.getHitAreaNum(),o=0;o&lt;r;o++)if(t==this.modelSetting.getHitAreaName(o))&#123;var n=this.modelSetting.getHitAreaID(o);return this.hitTestSimple(n,e,i)&#125;return!1&#125;&#125;,89:function(t,e,i)&#123;&quot;use strict&quot;;Object.defineProperty(e,&quot;__esModule&quot;,&#123;value:!0&#125;),e.ModelSettingJson=o;var r=i(81);function o()&#123;this.NAME=&quot;name&quot;,this.ID=&quot;id&quot;,this.MODEL=&quot;model&quot;,this.TEXTURES=&quot;textures&quot;,this.HIT_AREAS=&quot;hit_areas&quot;,this.PHYSICS=&quot;physics&quot;,this.POSE=&quot;pose&quot;,this.EXPRESSIONS=&quot;expressions&quot;,this.MOTION_GROUPS=&quot;motions&quot;,this.SOUND=&quot;sound&quot;,this.FADE_IN=&quot;fade_in&quot;,this.FADE_OUT=&quot;fade_out&quot;,this.LAYOUT=&quot;layout&quot;,this.INIT_PARAM=&quot;init_param&quot;,this.INIT_PARTS_VISIBLE=&quot;init_parts_visible&quot;,this.VALUE=&quot;val&quot;,this.FILE=&quot;file&quot;,this.json=&#123;&#125;&#125;o.prototype.loadModelSetting=function(t,e)&#123;var i=this;r.Live2DFramework.getPlatformManager().loadBytes(t,function(t)&#123;var r=String.fromCharCode.apply(null,new Uint8Array(t));i.json=JSON.parse(r),e()&#125;)&#125;,o.prototype.getTextureFile=function(t)&#123;return null==this.json[this.TEXTURES]||null==this.json[this.TEXTURES][t]?null:this.json[this.TEXTURES][t]&#125;,o.prototype.getModelFile=function()&#123;return this.json[this.MODEL]&#125;,o.prototype.getTextureNum=function()&#123;return null==this.json[this.TEXTURES]?0:this.json[this.TEXTURES].length&#125;,o.prototype.getHitAreaNum=function()&#123;return null==this.json[this.HIT_AREAS]?0:this.json[this.HIT_AREAS].length&#125;,o.prototype.getHitAreaID=function(t)&#123;return null==this.json[this.HIT_AREAS]||null==this.json[this.HIT_AREAS][t]?null:this.json[this.HIT_AREAS][t][this.ID]&#125;,o.prototype.getHitAreaName=function(t)&#123;return null==this.json[this.HIT_AREAS]||null==this.json[this.HIT_AREAS][t]?null:this.json[this.HIT_AREAS][t][this.NAME]&#125;,o.prototype.getPhysicsFile=function()&#123;return this.json[this.PHYSICS]&#125;,o.prototype.getPoseFile=function()&#123;return this.json[this.POSE]&#125;,o.prototype.getExpressionNum=function()&#123;return null==this.json[this.EXPRESSIONS]?0:this.json[this.EXPRESSIONS].length&#125;,o.prototype.getExpressionFile=function(t)&#123;return null==this.json[this.EXPRESSIONS]?null:this.json[this.EXPRESSIONS][t][this.FILE]&#125;,o.prototype.getExpressionName=function(t)&#123;return null==this.json[this.EXPRESSIONS]?null:this.json[this.EXPRESSIONS][t][this.NAME]&#125;,o.prototype.getLayout=function()&#123;return this.json[this.LAYOUT]&#125;,o.prototype.getInitParamNum=function()&#123;return null==this.json[this.INIT_PARAM]?0:this.json[this.INIT_PARAM].length&#125;,o.prototype.getMotionNum=function(t)&#123;return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]?0:this.json[this.MOTION_GROUPS][t].length&#125;,o.prototype.getMotionFile=function(t,e)&#123;return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][e]?null:this.json[this.MOTION_GROUPS][t][e][this.FILE]&#125;,o.prototype.getMotionSound=function(t,e)&#123;return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][e]||null==this.json[this.MOTION_GROUPS][t][e][this.SOUND]?null:this.json[this.MOTION_GROUPS][t][e][this.SOUND]&#125;,o.prototype.getMotionFadeIn=function(t,e)&#123;return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][e]||null==this.json[this.MOTION_GROUPS][t][e][this.FADE_IN]?1e3:this.json[this.MOTION_GROUPS][t][e][this.FADE_IN]&#125;,o.prototype.getMotionFadeOut=function(t,e)&#123;return null==this.json[this.MOTION_GROUPS]||null==this.json[this.MOTION_GROUPS][t]||null==this.json[this.MOTION_GROUPS][t][e]||null==this.json[this.MOTION_GROUPS][t][e][this.FADE_OUT]?1e3:this.json[this.MOTION_GROUPS][t][e][this.FADE_OUT]&#125;,o.prototype.getInitParamID=function(t)&#123;return null==this.json[this.INIT_PARAM]||null==this.json[this.INIT_PARAM][t]?null:this.json[this.INIT_PARAM][t][this.ID]&#125;,o.prototype.getInitParamValue=function(t)&#123;return null==this.json[this.INIT_PARAM]||null==this.json[this.INIT_PARAM][t]?NaN:this.json[this.INIT_PARAM][t][this.VALUE]&#125;,o.prototype.getInitPartsVisibleNum=function()&#123;return null==this.json[this.INIT_PARTS_VISIBLE]?0:this.json[this.INIT_PARTS_VISIBLE].length&#125;,o.prototype.getInitPartsVisibleID=function(t)&#123;return null==this.json[this.INIT_PARTS_VISIBLE]||null==this.json[this.INIT_PARTS_VISIBLE][t]?null:this.json[this.INIT_PARTS_VISIBLE][t][this.ID]&#125;,o.prototype.getInitPartsVisibleValue=function(t)&#123;return null==this.json[this.INIT_PARTS_VISIBLE]||null==this.json[this.INIT_PARTS_VISIBLE][t]?NaN:this.json[this.INIT_PARTS_VISIBLE][t][this.VALUE]&#125;&#125;&#125;);//# sourceMappingURL=L2Dwidget.0.min.js.map\n原链接\n","tags":["看板娘"]},{"title":"IDEA自定义注释模版","url":"/2022/10/16/0.3.5-IDEA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E9%87%8A%E6%A8%A1%E7%89%88/","content":"1.配置模板组\n2.填写参数\n** * TODO * @Author:Foam * @Date:$date$ $time$$param$ * @return $return$  **/\n3.设置表达式\nparam表达式groovyScript(&quot;def result=&#x27;&#x27;;def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList();for(i = 0; i &lt; params.size();i++) &#123;result+=&#x27; * @param &#x27; + params[i] + ((i &lt; params.size() - 1) ? &#x27;\\\\n&#x27;:&#x27;&#x27;)&#125;; return result&quot;, methodParameters())\nreturn表达式groovyScript(&quot;def result=&#x27;&#x27;;def params=\\&quot;$&#123;_1&#125;\\&quot;.replaceAll(&#x27;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;&lt;&#x27;).toList();for(i = 0; i &lt; params.size();i++) &#123;if(i!=0)&#123;result+=&#x27;&lt;&#x27;;&#125;;def p1=params[i].split(&#x27;,&#x27;).toList();for(i2 = 0; i2 &lt; p1.size(); i2++) &#123; def p2=p1[i2].split(&#x27;\\\\\\\\.&#x27;).toList(); result+=p2[p2.size()-1]; if(i2!=p1.size()-1)&#123;result+=&#x27;,&#x27;&#125; &#125; ;&#125;; return result&quot;, methodReturnType())\n4.设置触发方式\n5.设置应用范围\n","tags":["idea"]},{"title":"控制xxl-job下次执行时间","url":"/2023/06/06/0.4.1-%E6%8E%A7%E5%88%B6xxl-job%E4%B8%8B%E6%AC%A1%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4/","content":"​\n项目场景：\n目前项目引入了 xxl-job 来跑定时任务，但是存在一个问题，项目执行结束的时间不固定，有峰值，在高峰期的时候会出现长阻塞一直排队等待，如图：\n\n​\n问题描述需要做一种策略来解决长阻塞问题，精准控制下一次执行时间，尽量保证不空档\n原因分析：1.上游接口的接口限流或者峰值压力导致返回超时2.高峰期数据量达到峰值处理不过来3.设置的执行间隔太短，执行不过来\n解决方案：思路  编写一个cron表达式，时间一分钟一次，直接获取当前时间的下一次执行时间，并且更新到xxl-job的执行日志里面\n注意  1.因为设置的1分钟59秒，所以在秒的位置设置了59，防止在59秒执行完更新超时，导致定时任务执行过时间\n  2.xxlJobInfo.setTriggerStatus(1); 设置这个，只需要点击立即执行就可以让它运行，但是后续可能需要加一个开关来控制需要执行的策略是一次或者多次\n  3.在xxl_job_info中schedule_conf是编写cron表达式，但是trigger_next_time才是下次执行时间，需要转为时间戳更新\n实现方法package com.tthk.inland.ticket.core.service.xxlJobInfo.impl; import com.tthk.inland.ticket.core.configurations.druidconfig.DataSource;import com.tthk.inland.ticket.core.entity.xxlJobInfo.XxlJobInfo;import com.tthk.inland.ticket.core.mapper.xxlJobInfo.XxlJobInfoMapper;import com.tthk.inland.ticket.core.service.xxlJobInfo.IXxlJobInfoService;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.tthk.inland.ticket.core.utils.cron.CronUtils;import com.xxl.job.core.context.XxlJobHelper;import lombok.extern.slf4j.Slf4j;import org.springframework.stereotype.Service; import java.text.SimpleDateFormat;import java.util.Date; /** * &lt;p&gt; *  服务实现类 * &lt;/p&gt; * * @author Foam * @since 2023-05-31 */@Slf4j@Servicepublic class XxlJobInfoServiceImpl extends ServiceImpl&lt;XxlJobInfoMapper, XxlJobInfo&gt; implements IXxlJobInfoService &#123;     @DataSource(&quot;xxlJobs&quot;)    public void updateCronTime()&#123;        try&#123;            // 更新下一次cron时间            final var nextTime = CronUtils.getExecutionTimeByNum(&quot;59 0/1 * * * ?&quot;, 1).get(0);            final var nextCron = CronUtils.getCronByTimeString(nextTime);            final var xxlJobInfo = new XxlJobInfo();            xxlJobInfo.setId(74);            xxlJobInfo.setScheduleConf(nextCron);            final var simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            final var nextTimestamp = simpleDateFormat.parse(nextTime);            xxlJobInfo.setTriggerNextTime(nextTimestamp.getTime());            xxlJobInfo.setTriggerStatus(1);            this.updateById(xxlJobInfo);            XxlJobHelper.log(&quot;更新下一次cron时间&quot;+nextCron);        &#125;catch (Exception e)&#123;            log.error(&quot;cron解析异常&quot;,e);        &#125;    &#125;&#125;\n\n工具类package com.tthk.inland.ticket.core.utils.cron; import org.springframework.scheduling.support.CronSequenceGenerator; import java.text.SimpleDateFormat;import java.time.DateTimeException;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.util.*; /** * @Description:cron表达式工具类 * @date:2022/10/8_15:09 * @author:Foam */public class CronUtils &#123;    /**     * 解析cron对应次数     * @Author Foam     * @Date 2023/1/6     * @param cronStr cron 表达式     * @param num 解析最近几次执行时间     * @return List&lt;String&gt; 返回执行时间列表     **/    public static List&lt;String&gt; getExecutionTimeByNum(String cronStr, Integer num) &#123;        CronSequenceGenerator cronSequenceGenerator = new CronSequenceGenerator(cronStr, TimeZone.getTimeZone(&quot;Asia/Shanghai&quot;));        List&lt;String&gt; result = new ArrayList&lt;&gt;(num);        Date date = new Date();        for (Integer integer = 0; integer &lt; num; integer++) &#123;            date = cronSequenceGenerator.next(date);            SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);            String format1 = format.format(date);            result.add(format1);        &#125;        return result;    &#125;     /**     * @Description CN: 字符串解析cron表达式     * @Description EN:     * @Description KR:     * @Author Foam     * @Date 2023/5/29     **/    public static String getCronByTimeString(String times)&#123;        DateTimeFormatter dateTimeFormatter1 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);        // 定义时间        LocalDateTime dateTime = LocalDateTime.parse(times,dateTimeFormatter1);        // 使用DateTimeFormatter格式化时间        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy MM dd HH mm ss&quot;);        String format = dateTime.format(dateTimeFormatter);         // 拆分字符串        String[] dateTimeParts = format.split(&quot; &quot;);         // 构建cron表达式        return String.format(&quot;%s %s %s %s %s ? *&quot;,dateTimeParts[5],dateTimeParts[4],dateTimeParts[3],dateTimeParts[2],dateTimeParts[1],dateTimeParts[0]);    &#125;&#125; \n\n效果\n缺点  1.需要指定执行器id，需要加参数配置，比较麻烦[该配置最好是mysql或者redis，不要配置在param参数中，因为停止会多执行一次]\n  2.不适用集群模式下的任务\n  3.开启和关闭需要用户理解\n​\n","tags":["场景"]},{"title":"Vector","url":"/2023/02/06/0.3.8-Vector/","content":"什么是Vector类似于ArrayList，Vector也是由数组组成，默认的初始化大小是【10】但是Vector是线程安全的，在大多数的方法上面都存在synchronized关键字如果需要进行扩容，每次扩容大小默认为【2】，注意(capacityIncrement &gt; 0)是双括号条件\nVector和ArrayList的区别1.vector默认构造还是饿汉式，而arrayList在1.8后改为了懒汉式2.Vector 是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果，而 ArrayList 不是，这个可以从源码中看出，Vector 类中的方法很多有 synchronized 进行修饰，这样就导致了 Vector 在效率上无法与 ArrayList 相比【第二张图能体现】3.vector可以设置增长因子【默认0】\n以2倍的方式扩容，导致下一次申请的内存必然大于之前分配内存的总和，导致之前分配的内存不能再被使用，所以最好倍增长因子设置为(1,2)之间\n\n\n4.因为考虑到线程安全的问题，效率比较低可以用什么代替VectorCopyOnWriteArrayList 相当于线程安全的ArrayList，它是个可变数组\n\n它是线程安全的\n是通过volatile和监视器锁Synchrnoized来实现的\n\n\n\n\n\n它的List通常保持很小，只读操作大于可变操作，需要在遍历的时候防止线程间冲突\n因为需要复制整个基础数组，所以add,set,remove等可变操作开销大\n在“添加/修改/删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile数组”。这就是它叫做CopyOnWriteArrayList的原因！\n\n\n支持hasNext和next,但是不支持可变remove操作\n\n\n\n使用迭代器进行遍历的速度很快，并且不会与其它线程发生冲突，但是在构造迭代器的时候，迭代器依赖于不变的数组快照\nCOWIterator不支持修改元素的操作。例如，对于remove(),set(),add()等操作，COWIterator都会抛出异常！\n\n\n\n\n","tags":["基础"]},{"title":"秒杀架构","url":"/2023/02/26/0.4.0-%E7%A7%92%E6%9D%80%E6%9E%B6%E6%9E%84/","content":"什么是秒杀（seckill）seckill是一个老生常谈的场景它一般出现在电商系统中，在某些特定的节日，限定特定商品数量以超低折扣进行促销引流按照秒杀的特性，特价商品一般在一两秒内被抢光，剩下的人只会出现售罄页面这一两秒会出现一个瞬间峰值，因为是短暂的活动，不能消耗太多服务器资源，所以需要达到最小代价做到最大的抗压，不直接冲垮服务器，还得保证不超卖，不丢单，不宕机等问题\nseckill需要注意哪些问题幂等\n多次调用方法或者接口不会改变业务状态，可以保证重复调用的结果和单次调用的结果一致\n\n描述\n前端重复提交：前端瞬间点击多次造成表单重复提交\n接口超时重试：接口可能会因为某些原因而调用失败，处于容错性考虑会加上失败重试的机制。如果接口调用一半，再次调用就会因为脏数据的存在而产生异常\n消息重复消费：在使用消息中间件来处理消息队列，且手动ack确认消息被正常消费时。如果消费者突然断开链接，那么已经执行了一半的消息会重新放回队列。被其他消费者重新消费时就会导致结果异常，如数据库重复数据， 数据库数据冲突，资源重复等\n请求重发：网络抖动引发的nginx重发请求，造成重复调用解决方案\n\n\n给前端点击按钮设置点击置灰，等获取到正确结果再进行对应的处理【治标不治本，容易被绕过】\n使用Token机制\n通过Token机制实现接口的幂等性，这是一种比较通用性的实现方法\n\n客户端会先发送一个请求去获取Token，服务端会生成一个全局唯一的UUID作为Token保存在Redis中，同时把这个UUID返回给客户端,并缓存到session\n客户端第二次调用业务请求的时候必须携带这个Token\n服务端会校验这个Token，如果校验成功，则执行业务，并删除Redis中的Token\n如果校验失败，说明Redis中已经没有对应的Token，则表示重复操作，直接返回指定的结果给客户端\n\n\n\n\n注意：\n\n对 redis 中是否存在 token 以及删除的代码逻辑建议用 Lua 脚本或者setNX操作实现，保证原子性\n全局唯一 ID 可以用百度的 uid-generator、美团的 Leaf 去生成,也可以用雪花算法实现\n\n\n削峰（高并发）\n对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值高峰值流量是压垮系统很重要的原因【会造成雪崩效应】，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路\n\n常见削峰方案预约制：用户在提前固定时间内预约使用服务，在预约时间内服务繁忙时不再接受新的请求，以此来削峰。问答式验证：在请求访问服务时要求用户回答一些简单的问题，以此来减少恶意请求，并降低系统的峰值压力。动态限流：根据实时的系统负载情况动态调整请求的限流策略，以此来减少系统的峰值压力。动态分配资源：根据实时的系统负载情况动态分配资源，以此来减少系统的峰值压力。分段限流：将请求分为几个段，分别对每个段设置不同的限流策略，以此来减少系统的峰值压力。\n描述\n服务雪崩：服务提供者不可用导致服务调用者也跟着不可用，以此类推引起整个链路中的所有微服务都不可用\n服务异步：异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程\n资源控制：将整体流程中的资源调度进行控制，扬长避短，防止加载图片，js等静态资源增加服务器压力解决方案首先了解一下什么是CDN平时用户访问的地址是直接指向我们的服务器，中间会经过多层转发，而距离比较远的用户访问我们的服务器可能会有网络拥堵CDN的服务商在各地都有服务器群，可以解析DNS计算距离用户最近的服务器来获取缓存资源，以避免网络拥堵我们可以把静态资源（图片，js，css等）丢到CDN服务商上面，以减少我们的服务器压力【解耦】使用CDN的好处就是不浪费自己服务器资源和带宽，并且响应速度快，直接实现了动静分离现在由于市场需求量大技术日渐成熟，CDN的收费也越来越便宜传统动静分离一般做动静分离主要是为了提高用户访问静态资源的速度，降低直接对后台应用的访问最基本的做法就是用nginx来指向静态资源，因为nginx的吞吐量比tomcat高，响应更快具体可以参考：https://blog.csdn.net/qq_60387497/article/details/121512895负载均衡\n负载均衡的目的是将请求分摊到多台服务器上，从而降低单台服务器的负载，提高系统的吞吐量和响应速度。通常在 Web 应用、数据库应用、邮件服务器、文件服务器等高并发环境中使用负载均衡技术\n\n\n\n常用的负载一般是Nginx，Netflix Ribbon,Netflix Eureka,Apache Zookeeper如果有钱也可以买云服务商的，比如亚马逊，微软，谷歌，阿里巴巴，腾讯云等https://juejin.cn/post/7144621706312613896\n限流网关过滤方案对系统而言，如果我们可以在网关层面拦截掉用户请求，可以说这个方案的性价比很高。要是能在这层过滤 95% 以上的请求，整个系统也就很稳定\n\n限定每个用户的访问频率：比如几秒钟可以下单一次\n限定每个ip的访问频率：这种方式担心有些人通过脚本下单，因此错杀真实用户\n\n算法过滤方案在秒杀模块中，一般使用令牌桶算法或者固定窗口算法一.令牌桶\n\n每次请求需要消耗一个令牌，令牌生成速率是固定的，当令牌桶满时，请求将被阻塞或拒绝\n\nhttps://juejin.cn/post/6969182378845536292可以通过Google Guava 的 RateLimiter 实现了令牌桶算法，它提供了一种简单的方式来限流RateLimiter 支持两种限流方式：\n\n固定速率限流：固定速率限流是指固定每秒生成令牌的速率。例如，当令牌生成速率为 10 个每秒时，第一秒可以生成 10 个令牌，第二秒也可以生成 10 个令牌，以此类推。\nSmoothBursty 限流：SmoothBursty 限流是一种更加灵活的限流方式，它支持在短时间内的高速率限流，在长时间内的更加缓慢的限流。这种算法适用于那些具有短时间内的突发请求和长时间内的平稳请求的场景。例如，在一个时间段内可以生成大量令牌，但在另一个时间段内生成的令牌数可能会变少。\nSmoothBursty 限流算法通过适当地调整令牌生成速率，以适应系统的需求情况，并同时保证在令牌桶中令牌的有效利用。它可以帮助实现更好的资源利用率，同时保证系统的稳定性。\n\n\n\n二.漏桶算法\n\n将请求缓存到漏桶中，漏桶的容量有限，请求以固定速率从漏桶中流出\n\n三.滑动窗口\n\n在一段时间内，对请求数量进行限制，并随时间窗口的滑动而改变限制的数量\n\n四.固定窗口\n\n在固定时间窗口内，对请求数量进行限制\n\n五.随机算法\n\n随机接受或者拒绝\n\n注意：漏桶算法和固定窗口算法都是限流算法，但它们有一些重要的差异：\n\n原理：漏桶算法基于等待请求的思想，即请求被存储在漏桶中直到漏桶中有足够的令牌来处理请求。而固定窗口算法则是通过计算在固定时间窗口内处理的请求数来限制请求数量。\n实现方式：漏桶算法通过设置固定的令牌生成速率和固定的漏桶容量来实现限流。固定窗口算法则是通过维护一个请求数的计数器，并在固定的时间窗口内重置该计数器来实现限流。\n应用场景：漏桶算法适用于处理突发请求，并且请求处理速率相对稳定的场景。固定窗口算法则适用于请求处理速率需要在固定时间窗口内动态调整的场景。\n\n总的来说，漏桶算法和固定窗口算法都是有效的限流算法，选择哪种算法取决于应用场景和限流需求。如果需要处理突发请求，漏桶算法可能更合适；如果需要动态调整请求处理速率，则固定窗口算法可能更合适。\nMQ削峰、异步、解耦为什么使用MQ进行削峰操作\n\n处理高流量请求：当系统请求峰值很高时，可以将所有的请求投递到消息队列中，让后台异步处理请求，减少系统的峰值压力（缓冲请求）\n可靠性：能够有效避免瞬时请求过量，导致的系统不稳定或者数据丢失（系统故障时候也不会丢失消息）\n扩展性：可以有效将请求分散给多个系统处理，提高系统的处理能力，如果消费不过来可以临时加消费者进行处理\n可用性提高：因为是异步处理请求，即使在请求量激增情况也不会出现系统故障，可以灵活调整队列长度和消息生产速率来控制系统消费速度\n\n常见的MQ有ActiveMQ，RocketMQ，RabbitMQ和Kafka使用MQ所需要注意的问题\n\n队列管理：需要管理好队列的长度，避免过长导致的内存溢出\n消息可靠性：需要设置消息的持久化，重试等机制\n消息一致性：需要避免重复消费或者消息丢失\n消息处理能力：需要根据实际需求调整生产速率和消费速率\n资源利用率：需要监控系统资源使用情况，防止宕机\n\n出现死信队列怎么办\n\n死信队列一般是某些消息无法在规定时间内正常处理\n\n\n检查队列的配置：检查消息的存活时间和队列大小，确保它们有足够的内存保存待处理消息\n跟踪消息：查看日志和监控工具，跟踪消息处理的情况，定位问题\n重试：对于一些可以重试的消息，用重试机制重新消费\n恢复数据：在极端情况下，如果遇到无法处理消息，考虑从备份数据中恢复数据\n人工干预：对于特定消息，自动处理不了，就人工干预消费处理\n\nMQ消费不过来怎么办\n\n出现这种情况一般是消息生产过快或者消费端处理能力不足，导致消息积压\n\n\n提高消费端的处理能力：增加机器数量，配置更高的计算资源，代码调优等\n减缓生产速度：可以限制生产者的生产速度，用令牌桶或者漏桶来限制，避免消息积压\n长队列：可以通过分治队列，降低单队列的负荷，缩短消息处理时间\n设置正确的队列长度限制：避免队列过长导致的积压【一般和这个无关】\n\nMQ可靠性消息投递【高可靠必定牺牲性能】\n\nack+重试机制【目前常用】\n\n通过配置confirm的发送确认机制，当消息发送到消费者并且确认收到消息，通知生产者该消息已消费\n\n\n消息多备\n\n在生产者或者broker或者消费者保留一份，当消费者消费成功后再删除【 在消息的传输链路上每个节点冗余消息  】如果 Broker 是集群部署，有多副本机制，即消息不仅仅要写入当前 Broker ,还需要写入副本机中。那配置成至少写入两台机子后再给生产者响应。这样基本上就能保证存储的可靠了。一台挂了另一台还在。\n\n\n事务机制【太消耗性能】\n\n1.将channel设置为事务模式channel.txSelect();2.提交事务channel.txCommit();3.事务回滚channel.txRollback();\n\n\n\n如果消息入队列后MQ宕机此时就需要：持久化，不止消息的持久化，还有队列和Exchange的持久化MQ出现重复消费怎么办\n\n做好幂等性\n失败一定次数就通知人工处理缓存\n秒杀是一个典型的读多写少的应用场景，非常适用缓存【一件商品只有10件的库存，有200w人来抢，实际就只有10个人可以下单成功，其它的都是查询库存】\n\n\n\n缓存可以在秒杀前先缓存商品信息，库存信息和预热用户对该商品的请求，这样可以防止请求直接打到数据库里面，从而提高系统的效率对于读请求，无论是 Memcached 还是 Redis ，单机抗10wQPS问题都不大，在上层的限流，削峰，人机校验，幂等中已经筛选掉了90%的请求，所以真正能打入数据库的数据量是很少的基于Redis实现缓存 Cache-Aside Pattern(旁路缓存模式)\n\n在请求达到后端之后，防止请求直接面向传统数据库【RDBMS】（传统数据库处理读写效果比较慢），一般会做一层NoSQL缓存操作。先去Redis找有没有数据，如果有就返回，没有就去RDBMS里面查询数据，然后存入Redis并返回，方便下次直接从Redis拿到数据\n\n如何保证数据一致性\n\n强一致性：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大弱一致性：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态最终一致性：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型\n\n\n先更新缓存再更新数据库【脏数据】\n\n线程1：先更新缓存成功,但是网络原因写数据库失败，就会导致缓存是最新数据，而数据库的数据为旧数据，那缓存就是脏数据线程2：读取缓存中数据，而这个数据数据库中却不存在，数据库都不存在的数据，缓存并返回客户端就毫无意义了。\n\n先更新数据库，再更新缓存【存在线程安全问题】\n\n线程1：先更新数据库成功，但是由于网络卡顿更新缓存失败，从而导致缓存中的数据为旧数据线程2：从缓存中读取数据，缓存中的数据为旧数，从而导致数据库与缓存数据不一致。\n\n先删除缓存，再更新数据【线程安全问题】\n\n线程1：先删除缓存成功，但是由于网络卡顿原因，更新数据库异常。线程2：读取缓存由于缓存数据为空，则会查询数据库中的数据，查询成功并写入缓存，从而导致数据不一致。\n\n先更新数据库，再删除缓存【短暂不一致问题】\n\n线程1：写入数据库成功，由于网络卡顿原因，导致删除缓存数据失败线程2：读取数据，读取为缓存中的数据，但是当网络恢复正常后，缓存中的数据会被删除，所以可能会存在短暂的数据不一致\n\n延时双删\n\n先删除缓存，再更新数据库，确保数据库事务提交成功，然后休眠一段时间在删除缓存。我们都知道第三种情况是因为网络卡顿导致数据库更新失败，当网络恢复正常后，我们在执行更新数据库操作，然后再删除缓存，那么出现数据不一致的情况也就是在休眠的这短暂的时间内\n\n双删+队列重试机制\n\n在延时双删的方案上引入队列，需要删除失败的key存入消息队列中，采用异步的方式来进行删除，如果删除失败的次数已经超过了最大次数，发送警告邮件，需要人工介入解决【重试机制】\n\n监听binlog日志删除\n\n以 mysql 为例 可以使用阿里的 canal 将 binlog 日志采集发送到 MQ 队列里面，然后通过 ACK 机制确认处理这条更新消息，删除缓存，保证数据缓存一致性如何防止穿透，击穿，雪崩\n\n缓存穿透：请求在redis没命中缓存，在mysql也没有命中，查询失败，当请求量大的时候，一直有这种请求进来就会给数据库很大压力\n\n1.使用布隆过滤器【如果布隆过滤器存在就进行请求，不存在直接进行空值或者失败】2.缓存空对象，并且设置过期时间【缓存失效不宜过长，当数据库数据被写入时候要及时刷新，避免数据不一致的情况出现】3.非法请求校验【前端页面和后台请求参数校验，避免出现非法请求直接打入数据库】4.黑名单【对于请求频率过高不正常的进行黑名单限制】\n\n缓存击穿：大量热点key值同时失效或者单个热点key，在不停抗着大并发，这个key失效的瞬间，大量的请求就会击破缓存，打入数据库\n\n1.使用互斥锁【建议使用Redission分布式锁】，单机可以通过synchronized或者lock来实现，只让一个请求去请求数据库，其它的等待缓存构建后再去请求缓存2.热点key不设置过期时间，后代定时异步更新缓存【适用于弱一致性场景】3.续失效时长，在value内部设置一个比缓存过期时间短的标识，当异步线程发现该值快过期了，用互斥锁内置时间，并且重新去数据库加载该数据\n\n缓存雪崩：当缓存中大量热点缓存同时失效，会导致缓存在某个时间达到峰值，请求全都去请求数据库，导致数据库压力骤增，甚至宕机。从而形成连锁反应，导致系统崩溃\n\n一般是大量热点key同时过期或者缓存服务故障1.热点key随机失效时间，防止同时失效2.分布式锁读数据库3.Redis采用高可用集群（必要时采用异地多活）4.限流，降级，容灾，削峰等措施热点key\n\n请求次数过多，频率过高，又过于集中的一些key\n\n大key（Big Key）\n\nBig Key就是某个key对应的value很大，占用的redis空间很大，本质上是大value问题\n\n原因：\n\nredis数据结构使用不当\n未及时清理垃圾数据\n对业务预估不准\n明星，网红之类的粉丝列表或者热点新闻的评论列表\n\n解决方式：\n\n对大key进行拆分，拆分为小key，然后通过get不同的key或者使用mget批量获取\n对大key进行清理\n监控redis的内存，带宽，超时比例，然后进行预警\n定时清理失效数据，最好加一个时效性\n压缩value，采用序列化或者压缩算法方式将key大小控制，注意序列化和反序列化都会带来消耗\n\n数据预热【提前做好热点探测】\n\n缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。\n\n\n数据量不大的时候，工程启动的时候进行加载缓存动作\n数据量大的时候，设置一个定时任务脚本，进行缓存的刷新\n数据量太大的时候，优先保证热点数据进行提前加载到缓存mysql\n\n数据库同步问题\n\n缓存和数据库一致性问题 在上面已经提及\n\n数据库扩容问题\n\n业务系统在设计初期一般数据量小，会采取单服务+单数据库但是随着访问量上升，为了达到数据库的最佳储存容量，需要对数据库做垂直或者水平拆分，来提升服务响应速度，这时候就涉及到了扩容问题\n\n难点\n\n数据迁移问题\n分片规则的改变\n数据同步，时间点，数据一致性\n\n解决方式\n\n停机扩容【简单方案】\n\n【适用于简单业务，数据库较少的时候】停止服务 -》新增数据库，修改分片规则，迁移数据 -》重启服务优点：简单，停机风险操作低缺点：缺乏高可用，如果没配置好，容易造成数据丢失，难以修复\n\n平滑扩容【大数据量】\n\n【保持高可用】平滑扩容可以实现n库扩容2n库，增加数据库服务能力新增数据库 -》配置双主进行数据同步 -》数据同步完成后配置双主双写 -》删除双主同步，修改数据库配置并重启 -》 清空数据库多余数据优点：不用停机，保持高可用，扩容遇到问题容易解决，不影响线上服务，可以减少每个数据库数据量缺点：程序复杂，数据量大时，代价高https://juejin.cn/post/7166859294615273480#heading-6数据库冷热分离\n\n冷热分离就是在处理数据时，数据库分为冷库和热库冷库：存放那些走到了终态的数据的数据库热库：还需要修改的数据的数据库建议用es或者clickhouse作为冷库，因为冷库一般存储的数据量比较大，es属于数据量越多优势越大的数据库\n\n\n业务识别【简单场景适用】\n\n比如每次更新了订单的状态，就去触发这个逻辑\n\n监听识别【业务代码复杂场景适用】\n\n可通过监听数据库变更日志binlog的方式来触发（数据库触发器也可）\n\n扫表触发【时间区分冷热适用】\n\n数据库定时任务或通过程序定时任务来触发\n超卖少卖问题\njvm级别的锁 Synchronized 是无法在分布式微服务下解决超卖问题，只能解决当前进程的超卖问题这种时候就需要引入分布式锁\n\n\nRedis setnx实现简单分布式锁【不太建议使用】\n\n在redis中有一条命令 setnx (set if not exists)：如果不存在key，则可以设置成功，存在则失败这种情况可以实现普通的分布式锁，但是遇到了极端情况比如断电，超时，宕机等会造成不释放锁或者死锁\n\nredisson 实现分布式锁【建议使用】\n\n在redisson中有一种看门狗机制，可以实现锁续命这是一种已经造好的轮子，开箱即用，它也可以使用多redis实现分布式锁，防止单点故障https://juejin.cn/post/7168727597180780574\n\nRedLock 高可用并发锁（红锁）【不建议使用】\n\nRedLock为了保证高可用，在设置key的时候，会创建多个节点，单节点设置成功不会告诉程序获取到了锁，只有超过半数节点设置成功才会告诉程序获取到了锁https://juejin.cn/post/6983988197420171278\n接口防刷\n顾名思义，想让某个接口某个人在某段时间内只能请求N次。 在项目中比较常见的问题也有，那就是连点按钮导致请求多次，以前在web端有表单重复提交，可以通过token 来解决。 除了上面的方法外，前后端配合的方法。现在全部由后端来控制\n\n\n对比前端请求带来的时间戳，防止出现提前请求\n加ip限制，如果遇到在规定时间内请求多次【一般0.3s内连续两次都是不正常的】，可以直接加入黑名单，比如加入redis给一个被封的时间\nget换成post请求，防止直接通过url点击请求\n利用注解aop做拦截器，设置每秒请求间隔和请求次数https://juejin.cn/post/7109096387886710815https://juejin.cn/post/6844903843516383245\n\n秒杀url隐藏\n隐藏URL并不能完全防止爬虫的恶意攻击，因为这些攻击者可能通过大量的尝试来猜测正确的URL但是加密URL的意义在于增加攻击者猜测到URL的难度，无法轻易拿到正确的URL\n\n\n系统在秒杀的时间点才生成秒杀url地址，在非秒杀时间返回空串，防止提前被知道地址\n通过前端给的商品id+用户id+秒杀开始日期+秒杀结束日期+随机字符串来生成唯一uuid【记得加盐加密】，并且存入redis【60s】，并且返回给前端\n前端拿到uuid进行地址拼接，秒杀固定地址+uuid进行请求\n后端拿到请求地址的uuid，去redis查询有没有过期，没有过期可以进行下一步\n后端在秒杀时候可以通过同ip秒杀频率来进行ip黑名单限制，防止通过工具自动化刷单【防不了动态ip代理】限流熔断\n防止大请求量打入顶不住导致集体宕机\n\n\n\n一般分为监控，限流，熔断监控：对系统的各个关键指标进行监控采集，包括响应时间，请求量，错误率等限流：对系统的并发请求进行限制，控制系统的处理能力，防止系统超负荷运行导致的宕机或者响应变慢，推荐使用guava限流熔断：当服务或者下游出现故障或者网络异常，自动切断该服务的调用，并且返回提前设置好的错误响应，防止服务调用的连锁反应，导致系统崩溃，并且给用户体验不好，推荐使用Hystrix或者Sentinel\n服务降级\n秒杀系统在高并发的情况下，很容易因为大量的请求同时涌入导致服务不可用例如，在秒杀活动开始前，大量用户会提前准备，不断刷新商品页面，导致大量请求涌入系统，使得系统崩溃因此，在秒杀系统中使用服务降级是必要的，以保证系统的可用性和稳定性\n\n当系统出现异常或者超负荷的情况下，通过降低服务质量或者停用部分服务来保证核心服务的可用性\n自动扩缩容\n当请求量过大时，单机无法承受，需要通过自动扩缩容来保证系统的正常运行自动扩缩容是指根据系统的负载情况自动增加或减少系统的节点，以适应不同的负载情况\n\n监控系统通过监控系统实时监控系统的负载情况，当负载超过一定阈值时，自动触发扩容操作，当负载降低时，自动触发缩容操作\n云原生架构在云原生架构中，可以通过云平台提供的自动扩缩容功能来实现秒杀系统的自动扩缩容，例如 Kubernetes 提供了自动扩缩容的功能，可以根据负载情况自动增加或减少容器的数量\n弹性计算通过弹性计算来实现自动扩缩容，例如云服务器 ECS 提供了自动伸缩组的功能，可以根据负载情况自动增加或减少实例的数量\n分布式事务\n下单事务：秒杀下单需要进行扣减库存和创建订单两个操作，这两个操作需要在同一个事务中完成，否则可能会出现库存扣减成功但是订单创建失败的情况。在分布式场景下，可以使用分布式事务来保证这两个操作的原子性，常用的分布式事务解决方案有 TCC、XA、SAGA 等。支付事务：当用户下单成功后需要进行支付，支付也是一个需要保证原子性的操作。在分布式场景下，可以使用分布式事务来保证支付的原子性，但是相比于下单事务更为复杂，因为支付涉及到第三方支付平台的交互，可能需要处理退款等异常情况。\n\n最经典的事务就是数据库事务（ACID）\nA：原子性（Atomicity）一个事务中间执行的操作要么全部成功，要么全部失败，不会结束在某个环节【不可分割的执行单元】事务在执行的过程中如果发生错误，会进行回滚（Rollback）到事务开始前的状态，就像这个事务没有执行过一样\nC：一致性（Consistency）一个事务执行之前和执行之后数据库都必须处于一致性状态，数据库的完整性约束没有被破坏\nI：隔离性（Isolation）事务与事务之间是互相独立的，它们不会互相干扰，一个事务不会影响到另外一个事务的数据，也不会看到另外一个事务的数据\nD：持久性（Durability）当一个事务完成之后，执行的结果必须持久化保存，即使数据库崩溃，在数据库恢复后事务提交的结果仍然存在注意：\n\n事务只能保证数据库的高可靠性，即数据库本身发生问题后，事务提交后的数据仍然能恢复；而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于『高可用性』的范畴。因此，事务只能保证数据库的『高可靠性』，而『高可用性』需要整个系统共同配合实现。\n\n可能出现的问题更新丢失当有两个并发执行的事务，更新同一行数据，那么其中一个事务会覆盖另外一个事务的数据【当数据库没有加任何锁操作的情况下会发生】脏读一个事务读到另外一个未提交事务的数据【当第一个事务回滚时候，第二个事务拿着失效的数据去处理就会出现脏读】不可重复读（虚读，幻读）一个事务对同一行数据读两次，却拿到了不同的结果\n\n虚读：事务1在两次查询的过程中，事务2进行了一次修改，导致事务1读到了不一样的记录\n幻读：事务1在两次查询的过程中，事务2进行了插入，删除操作，导致事务1读取的结果发生了变化\n\n注意：脏读是尚未提交的数据，不可重复读是已提交的数据\n数据库的四种隔离级别读未提交【Read uncommitted】\n一个事务对一行数据修改的过程中，不允许另外一个事务对该行数据进行修改，但是允许读取该行数据\n\n不会出现更新丢失，但是会出现脏读，不可重复读\n读已提交【Read committed】\n未提交的写事务不允许其它事务访问该行，但是读取数据的事务允许其它的事务进行访问该行数据\n\n不会出现脏读，但是会出现不可重复读\n重复读【Repeatable read】\n该级别禁止写事务，但是允许读事务\n\n不会出现不可重复读\n序列化【Serializable】\n所有事务都必须串行执行\n\n能避免一切因为并发引起的问题，但是效率低\n小结隔离级别越高，越能保证数据的完整性和一致性，但是，对于并发性能的影响也越大大多数情况下选择读提交【Read committed】，它能避免脏数据，并且有较好的并发性能，虽然它会导致不可重复读，丢失更新的并发问题，可以通过采用悲观锁或者乐观锁来控制\n分布式事务\n上面的事务介绍的是数据库事务，目前数据库只支持单库事务，不支持跨库事务随着微服务架构的普及，一个大型的业务系统往往是多个服务组成，每个服务都有自己的数据库，现在一整套业务流程走下去需要多个服务来共同完成，这种跨库的事务支持就是“分布式事务”比较常见的就是：商品系统，订单系统，支付系统，积分系统等等\n\nCAP理论（布鲁尔定理）一致性【Consistency】同一数据的多个副本是否相同，所有的变化都是同步的可用性【Availability】在可以接受的时间范围内正确的响应用户请求，请求不能无限被阻塞分区容错性【Partition tolerance】当出现网络分区后，系统还是能继续工作，满足一致性和可用性注意熟悉CAP的人都知道，三者不能共存，一般是AP或者CP\n\n在分布式系统中，网络无法100%可靠，分区其实是一个必然现象如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构\n\nCP放弃可用性，追求一致性和分区容错性，例：Zookeeper就是追求的强一致性\n\n单一节点 或 多个节点处于相同的网络环境下，那么会存在一定的风险，万一该机房断电、该地区发生自然灾害，那么业务系统就全面瘫痪了。为了防止这一问题，采用分布式系统，将多个子系统分布在不同的地域、不同的机房中，从而保证系统高可用性。\n\nAP放弃一致性【这里的一致性是强一致性】，追求分区容错性和可用性，这是很多分布式系统设计时候的选择，后面的BASE理论也是根据AP扩展\n\nBASE解决了CAP中理论没有网络延迟，在BASE中用软状态和最终一致，保证了延迟后的一致性。BASE和 ACID 是相反的，它完全不同于ACID的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。\n\nBASE理论基本可用【Basically Available】在分布式系统中出现故障时，允许损失部分功能，保证核心功能可用【比如延长响应时间】软状态【Soft state】同一数据的不同副本的状态，可以不需要实时一致性【状态可以一段时间不同步】最终一致性【Eventually consistent】经过一段时间后，所有节点数据最后都会达到一致【不是强一致性】注意ACID能够保证事务的强一致性，即数据是实时一致的，在本地事务中是没有问题的，在分布式事务中，强一致性会极大影响分布式系统的性能，因此分布式系统中遵循BASE理论即可但分布式系统的不同业务场景对一致性的要求也不同。如交易场景下，就要求强一致性，此时就需要遵循ACID理论，而在注册成功后发送短信验证码等场景下，并不需要实时一致，因此遵循BASE理论即可。因此要根据具体业务场景，在ACID和BASE之间寻求平衡\n什么时候使用分布式事务一般出现分布式事务的原因就是微服务过多\n\n不同服务之间的调用\n\n随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，举个简单的例子，一个公司之内，用户的资产可能分为好多个部分，比如余额，积分，优惠券等等。在公司内部有可能积分功能由一个微服务团队维护，优惠券又是另外的团队维护\n\n数据库不在同一个地区\n\n我们的Mysql一般来说装千万级的数据就得进行分库分表，对于一个支付宝的转账业务来说，你给的朋友转钱，有可能你的数据库是在北京，而你的朋友的钱是存在上海，所以我们依然无法保证他们能同时成功。因为事务会增加系统的复杂度，并且会导致响应变慢，这样的成本实在是太高了，不要因为追求某些设计，而引入不必要的成本\n常见的分布式事务解决方案2PC【二段式提交】\n\n第一阶段：事务管理器通知所有资源管理器进行预备【prepare】，如果收到就绪状态则进入下一步，有一个未就绪则回滚第二阶段：事务管理器收到所有资源管理器都准备完毕，通知资源管理器进行提交操作，如果有一个失败则进行回滚\n\n优点：尽量的保证了数据的强一致性，实现成本低，现在各大主流数据库都有自己的实现缺点：\n\n单点问题：如果在第一阶段完成，第二阶段正准备提交的时候出现事务管理器宕机，资源管理器就会存在一直阻塞状态，导致数据库无法使用【需要备机进行容错】\n同步阻塞：在准备就绪后，资源管理器是出于阻塞状态，当提交完成才释放资源，其它第三方节点范围公共资源的时候就得处于阻塞等待状态\n数据不一致：在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性\n\n3PC【三段式提交】\n\n三段提交（3PC）是对两段提交（2PC）的一种升级优化，3PC在2PC的第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC 还是没能从根本上解决数据一致性的问题。\n\n3PC 的三个阶段分别是CanCommit、PreCommit、DoCommitCanCommit：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。\n\n3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回Yes响应，否则返回No响应。\n\n事务询问 协调者向参与者发送CanCommit请求。询问是否可以执行事务提交操作。然后开始等待参与者的响应。\n响应反馈 参与者接到CanCommit请求之后，正常情况下，如果其自身认为可以顺利执行事务，则返回Yes响应，并进入预备状态。否则反馈No\n\n\nPreCommit：协调者向所有参与者发送PreCommit命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回Yes响应，进入最终commit阶段。一旦参与者中有向协调者发送了No响应，或因网络造成超时，协调者没有接到参与者的响应，协调者向所有参与者发送abort请求，参与者接受abort命令执行事务的中断。\n\n协调者根据参与者的反应情况来决定是否可以记性事务的PreCommit操作。根据响应情况，有以下两种可能。 假如协调者从所有的参与者获得的反馈都是Yes响应，那么就会执行事务的预执行。\n\n发送预提交请求 协调者向参与者发送PreCommit请求，并进入Prepared阶段。\n事务预提交 参与者接收到PreCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。\n响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。\n\n\n假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。\n\n\n发送中断请求 协调者向所有参与者发送abort请求。\n中断事务 参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。\n\n\nDoCommit： 在前两个阶段中所有参与者的响应反馈均是YES后，协调者向参与者发送DoCommit命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送abort请求命令，执行事务的中断。TCC【二段式提交，补偿型】\n\nTCC【Try-Confirm-Cancel】又被称为补偿事务，TCC与2PC的思想很相似，事务处理流程也很相似，但是2PC应用于DB层面，TCC则应用于应用层面，需要编写业务逻辑来实现它的核心思想：针对每个操作都要注册一个与其对应的确认（try）和补偿（cancel）\n\nTry阶段：尝试执行，完成所有的业务检查（一致性），预留必须业务资源（准隔离性）Confirm阶段：确认执行业务，不做任何业务检查，只使用try阶段预留的业务资源，Confirm阶段需要满足幂等性要求幂等设计，失败后进行重试或者其它处理Cancel阶段：取消执行，释放try阶段预留的业务资源，并进行回滚小结：\n\n解决了协调者单点问题，由主业务方发起并且完成这个业务\n解决同步阻塞问题，可以引入超时，超时后进行补偿，这样不会锁定整个资源，将资源转为业务逻辑形式，粒度变小\n数据一致性问题，有了补偿机制，业务层可以控制一致性\n\n缺点是应用侵入性强，每个操作都需要try-confirm-cancel，其次开发难度大，代码量多，需要保证幂等性和数据一致性【对于程序员水平要求较高】\nMQ事务本地消息表：将需要分布式处理的任务通过消息日志的方式进行异步执行。消息日志可以存储到本地文本，数据库或者消息队列，再通过业务规则自动或者人工发起重试本地消息表对应的是BASE理论，追求的是最终一致性，适用于对一致性要求不高的MQ事务就是本地消息表的升级版中间如果存在消息确认失败或者没有确认的情况，会进行一个重试机制，需要保证幂等\n中间件推荐Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。AT模式是阿里首推的模式,阿里云上有商用版本的GTS(Global Transaction Service 全局事务服务)官网:seata.io/zh-cn/index…源码: github.com/seata/seata官方Demo: github.com/seata/seata…\n防止黄牛\n黄牛为什么难防\n\n模拟器作弊：模拟硬件设备，可以修改设备信息\n设备牧场作弊：工作室里面一大批移动设备同时抢\n人工作弊：靠佣金吸引兼职人员刷单\n\n\n解决方案：\n\n验证码，验证码符合91原则，90%时间都用在验证码输入上，如果使用自动化工具会降低影响\n代码混淆，url隐藏，防止黄牛通过提前解析js来找到后端接口\nip黑名单，对于同一个ip请求频率过多的直接拉黑，或者引入黄牛专用秒杀通道（现在秒杀，有很多可以通过频率来区分黄牛还是真人，然后负载到不同的服务器，让黄牛和黄牛抢，真人和真人抢，只是黄牛的通道里面秒杀的数量少于真人数量）\n限购，每个用户只能购买一台【遇到牧场作弊的可能防不住，但是同网络的情况可以防】\n风控系统，给每个用户做一个用户画像，打一个可疑度分数，来进行不同负载区分以及限流秒杀时序图秒杀流程图秒杀架构微服务架构【参考用】参考\n\nhttps://cloud.tencent.com/developer/article/1762003\nhttps://blog.51cto.com/u_8238263/6020353#:~:text=使用%E2%80%8B%20%E2%80%8BToken%E2%80%8B%20%E2%80%8B%E2%80%8B机制，或使用%E2%80%8B%20%E2%80%8BToken%E2%80%8B%20%E2%80%8B%20%2B%20分布式锁的方案来解决幂等性问题%E3%80%82,4-幂等性解决方案实现思路%204-1-%20Token机制实现%20通过%E2%80%8B%20%E2%80%8BToken%E2%80%8B%20%E2%80%8B%20机制实现接口的幂等性，这是一种比较通用性的实现方法%E3%80%82\nhttps://blog.csdn.net/a419240016/article/details/117236135\nhttps://blog.csdn.net/wyouwd1/article/details/125705646\nhttps://blog.csdn.net/qq_65567681/article/details/127712631\nhttps://blog.csdn.net/weixin_35835508/article/details/112668412\nhttps://www.cnblogs.com/hanease/p/15863393.html\nhttps://juejin.cn/post/7112466891335008270\nhttps://juejin.cn/post/6998416509026435108\nhttps://blog.csdn.net/qq1309664161/article/details/118650154\nhttps://juejin.cn/post/7126188464713760776#heading-7\nhttps://juejin.cn/post/6862875289786662926\nhttps://juejin.cn/post/6844903933182214151#heading-3\nhttps://juejin.cn/post/6844903843516383245\nhttps://juejin.cn/post/6844904087390011405#heading-5\nhttps://juejin.cn/post/6844903573667446797#heading-13\nhttps://juejin.cn/post/6844903647197806605#heading-15\nhttps://juejin.cn/post/6899645923024355336#heading-1\nhttps://juejin.cn/post/6844904176430874632\nhttps://juejin.cn/post/6992767837702111269\nhttps://juejin.cn/post/7044032901662375949#heading-10\n","tags":["中间件","场景"]},{"title":"规则枚举","url":"/2023/06/06/0.4.2-%E8%A7%84%E5%88%99%E6%9E%9A%E4%B8%BE/","content":"规则枚举一些简单的猜想实现，用来去除ifelse或者switch，虽然在jdk17中已经引入了新的switch语法，但是还是想做一些尝试\npackage com.tthk.inland.ticket.core.enums.czloworder;import lombok.AllArgsConstructor;import lombok.Getter;import java.util.Arrays;/** * @author Foam * @Description 枚举 * @date 2023/5/4 17:12 */@Getter@AllArgsConstructorpublic enum LowOrderEnums &#123;    UNLIMITED(&quot;枚举1&quot;)&#123;        @Override        public boolean check(Integer id) &#123;            return id&lt;1;        &#125;    &#125;,    ENUM2(&quot;枚举2&quot;)&#123;        @Override        public boolean check(Integer id) &#123;            return id &gt;= 1 &amp;&amp; id &lt; 3;        &#125;    &#125;,    ENUM3(&quot;枚举3&quot;)&#123;        @Override        public boolean check(Integer id) &#123;            return id &gt; 3;        &#125;    &#125;;    private String name;    public abstract boolean check(Integer id);    public static String getEnums(Integer id)&#123;        return Arrays.stream(LowOrderEnums.values()).filter(x -&gt; x.check(id)).findFirst().map(LowOrderEnums::getName).orElse(id+&quot;&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(getEnums(1));        System.out.println(getEnums(2));        System.out.println(getEnums(3));        System.out.println(getEnums(4));    &#125;&#125;\npackage com.tthk.inland.ticket.core.enums.czloworder;import lombok.AllArgsConstructor;import lombok.Getter;import java.util.Arrays;import java.util.function.Predicate;/** * @author Foam * @Description 枚举 * @date 2023/5/4 17:12 */@Getter@AllArgsConstructorpublic enum LowOrderEnums &#123;    UNLIMITED(x -&gt; x &lt; 1,&quot;枚举1&quot;),    ENUM2(x -&gt; x &gt;= 1 &amp;&amp; x &lt; 3,&quot;枚举2&quot;),    ENUM3(x -&gt; x &gt; 3,&quot;枚举3&quot;);    private Predicate&lt;Integer&gt; accumulator;    private String name;    public static String getEnums(Integer id)&#123;        return Arrays.stream(LowOrderEnums.values()).filter(x -&gt; x.getAccumulator().test(id)).findFirst().map(LowOrderEnums::getName).orElse(&quot;没匹配到&quot;);    &#125;    public static void main(String[] args) &#123;        System.out.println(getEnums(1));        System.out.println(getEnums(2));        System.out.println(getEnums(3));        System.out.println(getEnums(4));    &#125;&#125;\n","tags":["工具类","枚举"]},{"title":"JVM的组成","url":"/2022/10/14/0.3.3-JVM%E7%9A%84%E7%BB%84%E6%88%90/","content":"Java Virtual Machine虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现，java虚拟机有自己完善的硬件架构，如处理器，堆栈，寄存器等，还具有相应的指令系统\n一次编译，到处运行Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行\n开篇程序在执行之前，先要把Java代码编译成字节码（.class文件），JVM首先需要把字节码通过类加载器把文件加载到内存中的运行时数据区中。因为字节码文件是JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要执行引擎将字节码翻译成底层系统指令再交由CPU去执行，而这个过程中需要调用本地库接口来实现整个程序的功能。我们通常所说的JVM组成指的是运行时数据区，因为通常需要程序员调试分析的区域就是运行时数据区，或者更具体地说是运行时数据区里面的堆（Heap）模块。\n完整构成\n基本构成\n类加载器-ClassLoaderClassLoader 负责加载字节码文件即 class 文件class 文件在文件开头有特定的文件标示\n\n魔数：0X CA FE BA BE（）如果一个文件不是以0xCAFEBABE 开头的，那它肯定不是java class文件\n\nClassLoader 只负责class 文件的加载，至于它是否可以运行，则由 Execution Engine 决定。\n执行引擎-Execution Engine执行引擎，也叫 Interpreter。Class 文件被加载后，会把指令和数据信息放入内存中，Execution Engine 则负责把这些命令解释给操作系统，即将 JVM 指令集翻译为操作系统指令集。\n本地接口-Native Interface本地接口的作用是融合不同的编程语言为Java 所用，初衷是融合C/C++ 程序它的作用是调用不同语言的接口给 JAVA 用（现在主要是一些硬件交互），它会在 Native Method Stack 中记录对应的本地方法，然后调用该方法时就通过 Execution Engine 加载对应的本地 lib（本地方法库-native libraies）原本多用于一些专业领域，如JAVA驱动，地图制作引擎等，现在关于这种本地方法接口的调用已经被类似于Socket通信，WebService等方式取代。\n运行时数据区-Runtime Data AreaRuntime Data Area 是存放数据的，分为五部分：Stack（虚拟机栈），Heap（堆），Method Area（方法区），PC Register（程序计数器），Native Method Stack（本地方法栈）几乎所有的关于 Java 内存方面的问题，都是集中在这块\n线程私有的内存区域\n程序计数器（Program Counter Register）它是一块较小的内存空间（可能位于cpu的寄存器，有待确认），可以看做是当前字节码指令执行的行号指示器，记录了当前正在执行的虚拟机字节码指令地址，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，比如分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是说在任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。每个线程都有各自独立的程序计数器，注意如果正在执行的是 Native方法，则程序计数器为空（Undifined），并且 JVM 规范中并没有对程序计数器定义 OutOfMemoryError 异常。\n虚拟机栈（VM Stack）虚拟机栈也是线程私有的，它描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。虚拟机栈帧中，局部变量表是比较为人所熟知的，也就是平常所说的“栈”，局部变量表所需的内存空间在编译期间分配完成，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。生命周期与线程相同，不存在垃圾回收，线程结束，内存释放虚拟机栈有两种异常情况：\n\nStackOverflowError：线程请求的栈深度大于虚拟机所允许的深度，特别是方法的递归调用时（有空程序模拟一下）\nOutOfMemoryError：虚拟机栈无法满足线程所申请的空间需求，即使经过动态扩展仍然无法满足时抛出（有空程序模拟一下）\n\n\n本地方法栈（Native Method Stack）本地方法栈与虚拟机栈相似，区别是虚拟机栈为执行 Java 方法服务，而本地方法栈则为 Native 方法服务，有些虚拟机将这两个区域合二为一。\n\n在Execution Engine执行引擎执行时，通过Native Interface 本地接口调用已登记的native library\n本地方法栈中抛出异常的情况与虚拟机栈相同，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常\n\n使用场景：与一些底层系统如操作系统或某些硬件交换信息，如打印机\n线程共享的内存区域\n堆（Heap）对于java应用程序来讲，堆是jvm所管理的内存中最大的一块。是被所有线程共享的一块区域，并在虚拟机启动时创建。此区域的唯一目的就是存放对象实例，java程序里“几乎”所有的对象实例都会在这里创建并分配内存。\n\n所有的对象实例以及数组都应当在堆上分配\n\n堆也是垃圾收集器所管理的主要区域，因此很多时候也被称作GC堆。\n从内存回收的角度来看由于现在收集器基本都采用分代收集算法，因此堆还可以被细分为：新生代和老年代。再继续细分可以分为：Eden空间、From Survivor空间（s0）、To Survivor空间(s1)等\n从内存分配的角度来看线程共享的堆中还可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）堆可以是物理上不连续的空间，只要逻辑上是连续的即可，-Xmx和-Xms参数可以控制堆的最大和最小值\n\n堆的空间大小不满足时将抛出OutOfMemoryError异常方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等数据。Java虚拟机规范将方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆）,目的应该是与java堆区分开来。误区：方法区不等于永久代\n很多人原因把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是HotSpot虚拟机垃圾回收器团队把GC分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在Jdk8也移除了“永久代”，使用Native Memory来实现方法区\n\n\n\n在方法区中有一部分区域用来存储编译期产生的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。这里需要说明一点，常量并不是只能在编译期产生，运行期间也会产生新的常量并被发在常量池中，如 String 类的 intern() 方法。方法区同样会抛出OutOfMemoryError异常\n直接内存注意直接内存不属于虚拟机运行时数据区的一部分，也不是 JVM 规范中定义的内存区域，其主要用于 JDK1.4 引入的基于通道(Channel)和缓冲区(Buffer)的 NIO 类，可以避免在 Native 堆和 Java 堆之间来回复制数据从而提高性能。该部分内存分配不受 Java 堆内存大小的限制，但是肯定也受限于机器硬件内存的限制，在设置虚拟机参数的时候，不能忽略直接内存，把实际内存设置为-Xmx，使得内存区域的总和大于物理内存的限制，从而导致动态扩展时出现OutOfMemoryError异常。\n栈帧构成（Stack Frame）\n一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现\n\n每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息，方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性中了，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体虚拟机的实现。当前栈帧一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是最有效的,称为当前栈帧(Current Stack Frame),与这个栈帧相关联的方法称为当前方法。执行引擎运行的所有的字节码指令都只针对当前栈帧进行操作\n局部变量表（Local Variable Table）局部变量表(Local Variable Table)是一组变量值存贮空间，用于存放方法参数和方法内定义的局部变量在Java程序编译为Class文件时候，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量局部变量表的容量以变量槽为最小单位\n变量槽（Variable Slot）每个变量槽都可以存储32位长度的内存空间，例如boolean、byte、char、short、int、float、reference和returnAddress对于64位长度的数据类型（long，double），虚拟机会以高位对齐方式为其分配两个连续的Slot空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。为了节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超过了某个变量的作用域，那么这个变量对应的Slot就可以交给其他变量使用。这种机制有时候会影响垃圾回收行为（如大方法占用较多的Slot，执行完该方法的作用域后没有对Slot赋值或者清空设置null值，垃圾回收器便不能及时的回收该内存）如果执行的是实例方法，那局部变量表中第 0 位索引的 Slot 默认是用于传递方法所属对象实例的引用（在方法中可以通过关键字 this 来访问到这个隐含的参数）jvm不会给局部变量赋初始值，只给全局变量赋初始值。\n操作数栈（Operand Stack）操作数栈（Operand Stack）也常称为操作栈，是一个后入先出栈。在Class 文件的Code 属性的 max_stacks 指定了执行过程中最大的栈深度。Java 虚拟机的解释执行引擎称为”基于栈的执行引擎“，这里的栈就是指操作数栈。\n\n当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法执行的过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈 / 入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其它方法的时候是通过操作数栈来进行参数传递的\n\n\njvm对操作数栈的优化在概念模型中，两个栈帧是相互独立的。但是大多数虚拟机的实现都会进行优化，令两个栈帧出现一部分重叠。令下面的部分操作数栈与上面的局部变量表重叠在一块，这样在方法调用的时候可以共用一部分数据，无需进行额外的参数复制传递操作栈调用其它有返回结果的方法时，会把结果 push 到栈上（通过操作数栈来进行参数传递）\n动态链接（Dynamic Linking）每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。\n返回地址（Return Address）当一个方法开始执行以后，只有两种方法可以退出当前方法：\n\n当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。\n当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。\n\n当方法返回时，可能进行3个操作：\n\n恢复上层方法的局部变量表和操作数栈\n把返回值压入调用者调用者栈帧的操作数栈\n调整 PC 计数器的值以指向方法调用指令后面的一条指令附加信息（Additional information）虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息。帧数据区（Frame Data）帧数据区的大小依赖于 JVM 的具体实现这部分的作用主要有三部分：\n\n\n常量池中数据的解析\n方法运行完后处理方法返回，恢复调用方现场\n方法运行过程中抛出异常时的异常处理，存储有一个异常表，当出现异常时虚拟机查找相应的异常表看是否有相应的Catch语句，假设没有就抛出异常终止这种方法调参考https://java.jverson.com/jvm/jvm-components.htmlhttps://baijiahao.baidu.com/s?id=1720844278862268813&amp;wfr=spider&amp;for=pchttps://blog.csdn.net/wendyyanan/article/details/104261162https://www.cnblogs.com/jhxxb/p/11001238.htmlhttps://juejin.cn/post/6844903655796113421\n\n","tags":["jvm"]},{"title":"定义either类","url":"/2023/06/06/0.4.3-%E5%AE%9A%E4%B9%89either%E7%B1%BB/","content":"定义either类\n在我们日常开发中，stream流里面如果出现了异常是没法直接抛出的，需要进行try-catch进行捕获然后进行处理，或者干脆直接抛出异常停止\n\n这个时候我们需要一个either工具类，区分成功和失败的执行结果，并且单独对失败的这些结果进行处理，以下是一些简单的实现\npackage com.tthk.inland.ticket.core.utils.stream;import java.util.List;import java.util.Random;import java.util.stream.Collectors;import java.util.stream.Stream;/** * @Description either类 * @date 2023/4/20_15:05 * @author Foam */public class Either&lt;L, R&gt; &#123;    public static void main(String[] args) &#123;        List&lt;EitherUtil&lt;String,String&gt;&gt; collect = Stream.iterate(1, i -&gt; i + 1).limit(100).map(Either::readline).collect(Collectors.toList());        EitherUtil&lt;String, List&lt;String&gt;&gt; sequence = EitherUtil.sequence(collect, (s1, s2) -&gt; s1 + s2);        if(sequence.isLeft())&#123;            System.out.println(sequence.getLeft());        &#125;else&#123;            List&lt;String&gt; right = sequence.getRight();            for (String s : right) &#123;                System.out.println(s);            &#125;        &#125;    &#125;    public static EitherUtil&lt;String,String&gt; readline(int i)&#123;        if((new Random().nextInt() %2) &gt;= 0)&#123;            return EitherUtil.right(&quot;成功&quot;);        &#125;else &#123;            return EitherUtil.left(&quot;错误&quot;);        &#125;    &#125;&#125;\npackage com.tthk.inland.ticket.core.utils.stream;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import java.util.List;import java.util.function.BinaryOperator;import java.util.function.Function;import java.util.stream.Collectors;/** * @Description either工具类 * @date 2023/4/20_15:12 * @author Foam */@Data@AllArgsConstructor@NoArgsConstructorpublic class EitherUtil&lt;L,R&gt; &#123;    /**     * @Description 异常数据     * @date 2023/4/20     **/    private L left;    /**     * @Description 正常数据     * @date 2023/4/20     **/    private R right;    public boolean isLeft()&#123;        return left != null;    &#125;    public boolean isRight()&#123;        return right != null;    &#125;    /**     * @Description 工厂方法 - 左值     * @date 2023/4/20     **/    public static &lt;L,R&gt; EitherUtil&lt;L,R&gt; left(L exception)&#123;        EitherUtil&lt;L,R&gt; e = new EitherUtil&lt;L,R&gt;();        e.left = exception;        return e;    &#125;    /**     * @Description 工厂方法 - 右值     * @date 2023/4/20     **/    public static &lt;L,R&gt; EitherUtil&lt;L,R&gt; right(R value)&#123;        EitherUtil&lt;L,R&gt; e = new EitherUtil&lt;L,R&gt;();        e.right = value;        return e;    &#125;    /**     * @Description map方法，如果是异常值，进行保存，如果是正常值，进行函数映射     * @date 2023/4/20     **/    public &lt;T&gt; EitherUtil&lt;L,T&gt; map(Function&lt;R,T&gt; function)&#123;        if(isLeft())&#123;            return left(left);        &#125;else &#123;            return right(function.apply(right));        &#125;    &#125;    /**     * @Description 将either的list转换成一个either对象，里面分别装正常值和异常值     * @date 2023/4/20     **/    public static &lt;L,R&gt; EitherUtil&lt;L, List&lt;R&gt;&gt; sequence(List&lt;EitherUtil&lt;L,R&gt;&gt; eitherList, BinaryOperator&lt;L&gt; accumulator)&#123;        if(eitherList.stream().allMatch(EitherUtil::isRight))&#123;            // 将所有数据存入            return right(eitherList.stream().map(EitherUtil::getRight).collect(Collectors.toList()));        &#125;else &#123;            // 结合需求，确定是取第一个异常还是取全部异常            // 1.取第一个异常//            return left(eitherList.stream().filter(EitherUtil::isLeft).findFirst().orElseThrow().getLeft());            // 2.取全部异常            return left(eitherList.stream().filter(EitherUtil::isLeft).map(EitherUtil::getLeft).reduce(accumulator).orElseThrow());        &#125;    &#125;    /**     * @Description 获取所有的异常数据     * @date 2023/4/20     **/    public static &lt;L,R&gt; EitherUtil&lt;L, List&lt;R&gt;&gt; sequenceLift(List&lt;EitherUtil&lt;L,R&gt;&gt; eitherList, BinaryOperator&lt;L&gt; accumulator)&#123;        return left(eitherList.stream().filter(EitherUtil::isLeft).map(EitherUtil::getLeft).reduce(accumulator).orElseThrow());    &#125;&#125;\n","tags":["工具类"]},{"title":"limiter限流","url":"/2023/06/06/0.4.4-limiter%E9%99%90%E6%B5%81/","content":"limiter限流单机限流思路介绍采用 Google 的 Guava 中的 RateLimiter.create 来进行令牌桶的分发，但是我们需要动态控制限流的速率，所以在这上面利用单例模式的“ 双重检查锁 ”和 “懒汉式”来进行动态创建\n&lt;dependency&gt;\t\t&lt;groupId&gt;com.google.guava&lt;/groupId&gt;\t\t&lt;artifactId&gt;guava&lt;/artifactId&gt;\t\t&lt;version&gt;20.0&lt;/version&gt;&lt;/dependency&gt;\npackage com.tthk.inland.ticket.core.utils.limiters;import com.google.common.util.concurrent.RateLimiter;import lombok.extern.slf4j.Slf4j;import java.util.Optional;/** * @Description CN: 利用guava令牌桶限流【单机限流】 * @Description EN: Use the Guava token-bucket to limit the service * @Description KR: Guava 토큰 버킷을 사용하여 서비스 제한 * @Author Foam * @Date 2023/5/6 **/@Slf4jpublic class GuavaRateLimiterUtils &#123;    /**     * @Description CN: 默认速率     * @Description EN: Default rate     * @Description KR: 기본 비율     **/    private final static Integer DEFAULT_RATE = 80;    private static RateLimiter instance = null;    private GuavaRateLimiterUtils()&#123;&#125;    /**     * @Description CN: 初始化令牌桶     * @Description EN: Initialize the Guava token-bucket     * @Description KR: Guava 토큰 버킷 초기화     * @Author Foam     * @Date 2023/5/6     * @param rate 限流速率【每秒生产的token】 RateLimiter: Tokens produced per second     * @return boolean true: 限流中 limiting | false: 未限流 pass     **/    public static boolean initRateLimiter(Integer rate)&#123;        try&#123;            Integer limiter = Optional.ofNullable(rate).orElse(DEFAULT_RATE);            if(instance == null || limiter.equals(DEFAULT_RATE))&#123;                synchronized (GuavaRateLimiterUtils.class)&#123;                    if(instance == null || limiter.equals(DEFAULT_RATE))&#123;                        // 创建令牌桶 Create token-bucket                        instance = RateLimiter.create(limiter);                    &#125;                &#125;            &#125;            if(!instance.tryAcquire(1))&#123;                log.info(&quot;限流中&quot;);                return true;            &#125;        &#125;catch (Exception e)&#123;            log.info(e.getMessage());        &#125;        return false;    &#125;&#125;\n分布式限流思路介绍采用 Redis 队列实现滑动窗口的方式来进行限流，利用 Redis 的 SETNX 特性来加分布式锁，保证执行顺序\n&lt;!--redisson--&gt;&lt;dependency&gt;\t\t&lt;groupId&gt;org.redisson&lt;/groupId&gt;\t\t&lt;artifactId&gt;redisson&lt;/artifactId&gt;\t\t&lt;version&gt;2.9.3&lt;/version&gt;&lt;/dependency&gt;\npackage com.tthk.inland.ticket.core.utils.limiters;import lombok.extern.slf4j.Slf4j;import org.redisson.Redisson;import org.redisson.api.RLock;import org.redisson.api.RedissonClient;import org.redisson.config.Config;import java.util.concurrent.TimeUnit;/** * @Description CN: Redis链接工具类 * @Description EN: Redis links the tool class * @Description KR: Redis 는 도구 클래스를 연결합니다 * @Author Foam * @Date 2023/5/6 **/@Slf4jpublic class RedisLinkUtils &#123;    // Redis link    private static volatile RedissonClient redissonClient;    // redis地址 Redis url    private static final String URL = &quot;&quot;;    // 端口 Redis port    private static final String PORT = &quot;&quot;;    // redis密码 Redis password    private static final String PASSWORD = &quot;&quot;;    // 对应DB Redis DB    private static final Integer DB = 17;    // Limit dequeue name    public final static String TASK_NAME = &quot;REDIS_LIMIT&quot;;    // Lock name    public final static String TASK_LOCK = &quot;REDIS_LOCK&quot;;    /**     * @Description CN: 获取redis客户端     * @Description EN: Get redis client     * @Description KR: Redis 클라이언트 가져오기     * @Author Foam     * @Date 2023/5/6     * @return RedissonClient     **/    public static RedissonClient getRedissonClient()&#123;        if(redissonClient == null)&#123;            synchronized (RedisLinkUtils.class)&#123;                if(redissonClient == null)&#123;                    Config config = new Config();                    config.useSingleServer().setAddress(&quot;redis://&quot;+URL+&quot;:&quot;+PORT)                            .setPassword(PASSWORD)                            .setDatabase(DB);                    redissonClient = Redisson.create(config);                    // 清空队列 Queue clear                    redissonClient.getBlockingDeque(TASK_NAME).clear();                &#125;            &#125;        &#125;        return redissonClient;    &#125;    /**     * @Description CN: 分布式锁     * @Description EN: Distributed locking     * @Description KR: 분산 잠금     * @Author Foam     * @Date 2023/5/6     * @param waitTime 等待时间（锁续命）     * @param leaseTime 强制解锁时间     * @return boolean true: 锁定 lock false：未锁定 unlock     **/    public static boolean acquireSecond(Integer waitTime, Integer leaseTime)&#123;        try &#123;            RLock myLock = redissonClient.getLock(TASK_LOCK);            return myLock.tryLock(waitTime, leaseTime, TimeUnit.SECONDS);        &#125; catch (InterruptedException e) &#123;            log.info(e.getMessage());        &#125;        return false;    &#125;    /**     * @Description CN: 解锁     * @Description EN: Release lock     * @Description KR: 잠금 해제     * @Author Foam     * @Date 2023/5/6     **/    public static void release()&#123;        if(redissonClient != null) &#123;            RLock myLock = redissonClient.getLock(TASK_LOCK);            if(myLock != null)&#123;                myLock.unlock();            &#125;        &#125;    &#125;&#125;\npackage com.tthk.inland.ticket.core.utils.limiters;import lombok.extern.slf4j.Slf4j;import java.util.*;/** * @Description CN: Redis 滑动窗口限流 * @Description EN: Redis sliding window throttling * @Description KR: * @Author Foam * @Date 2023/5/6 **/@Slf4jpublic class RedisRateLimiterUtils &#123;    /**     * @Description CN: 默认速率     * @Description EN: Default rate     * @Description KR: 기본 비율     **/    private final static Integer DEFAULT_RATE = 80;    private final static Long timeout = 1L;    /**     * @Description CN: 初始化滑动窗口限流     * @Description EN: Initialize sliding window current limiting     * @Description KR: 슬라이딩 윈도우 전류 제한 초기화     * @Author Foam     * @Date 2023/5/6     * @param rate 速率     * @return Boolean true:限流中 false:未限流     **/    public static Boolean initRateLimiter(Integer rate)&#123;        Long currentTimeMillis = System.currentTimeMillis();        Integer limiter = Optional.ofNullable(rate).orElse(DEFAULT_RATE);        Deque&lt;Long&gt; stack = RedisLinkUtils.getRedissonClient().getBlockingDeque(RedisLinkUtils.TASK_NAME);        try&#123;            if(stack.size() &gt;= limiter)&#123;                // 获取分布式锁 Get distributed lock                if(RedisLinkUtils.acquireSecond(1,2))&#123;                    // 获取最早时间 Get the earliest time                    Long firstTime = Optional.ofNullable(stack.peekFirst()).orElse(currentTimeMillis);                    if((currentTimeMillis - firstTime) &lt; (timeout * 1000))&#123;                        // 在限流时间内 During the current limit time                        log.info(&quot;限流中&quot;);                        return true;                    &#125;                    // 弹出最早时间 Poll the earliest queue                    while (stack.size() &gt;= limiter)&#123;                        stack.pollFirst();                    &#125;                    // 分布式解锁 Release distributed lock                    RedisLinkUtils.release();                &#125;else &#123;                    // 未获取到分布式锁，限流！The distributed lock not obtained,current limit                    log.info(&quot;未获取到分布式锁，限流！&quot;);                    return true;                &#125;            &#125;        &#125;catch (Exception e)&#123;            log.info(e.getMessage());        &#125;        // 尾端插入当前时间戳 The trailer inserts the current timestamp        RedisLinkUtils.getRedissonClient().getBlockingDeque(RedisLinkUtils.TASK_NAME).offerLast(currentTimeMillis);        return false;    &#125;    public static void main(String[] args) throws InterruptedException &#123;        for (int i = 0; i &lt; 100; i++) &#123;            while (initRateLimiter(1))&#123;                Thread.sleep(300);            &#125;;            System.out.println(i+&quot;次&quot;);        &#125;    &#125;&#125;\n","tags":["工具类"]},{"title":"http工具类统一封装","url":"/2023/06/06/0.4.5-http%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85/","content":"http工具类统一封装\n个人封装使用，仅供参考,用来捕获接口异常，并且通知到企业微信\n\npackage com.tthk.inland.ticket.core.utils.https;import cn.hutool.http.HttpRequest;import cn.hutool.http.HttpResponse;import com.alibaba.fastjson.JSONObject;import com.tthk.framework.base.api.dto.CommonResult;import com.tthk.inland.ticket.core.enums.result.ResulEnum;import com.tthk.inland.ticket.core.enums.wechat.WeChatEnums;import com.tthk.inland.ticket.core.utils.wechat.WeChatRobotUtils;import com.xxl.job.core.context.XxlJobHelper;import java.lang.reflect.Type;/** * @Description 请求状态通知工具类 * @date 2023/4/13_17:08 * @author Foam */public class RequestStatusNotify &#123;    /**     * @Description 封装返回结果     * @date 2023/4/13     **/    public static &lt;T&gt; CommonResult&lt;T&gt; requestStatusNotify(HttpRequest request,Class&lt;? extends T&gt; aClass,Type type)&#123;        final var execute = request.execute();        if(execute.getStatus() != 200)&#123;            XxlJobHelper.log(&quot;接口调用失败&quot;);\t\t\t// 微信通知            WeChatRobotUtils.pushNotice(&quot;【&quot;+execute.getStatus()+&quot;】接口调用失败:&quot;+request.getUrl(), WeChatEnums.WARN);            return CommonResult.error(ResulEnum.INTERFACE_FALT.getErrorCode());        &#125;else &#123;            T o = null;            if(aClass != null)&#123;                o = JSONObject.parseObject(execute.body(), aClass);            &#125;            if(type != null)&#123;                o = JSONObject.parseObject(execute.body(), type);            &#125;            XxlJobHelper.log(execute.getStatus()+&quot;接口调用结果：&quot;+JSONObject.toJSONString(o));            // 封装返回结果            return CommonResult.success(o);        &#125;    &#125;    public static &lt;T&gt; CommonResult&lt;T&gt; requestStatusNotify(HttpRequest request,Type type)&#123;        return requestStatusNotify(request,null,type);    &#125;    public static &lt;T&gt; CommonResult&lt;T&gt; requestStatusNotify(HttpRequest request,Class&lt;? extends T&gt; aClass)&#123;        return requestStatusNotify(request,aClass,null);    &#125;&#125;\n使用方法\npublic static final String SPECIAL_PRICE_URL = APP_OPER_URL + &quot;/AppOper/GetPrice&quot;;    public static CommonResult&lt;B2CSpecialPriceVO&gt; getB2CSpecialPrice(B2CSpecialPriceDTO b2CSpecialPriceDTO)&#123;        final var body = HttpRequest.get(SPECIAL_PRICE_URL).form(EntityUtils.entityToMap(b2CSpecialPriceDTO));        return RequestStatusNotify.requestStatusNotify(body, new TypeReference&lt;CommonResult&lt;B2CSpecialPriceVO&gt;&gt;()&#123;&#125;.getType());    &#125;\n","tags":["工具类"]},{"title":"实体类转MAP工具类","url":"/2023/06/06/0.4.6-%E5%AE%9E%E4%BD%93%E7%B1%BB%E8%BD%ACMAP%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"实体类转MAP工具类package com.tthk.inland.ticket.core.utils.other;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class EntityUtils &#123;\t/**\t * \t * @description 实体类转Map\t */\tpublic static Map&lt;String, Object&gt; entityToMap(Object object) &#123;\t\tMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();\t\tfor (Field field : object.getClass().getDeclaredFields()) &#123;\t\t\ttry &#123;\t\t\t\tboolean flag = field.isAccessible();\t\t\t\tfield.setAccessible(true);\t\t\t\tObject o = field.get(object);\t\t\t\tmap.put(field.getName(), o);\t\t\t\tfield.setAccessible(flag);\t\t\t&#125; catch (Exception e) &#123;\t\t\t\te.printStackTrace();\t\t\t&#125;\t\t&#125;\t\treturn map;\t&#125;\t/**\t * \t * @description Map转实体类\t * @param map    需要初始化的数据，key字段必须与实体类的成员名字一样，否则赋值为空\t * @param entity 需要转化成的实体类\t */\tpublic static &lt;T&gt; T mapToEntity(Map&lt;String, Object&gt; map, Class&lt;T&gt; entity) &#123;\t\tT t = null;\t\ttry &#123;\t\t\tt = entity.newInstance();\t\t\tfor (Field field : entity.getDeclaredFields()) &#123;\t\t\t\tif (map.containsKey(field.getName())) &#123;\t\t\t\t\tboolean flag = field.isAccessible();\t\t\t\t\tfield.setAccessible(true);\t\t\t\t\tObject object = map.get(field.getName());\t\t\t\t\tif (object != null &amp;&amp; field.getType().isAssignableFrom(object.getClass())) &#123;\t\t\t\t\t\tfield.set(t, object);\t\t\t\t\t&#125;\t\t\t\t\tfield.setAccessible(flag);\t\t\t\t&#125;\t\t\t&#125;\t\t\treturn t;\t\t&#125; catch (InstantiationException | IllegalAccessException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t\treturn t;\t&#125;&#125;\n","tags":["工具类"]},{"title":"服务构造静态引用","url":"/2023/06/06/0.4.7-%E6%9C%8D%E5%8A%A1%E6%9E%84%E9%80%A0%E9%9D%99%E6%80%81%E5%BC%95%E7%94%A8/","content":"构造静态引用我们有些静态工具类中如果需要使用到service，这个时候引入就会有问题，如下所示\npackage com.tthk.inland.ticket.core.utils.statistic;import com.tthk.inland.ticket.core.utils.redis.RedisUtil;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class StaticRedisTemplateComponet &#123;    @Autowired    private RedisUtil redisUtil;    private static void test()&#123;        redisUtil.get(&quot;test&quot;);    &#125;&#125;\n有时候我们在静态方法里面无法使用@Autowired引入的bean，因为有加载顺序问题会报错\n// 这一行的 redisUtil 会爆红redisUtil.get(&quot;test&quot;);\n这个时候我们就需要单独去实例化这个引用，并且变成默认的静态方法如下：\npackage com.tthk.inland.ticket.core.utils.statistic;import com.tthk.inland.ticket.core.configurations.activemq.QueueProducerService;import com.tthk.inland.ticket.core.utils.redis.RedisUtil;import lombok.RequiredArgsConstructor;import org.springframework.stereotype.Component;import javax.annotation.PostConstruct;@Component@RequiredArgsConstructorpublic class StaticRedisTemplateComponet &#123;    private final QueueProducerService queueProducerService;    private final RedisUtil redisUtil;    private static QueueProducerService staticQueueProducerService;    private static RedisUtil staticRedisUtil;    @PostConstruct    public void init() &#123;        staticQueueProducerService = this.queueProducerService;        staticRedisUtil = this.redisUtil;    &#125;    public static RedisUtil getStaticRedisTenService() &#123;        return staticRedisUtil;    &#125;    public static QueueProducerService getStaticQueueProducerService() &#123;        return staticQueueProducerService;    &#125;&#125;\n这样我们就可以用get方法来进行获取\nStaticRedisTemplateComponet.getStaticRedisTenService().get(&quot;tt_interface_switch&quot;,10);\n第二种方法，比较原始@Autowired会根据bean里面注册的name来进行搜索，如果获取到了，则进行赋值\nprivate static ZXSearchNewService_new zxSearchNewService_new;private static QueueProducerService messageService;@Autowiredpublic zxSearch(QueueProducerService queueProducerService,ZXSearchNewService_new zxSearchNewService_new) &#123;    zxSearch.zxSearchNewService_new = zxSearchNewService_new;    zxSearch.messageService = queueProducerService;&#125;\n","tags":["工具类"]},{"title":"枚举工具类判断包含关系","url":"/2023/06/06/0.4.8-%E6%9E%9A%E4%B8%BE%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%A4%E6%96%AD%E5%8C%85%E5%90%AB%E5%85%B3%E7%B3%BB/","content":"package com.tthk.inland.ticket.core.enums.order;import lombok.AllArgsConstructor;import lombok.Getter;import java.util.Arrays;/** * @Description 重试状态枚举 * @date 2023/4/7_15:04 * @author Foam */@Getter@AllArgsConstructorpublic enum RetryEnum &#123;    SYS_ERROR(&quot;系统错误，请您稍后重试&quot;),    SYS_ERROR_01(&quot;系统开了一个小差&quot;);    private String type;    /**     * @Description 判断是否需要进行重试，true：需要，false：不需要     * @date 2023/4/7     **/    public static Boolean needRetry(String value) &#123;        return Arrays.stream(RetryEnum.values()).anyMatch(e -&gt; value.contains(e.type));    &#125;&#125;\n\n测试方法\npackage com.tthk.inland.ticket.core.account;import com.tthk.inland.ticket.core.enums.order.RetryEnum;import lombok.extern.slf4j.Slf4j;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;/** * @Description 订单测试类 * @date 2023/4/7_15:11 * @author Foam */@SpringBootTest@Slf4jpublic class OrderTest &#123;    /**     * @Description 测试重试枚举是否可用     * @date 2023/4/7     **/    @Test    public void testEnums() &#123;        System.out.println(                RetryEnum.needRetry(&quot;系统开了一个小差~请稍后重试&quot;)        );    &#125;&#125;\n","tags":["工具类"]},{"title":"柔性可用和刚性可用","url":"/2023/06/06/0.4.9-%E6%9F%94%E6%80%A7%E5%8F%AF%E7%94%A8%E5%92%8C%E5%88%9A%E6%80%A7%E5%8F%AF%E7%94%A8/","content":"简述这两个词汇一般出现在事务当中刚性可用又称为刚性事务，也就是我们经常见到的”强一致性”，ACID理论柔性可用又称为柔性事务，也就是我们经常见到的”最终一致性”，BASE理论\n前言进入主题之前，我们先简单聊一下事务在编程中，事务是指作为单个工作单元执行的一系列操作，用于确保数据库或者其它系统中数据的一致性和完整性而事务通常具有四个属性（ACID）：\n\n原子性（Atomicity）\n\n事务的原子性是指事务必须是一个原子的操作序列单元任何一项操作失败都将导致整个事务失败，同时其他已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成要么成功，要么失败\n\n\n一致性（Consistency）\n\n事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处于一致性状态事务执行的结果必须是使数据库从一个一致性状态转变到另一个一致性状态\n\n\n隔离性（Isolation）\n\n事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰\n\n\n持久性（Durability）\n\n事务的持久性也被称为永久性，是指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的一旦某个事务成功结束，那么它对数据库所做的更新就必须被永久保存下来——即使发生系统崩溃或机器宕机等故障，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态\n\n\n\n刚性可用正常我们的单体服务，只要满足ACID，它都是刚性可用的\n柔性可用随着业务的扩展，我们的服务需要进行跨服务间进行调用，并且用户量开始上升\n为什么我们要用柔性可用\n我们的系统不再绝对可靠，开始出现了宕机，网络波动（故障）\n系统的成本预算也不够，为了系统能稳定运行，在设计的时候可能会进行容灾（资源冗余），但是这种冗余不是无限度的，成本在哪里，当遇到超过冗余的流量，照样会出现问题\n\n当条件有限而不能向用户提供完美服务的时候，可以用柔性有损的服务，最大程度的保证关键服务可用性通常有损的服务所需的成本会低于完美服务，相应的体验也较差，所以在系统设计时需要平衡二者的关系，尽量提供高等级服务我们常见的”BASE理论”就是最经典的柔性可用，TCC补偿型事务和MQ通知型事务\nBASE理论在分布式系统中，一般有三个指标，简称：CAP理论CAP理论Consistency 一致性：读写操作后的值必须一直Avaliability 可用性：收到请求必须在规定时间内给出回应Partition tolerance 分区容错性：在不同地区可以进行通信\n\n分布式系统中，网络本身无法做到100%可靠，有可能出现故障所以C和A无法同时做到\n\n具体来说，当分布式系统遇到网络分区（即节点之间的通信中断）时，必须在一致性（CP）和可用性（AP）之间进行选择。如果选择保证一致性，那么在网络分区期间，系统将无法提供服务，即不可用。如果选择保证可用性，那么在网络分区期间，系统将无法保证数据的一致性。什么是BASE理论BASE理论本质上是对CAP的延伸和补充，更具体地说，是对CAP中AP方案的一个补充Basically Available 基本可用：系统应始终可用，即使面临网络分区或者其它故障Soft State 软状态：系统允许存在中间状态，该中间状态不会影响系统整体可用性Eventual Consistency 最终一致性：系统最终的结果会变得一致，但不是立刻一致\n柔性可用的实现步骤要实现柔性可用的系统，需要在产品设计和技术实现两个阶段都有柔性的意识\n\n服务分级\n\n在产品设计阶段，需要对服务的应用场景进行还原要清楚地认识到哪些服务是系统的核心服务，哪些服务是支撑服务（这不单单是从重要性进行分级，还要考虑，有些服务是需要实时完成还是可以离线完成后延迟同步）\n\n\n自身能力评估\n\n在产品设计阶段，要了解自己拥有的资源，对自己的负载能力有较好的评估简单的说，就是要清楚在各种条件下，自己能提供什么样的服务\n\n\n系统划分\n\n在技术实现初期（系统设计），需要遵循大系统小做的原则，对系统进行拆分，避免各个服务互相影响，降低子模块耦合性\n\n\n自我监控\n\n系统要有自我监控能力，了解当前负载，评估是否需要提供降级服务\n\n\n降级服务\n\n满足降级条件时，分级提供柔性服务\n\n\n系统恢复\n\n当系统重新满足可以提供完美服务的条件时，升级服务等级（有能力时，还应该对之前放弃的局部服务进行恢复）\n\n\n\n参考：https://blog.csdn.net/jokeMqc/article/details/127503412https://blog.csdn.net/weixin_39582708/article/details/113911252https://cloud.tencent.com/developer/article/1339887https://www.jianshu.com/p/a555d9cef983\n","tags":["工具类"]},{"title":"面向对象设计原则","url":"/2023/06/06/0.5.0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/","content":"\n面向对象【Object Oriented】四大特性：封装，继承，抽象，多态\n\n一份好的对象设计，往往是以对象为中心，充分利用接口和多态来停供灵活性【应对变化，提高复用】\n目标可扩展性\n\n有了新的需求，新的性能可以容易添加到系统中，不影响现有的性能，也不会带来新的缺陷\n\n可修改性\n\n系统一部分的代码要修改时不会破坏系统的现有结构，也不会影响到其它的部分\n\n可替换性\n\n可以将系统中的某些代码替换为相同接口的其它类，不会影响到系统\n\n七大设计原则\n\n\n设计原则名称\n定 义\n使用频率\n\n\n\n单一职责原则(Single Responsibility  Principle, SRP)\n一个类只负责一个功能领域中的相应职责\n★★★★☆\n\n\n开闭原则(Open-Closed Principle, OCP)\n软件实体应对扩展开放，而对修改关闭\n★★★★★\n\n\n里氏代换原则(Liskov Substitution  Principle, LSP)\n所有引用基类对象的地方能够透明地使用其子类的对象\n★★★★★\n\n\n依赖倒转原则(Dependence Inversion  Principle, DIP)\n抽象不应该依赖于细节，细节应该依赖于抽象\n★★★★★\n\n\n接口隔离原则(Interface Segregation  Principle, ISP)\n使用多个专门的接口，而不使用单一的总接口\n★★☆☆☆\n\n\n合成复用原则(Composite Reuse Principle,  CRP)\n尽量使用对象组合，而不是继承来达到复用的目的\n★★★★☆\n\n\n迪米特法则(Law of Demeter, LoD)\n一个软件实体应当尽可能少地与其他实体发生相互作用\n★★★☆☆\n\n\n单一职责原则\n单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小\n单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责  并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验\n\n单一职责原则原则的核心含意是：只能让一个类/接口/方法有且仅有一个职责。违反单一职责原则\npackage com.weirdo.principle.singleResponsibility;public class SingleResponsibility1 &#123;    public static void main(String[] args) &#123;        Vehicle vehicle = new Vehicle();        vehicle.run(&quot;摩托车&quot;);        vehicle.run(&quot;汽车&quot;);        vehicle.run(&quot;飞机&quot;);    &#125;        //交通工具类    static class Vehicle&#123;        public void run(String vehicle)&#123;            System.out.println(vehicle+&quot;在公路上运行...&quot;);        &#125;    &#125;&#125;\n遵循单一职责原则【类级】\npackage com.weirdo.singleResponsibility;public class SingleResponsibility2 &#123;    public static void main(String[] args) &#123;        RoadVehicle roadVehicle = new RoadVehicle();        roadVehicle.run(&quot;摩托车&quot;);        roadVehicle.run(&quot;汽车&quot;);        AirVehicle airVehicle = new AirVehicle();        airVehicle.run(&quot;飞机&quot;);    &#125;    static class RoadVehicle &#123;        public void run(String vehicle) &#123;            System.out.println(vehicle + &quot;在公路上运行...&quot;);        &#125;    &#125;    static class AirVehicle &#123;        public void run(String vehicle) &#123;            System.out.println(vehicle + &quot;在天上上运行...&quot;);        &#125;    &#125;&#125;\n遵循单一职责原则【方法级】\npackage com.weirdo.singleResponsibility;public class SingleResponsibility3 &#123;    public static void main(String[] args) &#123;        Vehicle  vehicle = new Vehicle();        vehicle.runAir(&quot;飞机&quot;);        vehicle.runRoad(&quot;汽车&quot;);        vehicle.runWater(&quot;航母&quot;);    &#125;    static class Vehicle &#123;        public void runRoad(String vehicle) &#123;            System.out.println(vehicle + &quot;在公路上运行...&quot;);        &#125;        public void runAir(String vehicle) &#123;            System.out.println(vehicle + &quot;在公路上运行...&quot;);        &#125;        public void runWater(String vehicle) &#123;            System.out.println(vehicle + &quot;在水里运行...&quot;);        &#125;    &#125;&#125;\n注意点：\n\n降低类的复杂度，一个类只负责属于自己的职责\n\n提高类的可读性，可维护性\n\n通常情况下，只有在逻辑足够简单的时候才可以违反单一职责原则，因为过度设计会导致物极必反\n开闭原则\n开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则\n\n抽象化是开闭原则的关键\n\n\nhttps://juejin.cn/post/6979029066296852511https://juejin.cn/post/6844904051868434446https://juejin.cn/post/7087483087403089934\n","tags":["基础"]},{"title":"jenkins三种部署方式","url":"/2023/08/31/0.5.1-jenkins%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/","content":"Jenkins 是一款开源 CI&amp;CD 软件\n持续集成(CI)持续集成是指多名开发这在开发不同功能代码的过程中，可以频繁的将代码合并到一起并且相互不影响工作。持续集成是在版本控制的基础上，通过频繁的代码提交、自动化构建和单元测试加快集成周期和问题反馈速度，从而及时验证系统可用性。为了保证后续的系统质量，在持续集成过程中，还会加入代码规范扫描、安全漏洞扫描、集成测试等活动，用来保证代码形成过程符合质量要求。持续集成的频率达到每天多次、频繁的集成，可以提前发现问题尽早解决冲突，使后续的持续集成更顺畅。\n持续部署(CD)持续部署是基于某种工具或者平台实现代码自动化的构建、测试和部署到线上环境以实现交付高质量的产品，持续部署在某种程度上代表一个开发团队的更新迭代速率。持续部署并不特指通过质量验证的制品自动部署到生产环境的特定环节。在持续集成过程中不断生成可执行的制品，需要尽快验证是否存在功能性能等方面的问题，或者尽可能快速的让最终用户可以使用这些功能。通过持续部署到测试环境、准生成环境中，可以使测试团队尽快开始测试，开发团队获得快速的反馈并响应。使研发和测试的协同加快了进程。通过持续部署到生产环境，让最终用户可见，则可以快速获得最终用户的使用反馈，体现需求的市场价值。\n持续交付(CO)从在不同角色的角度对交付进行解读会有不同含义。对于产品研发团队来说，产品的版本更新迭代和交付，版本通过各阶段测试达到可提供给客户使用的状态即为可交付。对于项目实施团队来说，持续交付是要将客户要求实现的功能部署到客户的生产环境，通过验收即为交付。对于最终用户来说，持续交付是最终用户可以使用相关的功能即为交付。持续交付是指持续的将各类变更（包括新功能、缺陷修复、配置变化、实验等）安全、快速、高质量地落实到生产环境或用户手中的能力。持续交付的能力通过自动化流水线的方式实现，减少研发过程中不必要的浪费，近而缩短整个研发过程中所有需求的交付周期。持续交付是一个整体过程，从一个业务端的想法到系统功能可以面对客户的全流程。\n\n1、jenkins触发式构建：用于开发环境部署，开发人员push代码或者合并代码到gitlab项目的master分支，jenkins就部署代码到对应服务器。\n2、jenkins参数化构建：用于测试环境预上线环境部署，开发push代码或者合并代码到gitlab项目的master分支之后，并不会部署代码，而是需要登录到jenkins的web界面，点击构建按钮，传入对应的参数（比如参数需要构建的tag，需要部署的分支）然后才会部署。\n3、jenkins定时构建：用于APP自动打包，定时构建是在参数化构建的基础上添加的，开发人员可以登录jenkins手动传入tag进行打包，如果不手动打包，那么jenkins就每天凌晨从gitlab拉取最新的APP代码打包。\n","tags":["DevOps"]},{"title":"Spring AI打造自己的LLM应用","url":"/2025/01/16/0.5.3-SpringAI%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84LLM%E5%BA%94%E7%94%A8/","content":"\nSpring AI是Spring官方推出的AI框架，为Java开发者提供了原生的AI开发体验。本文将带你从零开始，掌握Spring AI的核心概念和Spring Boot集成技巧，打造属于自己的AI应用。\n\nSpring AI简介Spring AI是Spring官方推出的AI框架，专门为Java和Spring开发者设计，提供了一套简洁、直观且符合Spring生态的AI开发API。它集成了多种主流的AI模型和服务，让开发者能够轻松构建AI驱动的应用。\n为什么选择Spring AI？\nSpring生态完美集成：无缝集成Spring Boot、Spring Cloud等\n官方维护：Spring官方项目，质量保证\n简洁的API：直观的编程模型，学习成本低\n企业级支持：完整的生产环境特性支持\n多模型支持：支持OpenAI、Azure OpenAI、Ollama等多种模型\n工具集成：内置丰富的工具和增强器\n社区活跃：Spring社区强大的支持\n\n核心组件详解1. ChatClient（聊天客户端）ChatClient是Spring AI的核心组件，提供简洁的聊天交互API。\n@Configurationpublic class AiConfig &#123;    @Bean    public ChatClient chatClient(ChatClient.Builder builder) &#123;        return builder            .defaultAdvisors(new SimpleLoggerAdvisor())            .build();    &#125;&#125;// 使用示例@Servicepublic class ChatService &#123;    private final ChatClient chatClient;    public ChatService(ChatClient chatClient) &#123;        this.chatClient = chatClient;    &#125;    public String chat(String message) &#123;        return chatClient.prompt()            .user(message)            .call()            .content();    &#125;    public String chatWithSystem(String systemMessage, String userMessage) &#123;        return chatClient.prompt()            .system(systemMessage)            .user(userMessage)            .call()            .content();    &#125;&#125;\n\n2. Prompt Templates（提示词模板）Spring AI提供了丰富的提示词模板支持。\n@Servicepublic class PromptService &#123;    public String generatePrompt(String role, String question, String language) &#123;        return &quot;&quot;&quot;            你是一个专业的%s，请回答以下问题：            %s            请用%s回答。            &quot;&quot;&quot;.formatted(role, question, language);    &#125;    // 使用PromptTemplate    public String chatWithTemplate(String role, String question) &#123;        PromptTemplate template = new PromptTemplate(&quot;&quot;&quot;            你是一个专业的&#123;role&#125;，请详细解释：            &#123;question&#125;            请提供具体示例和最佳实践。            &quot;&quot;&quot;);        return chatClient.prompt(template)            .user(Map.of(&quot;role&quot;, role, &quot;question&quot;, question))            .call()            .content();    &#125;&#125;\n\n3. Advisors（增强器）Advisor是Spring AI中用于增强AI响应的机制。\n@Configurationpublic class AdvisorConfig &#123;    // 日志增强器    @Bean    public Advisor loggingAdvisor() &#123;        return new SimpleLoggerAdvisor();    &#125;    // 自定义增强器    @Bean    public Advisor customAdvisor() &#123;        return new DefaultPromptAugmentor() &#123;            @Override            public AdvisedRequest adviseRequest(AdvisedRequest request, Map&lt;String, Object&gt; context) &#123;                // 在请求前添加自定义逻辑                String enhancedUserMessage = &quot;请详细回答以下问题，并提供示例：\\n&quot; + request.user().text();                return AdvisedRequest.from(request)                    .withUser(enhancedUserMessage)                    .build();            &#125;        &#125;;    &#125;    // 速率限制增强器    @Bean    public Advisor rateLimitAdvisor() &#123;        return new RateLimitChatMemoryAdvisor(Duration.ofMinutes(10), 50);    &#125;&#125;\n\n4. Function Callbacks（函数调用）Spring AI支持工具调用，让AI能够执行特定任务。\n// 定义工具类public class SearchTools &#123;    @Tool(description = &quot;搜索互联网信息&quot;)    public String searchWeb(String query) &#123;        // 这里实现搜索逻辑        return &quot;搜索 &#x27;&quot; + query + &quot;&#x27; 的结果...&quot;;    &#125;    @Tool(description = &quot;计算数学表达式&quot;)    public double calculate(String expression) &#123;        try &#123;            // 使用JavaScript引擎计算            ScriptEngineManager manager = new ScriptEngineManager();            ScriptEngine engine = manager.getEngineByName(&quot;JavaScript&quot;);            return ((Number) engine.eval(expression)).doubleValue();        &#125; catch (Exception e) &#123;            return 0.0;        &#125;    &#125;    @Tool(description = &quot;获取当前时间&quot;)    public String getCurrentTime() &#123;        return LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);    &#125;&#125;// 配置函数调用@Configurationpublic class FunctionConfig &#123;    @Bean    public FunctionCallbackContext functionCallbackContext() &#123;        FunctionCallbackContext context = new FunctionCallbackContext();        // 注册工具        context.addCallback(&quot;searchWeb&quot;, new FunctionCallback() &#123;            @Override            public String call(String input) &#123;                return new SearchTools().searchWeb(input);            &#125;        &#125;);        return context;    &#125;&#125;// 在ChatClient中使用@Servicepublic class FunctionCallService &#123;    public String chatWithTools(String message) &#123;        return chatClient.prompt()            .user(message)            .functions(&quot;searchWeb&quot;, &quot;calculate&quot;, &quot;getCurrentTime&quot;)            .call()            .content();    &#125;&#125;\n\n5. Vector Store（向量存储）Spring AI支持多种向量存储，用于实现RAG（检索增强生成）。\n@Configurationpublic class VectorStoreConfig &#123;    @Bean    public VectorStore vectorStore(EmbeddingModel embeddingModel) &#123;        // 使用内存向量存储（生产环境建议使用Redis、PostgreSQL等）        return new SimpleVectorStore(embeddingModel);    &#125;    @Bean    public EmbeddingModel embeddingModel() &#123;        return new OpenAiEmbeddingModel(OpenAiApi.builder()            .apiKey(System.getenv(&quot;OPENAI_API_KEY&quot;))            .build());    &#125;&#125;@Servicepublic class RagService &#123;    private final VectorStore vectorStore;    private final EmbeddingModel embeddingModel;    private final ChatClient chatClient;    public RagService(VectorStore vectorStore,                     EmbeddingModel embeddingModel,                     ChatClient chatClient) &#123;        this.vectorStore = vectorStore;        this.embeddingModel = embeddingModel;        this.chatClient = chatClient;    &#125;    // 文档入库    public void storeDocument(String content, String metadata) &#123;        TextSegment segment = TextSegment.from(content);        Embedding embedding = embeddingModel.embed(segment).content();        Document document = new Document(segment, Map.of(&quot;source&quot;, metadata));        vectorStore.add(List.of(document));    &#125;    // 检索增强问答    public String askWithContext(String question) &#123;        // 检索相关文档        List&lt;Document&gt; relevantDocs = vectorStore.similaritySearch(            SearchRequest.builder()                .query(question)                .topK(3)                .build()        );        // 构建上下文        String context = relevantDocs.stream()            .map(doc -&gt; doc.getText())            .collect(Collectors.joining(&quot;\\n\\n&quot;));        return chatClient.prompt()            .system(&quot;基于以下文档内容回答问题：\\n&quot; + context)            .user(question)            .call()            .content();    &#125;&#125;\n\n实战案例：智能问答系统项目结构spring-ai-qa-system/├── src/main/java/com/example/springai/│   ├── config/                    # 配置类│   │   ├── AiConfig.java         # AI配置│   │   ├── VectorStoreConfig.java # 向量存储配置│   │   └── AdvisorConfig.java     # 增强器配置│   ├── controller/               # 控制器│   │   └── QaController.java     # 问答接口│   ├── service/                  # 业务服务│   │   ├── ChatService.java      # 聊天服务│   │   ├── RagService.java       # RAG服务│   │   └── PromptService.java    # 提示词服务│   ├── model/                    # 数据模型│   │   ├── ChatRequest.java      # 请求模型│   │   └── ChatResponse.java     # 响应模型│   └── tools/                    # 工具类│       └── SearchTools.java      # 搜索工具├── src/main/resources/│   ├── application.yml           # 应用配置└── pom.xml                       # Maven依赖\n\nMaven依赖配置&lt;!-- pom.xml --&gt;&lt;dependencies&gt;    &lt;!-- Spring Boot --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- Spring AI --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;        &lt;artifactId&gt;spring-ai-openai-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.0.0-M3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 向量存储（可选） --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.ai&lt;/groupId&gt;        &lt;artifactId&gt;spring-ai-pgvector-store-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;1.0.0-M3&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 其他依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n核心服务实现// ChatService.java@Service@Slf4jpublic class ChatService &#123;    private final ChatClient chatClient;    private final PromptService promptService;    public ChatService(ChatClient chatClient, PromptService promptService) &#123;        this.chatClient = chatClient;        this.promptService = promptService;    &#125;    public ChatResponse chat(ChatRequest request) &#123;        try &#123;            // 生成提示词            String prompt = promptService.generatePrompt(request);            // 调用AI            String response = chatClient.prompt()                .system(prompt)                .user(request.getMessage())                .call()                .content();            return ChatResponse.builder()                .response(response)                .timestamp(System.currentTimeMillis())                .success(true)                .build();        &#125; catch (Exception e) &#123;            log.error(&quot;聊天服务调用失败&quot;, e);            return ChatResponse.builder()                .success(false)                .errorMessage(e.getMessage())                .timestamp(System.currentTimeMillis())                .build();        &#125;    &#125;    // 流式响应    public Flux&lt;String&gt; streamChat(ChatRequest request) &#123;        String prompt = promptService.generatePrompt(request);        return chatClient.prompt()            .system(prompt)            .user(request.getMessage())            .stream()            .content();    &#125;&#125;\n\nREST控制器@RestController@RequestMapping(&quot;/api/chat&quot;)@RequiredArgsConstructor@Slf4jpublic class ChatController &#123;    private final ChatService chatService;    private final RagService ragService;    @PostMapping(&quot;/simple&quot;)    public ResponseEntity&lt;ChatResponse&gt; simpleChat(@Valid @RequestBody ChatRequest request) &#123;        log.info(&quot;收到简单聊天请求：&#123;&#125;&quot;, request.getMessage());        ChatResponse response = chatService.chat(request);        return ResponseEntity.ok(response);    &#125;    @PostMapping(&quot;/rag&quot;)    public ResponseEntity&lt;ChatResponse&gt; ragChat(@Valid @RequestBody ChatRequest request) &#123;        log.info(&quot;收到RAG聊天请求：&#123;&#125;&quot;, request.getMessage());        String answer = ragService.askWithContext(request.getMessage());        ChatResponse response = ChatResponse.builder()            .response(answer)            .timestamp(System.currentTimeMillis())            .success(true)            .build();        return ResponseEntity.ok(response);    &#125;    @PostMapping(value = &quot;/stream&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)    public Flux&lt;String&gt; streamChat(@Valid @RequestBody ChatRequest request) &#123;        log.info(&quot;收到流式聊天请求：&#123;&#125;&quot;, request.getMessage());        return chatService.streamChat(request);    &#125;    @PostMapping(&quot;/tools&quot;)    public ResponseEntity&lt;ChatResponse&gt; chatWithTools(@Valid @RequestBody ChatRequest request) &#123;        log.info(&quot;收到工具聊天请求：&#123;&#125;&quot;, request.getMessage());        // 这里可以调用带有工具的聊天服务        ChatResponse response = chatService.chat(request);        return ResponseEntity.ok(response);    &#125;&#125;\n\n应用配置# application.ymlspring:  application:    name: spring-ai-qa-system  ai:    openai:      api-key: $&#123;OPENAI_API_KEY:your-api-key-here&#125;      chat:        model: gpt-3.5-turbo        temperature: 0.3        max-tokens: 1000      embedding:        model: text-embedding-ada-002server:  port: 8080logging:  level:    org.springframework.ai: DEBUG    com.example.springai: INFO\n\n高级功能扩展1. 多模型支持@Configurationpublic class MultiModelConfig &#123;    @Bean    @Qualifier(&quot;gpt4ChatClient&quot;)    public ChatClient gpt4ChatClient(ChatClient.Builder builder) &#123;        return builder            .defaultOptions(ChatOptions.builder()                .model(&quot;gpt-4&quot;)                .temperature(0.1)                .build())            .build();    &#125;    @Bean    @Qualifier(&quot;gpt35ChatClient&quot;)    public ChatClient gpt35ChatClient(ChatClient.Builder builder) &#123;        return builder            .defaultOptions(ChatOptions.builder()                .model(&quot;gpt-3.5-turbo&quot;)                .temperature(0.7)                .build())            .build();    &#125;&#125;@Servicepublic class MultiModelService &#123;    private final ChatClient gpt4Client;    private final ChatClient gpt35Client;    public MultiModelService(            @Qualifier(&quot;gpt4ChatClient&quot;) ChatClient gpt4Client,            @Qualifier(&quot;gpt35ChatClient&quot;) ChatClient gpt35Client) &#123;        this.gpt4Client = gpt4Client;        this.gpt35Client = gpt35Client;    &#125;    public String chatWithModel(String message, String model) &#123;        ChatClient client = &quot;gpt4&quot;.equals(model) ? gpt4Client : gpt35Client;        return client.prompt()            .user(message)            .call()            .content();    &#125;&#125;\n\n2. 自定义增强器@Componentpublic class CustomLoggingAdvisor implements Advisor &#123;    private static final Logger log = LoggerFactory.getLogger(CustomLoggingAdvisor.class);    @Override    public AdvisedRequest adviseRequest(AdvisedRequest request, Map&lt;String, Object&gt; context) &#123;        log.info(&quot;AI请求 - 用户: &#123;&#125;, 系统: &#123;&#125;, 消息长度: &#123;&#125;&quot;,            request.user().text(),            request.system().text(),            request.user().text().length());        return request;    &#125;    @Override    public ChatResponse adviseResponse(ChatResponse response, Map&lt;String, Object&gt; context) &#123;        log.info(&quot;AI响应 - 成功: &#123;&#125;, 响应长度: &#123;&#125;, Token使用: &#123;&#125;&quot;,            response != null,            response != null ? response.getResult().getOutput().getContent().length() : 0,            response != null ? response.getMetadata().getUsage().getTotalTokens() : 0);        return response;    &#125;&#125;\n\n部署和优化Docker部署# DockerfileFROM openjdk:17-jdk-slimWORKDIR /appCOPY target/*.jar app.jarEXPOSE 8080CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]\n\n# docker-compose.ymlversion: &#x27;3.8&#x27;services:  spring-ai-app:    build: .    ports:      - &quot;8080:8080&quot;    environment:      - OPENAI_API_KEY=$&#123;OPENAI_API_KEY&#125;    restart: unless-stopped\n\n性能优化策略\n缓存机制\n@Configurationpublic class CacheConfig &#123;    @Bean    public CacheManager cacheManager() &#123;        CaffeineCacheManager cacheManager = new CaffeineCacheManager();        cacheManager.setCaffeine(Caffeine.newBuilder()            .maximumSize(1000)            .expireAfterWrite(Duration.ofMinutes(30)));        return cacheManager;    &#125;&#125;@Service@Cacheable(&quot;ai-responses&quot;)public String cachedChat(String message) &#123;    return chatClient.prompt()        .user(message)        .call()        .content();&#125;\n异步处理\n@Servicepublic class AsyncChatService &#123;    @Async    public CompletableFuture&lt;String&gt; asyncChat(String message) &#123;        return CompletableFuture.supplyAsync(() -&gt;            chatClient.prompt()                .user(message)                .call()                .content()        );    &#125;    public List&lt;String&gt; batchChat(List&lt;String&gt; messages) &#123;        return messages.stream()            .map(message -&gt; chatClient.prompt()                .user(message)                .call()                .content())            .collect(Collectors.toList());    &#125;&#125;\n\n最佳实践1. 错误处理@Servicepublic class ResilientChatService &#123;    @Retryable(        value = &#123;AiException.class&#125;,        maxAttempts = 3,        backoff = @Backoff(delay = 1000, multiplier = 2)    )    public String resilientChat(String message) &#123;        try &#123;            return chatClient.prompt()                .user(message)                .call()                .content();        &#125; catch (AiException e) &#123;            log.error(&quot;AI服务调用失败，重试中...&quot;, e);            throw e;        &#125;    &#125;    @Recover    public String recover(AiException e, String message) &#123;        log.error(&quot;AI服务调用失败，使用降级方案&quot;, e);        return &quot;抱歉，AI服务暂时不可用，请稍后再试。&quot;;    &#125;&#125;\n\n2. 监控和指标@Configurationpublic class MetricsConfig &#123;    @Bean    public MeterRegistryCustomizer&lt;MeterRegistry&gt; metricsCustomizer() &#123;        return registry -&gt; &#123;            registry.config()                .commonTags(&quot;application&quot;, &quot;spring-ai-qa-system&quot;);        &#125;;    &#125;&#125;@Servicepublic class MonitoredChatService &#123;    private final Counter chatRequests;    private final Counter chatErrors;    private final Timer chatDuration;    public MonitoredChatService(MeterRegistry registry) &#123;        this.chatRequests = Counter.builder(&quot;ai.chat.requests&quot;)            .description(&quot;Number of chat requests&quot;)            .register(registry);        this.chatErrors = Counter.builder(&quot;ai.chat.errors&quot;)            .description(&quot;Number of chat errors&quot;)            .register(registry);        this.chatDuration = Timer.builder(&quot;ai.chat.duration&quot;)            .description(&quot;Chat request duration&quot;)            .register(registry);    &#125;    public String monitoredChat(String message) &#123;        chatRequests.increment();        return chatDuration.recordCallable(() -&gt; &#123;            try &#123;                return chatClient.prompt()                    .user(message)                    .call()                    .content();            &#125; catch (Exception e) &#123;                chatErrors.increment();                throw e;            &#125;        &#125;);    &#125;&#125;\n\n3. 安全考虑@Configurationpublic class SecurityConfig &#123;    @Bean    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception &#123;        http            .csrf().disable()            .authorizeHttpRequests(authz -&gt; authz                .requestMatchers(&quot;/api/chat/**&quot;).authenticated()                .anyRequest().permitAll()            )            .httpBasic();        return http.build();    &#125;    @Bean    public RateLimiter rateLimiter() &#123;        return RateLimiter.create(10.0); // 每秒10个请求    &#125;&#125;@Servicepublic class SecureChatService &#123;    private final RateLimiter rateLimiter;    public SecureChatService(RateLimiter rateLimiter) &#123;        this.rateLimiter = rateLimiter;    &#125;    public String secureChat(String message, Authentication auth) &#123;        // 速率限制        if (!rateLimiter.tryAcquire()) &#123;            throw new RuntimeException(&quot;请求过于频繁，请稍后再试&quot;);        &#125;        // 输入过滤        String sanitizedMessage = sanitizeInput(message);        // 调用AI        String response = chatClient.prompt()            .user(sanitizedMessage)            .call()            .content();        // 输出过滤        return sanitizeOutput(response);    &#125;    private String sanitizeInput(String input) &#123;        // 实现输入过滤逻辑        return input.trim();    &#125;    private String sanitizeOutput(String output) &#123;        // 实现输出过滤逻辑        return output.trim();    &#125;&#125;\n\n总结与注意事项技术要点总结\nSpring AI是Spring官方推出的AI框架，提供了原生的Spring集成体验\n核心组件包括ChatClient、Advisor、Function Callbacks、Vector Store等\nSpring Boot集成提供了完整的应用开发体验\n多模型支持可以灵活选择不同的AI模型\n企业级特性包括监控、安全、缓存等生产环境必需功能\n\n使用注意事项\n合理管理API密钥，避免泄露\n注意速率限制和成本控制\n在生产环境中使用适当的缓存和监控\n定期更新Spring AI版本，获取最新功能\n遵守相关法律法规，确保内容合规\n\n扩展阅读建议\n深入学习Spring AI官方文档\n了解Spring生态的其他AI相关项目\n学习Spring Boot最佳实践\n关注AI技术的最新发展趋势\n研究向量数据库和RAG技术\n\n通过本文的介绍，你已经掌握了使用Spring AI构建LLM应用的基本技能。Spring AI以其简洁的API设计和强大的Spring生态集成，为Java开发者提供了一条快速构建AI应用的捷径。\n参考资料\nSpring AI官方文档\nSpring AI GitHub仓库\nOpenAI API文档\nSpring Boot官方文档\nSpring WebFlux文档\nResilience4j文档\nMicrometer文档\nDocker最佳实践\nSpring Security文档\n向量数据库比较\n\n","tags":["Spring AI","大语言模型","LLM","AI应用","Java","Spring Boot"]},{"title":"LangChain4j打造自己的LLM应用","url":"/2025/01/15/0.5.2-LangChain4j%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84LLM%E5%BA%94%E7%94%A8/","content":"\nLangChain4j是Java生态中强大的框架，帮助开发者快速构建基于大语言模型的应用。本文将带你从零开始，掌握LangChain4j的核心概念和Spring Boot集成技巧，打造属于自己的AI应用。\n\nLangChain4j简介LangChain4j是一个开源框架，专门为Java开发者设计，用于开发基于大语言模型的应用程序。它提供了一套完整的工具链，包括模型集成、提示工程、链式调用、记忆管理、代理系统等核心组件，并与Spring Boot等Java生态完美集成。\n为什么选择LangChain4j？\nJava原生支持：专为Java生态设计，与Spring Boot完美集成\n类型安全：利用Java的类型系统，提供更好的开发体验\n简化开发流程：提供标准化组件，减少重复代码\n模型无关性：支持多种LLM，如OpenAI、Anthropic、Hugging Face等\n可扩展性：模块化设计，易于定制和扩展\n生产就绪：内置错误处理、日志记录等企业级功能\n社区活跃：拥有完善的文档和活跃的开源社区\n\n核心组件详解1. Models（模型）LangChain4j支持多种类型的模型，包括大语言模型、聊天模型和文本嵌入模型。\nimport dev.langchain4j.model.openai.OpenAiChatModel;import dev.langchain4j.model.openai.OpenAiEmbeddingModel;import dev.langchain4j.model.openai.OpenAiTokenizer;// 聊天模型OpenAiChatModel chatModel = OpenAiChatModel.builder()    .apiKey(&quot;your-openai-api-key&quot;)    .modelName(&quot;gpt-3.5-turbo&quot;)    .temperature(0.3)    .maxTokens(1000)    .build();// 嵌入模型OpenAiEmbeddingModel embeddingModel = OpenAiEmbeddingModel.builder()    .apiKey(&quot;your-openai-api-key&quot;)    .modelName(&quot;text-embedding-ada-002&quot;)    .build();// 分词器OpenAiTokenizer tokenizer = new OpenAiTokenizer(&quot;gpt-3.5-turbo&quot;);\n\n2. Prompts（提示词）提示词是与语言模型交互的核心，LangChain4j提供了丰富的提示词管理功能。\nimport dev.langchain4j.model.input.Prompt;import dev.langchain4j.model.input.PromptTemplate;import java.util.Map;// 基础提示词模板String template = &quot;&quot;&quot;你是一个专业的&#123;&#123;role&#125;&#125;，请回答以下问题：&#123;&#123;question&#125;&#125;请用&#123;&#123;language&#125;&#125;回答。&quot;&quot;&quot;;PromptTemplate promptTemplate = PromptTemplate.from(template);// 使用提示词Map&lt;String, Object&gt; variables = Map.of(    &quot;role&quot;, &quot;技术专家&quot;,    &quot;question&quot;, &quot;什么是微服务架构？&quot;,    &quot;language&quot;, &quot;中文&quot;);Prompt prompt = promptTemplate.apply(variables);// 直接创建提示词Prompt directPrompt = Prompt.from(&quot;&quot;&quot;你是一个专业的技术专家，请详细解释什么是微服务架构。请从以下几个方面进行说明：1. 基本概念2. 与单体架构的区别3. 主要优势和挑战4. 实际应用场景&quot;&quot;&quot;);\n\n3. Chains（链）在LangChain4j中，链式调用通过方法组合和管道模式来实现复杂的处理流程。\nimport dev.langchain4j.chain.ConversationalRetrievalChain;import dev.langchain4j.data.message.AiMessage;import dev.langchain4j.data.message.UserMessage;import dev.langchain4j.memory.chat.ChatMemory;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import dev.langchain4j.retriever.EmbeddingStoreRetriever;import dev.langchain4j.store.embedding.EmbeddingStore;import java.util.function.Function;// 创建对话链ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(10);ConversationalRetrievalChain chain = ConversationalRetrievalChain.builder()    .chatLanguageModel(chatModel)    .retriever(retriever)    .chatMemory(chatMemory)    .build();// 使用链进行对话String question = &quot;什么是微服务架构？&quot;;AiMessage answer = chain.execute(question);// 自定义链式处理Function&lt;String, String&gt; processingChain = input -&gt; &#123;    // 第一步：预处理输入    String processedInput = preprocess(input);    // 第二步：调用AI模型    AiMessage response = chatModel.generate(        UserMessage.from(processedInput)    );    // 第三步：后处理输出    return postprocess(response.text());&#125;;// 执行链式处理String result = processingChain.apply(&quot;原始输入&quot;);\n\n4. Memory（记忆）记忆组件让LLM能够记住之前的对话历史，提供更连贯的交互体验。\nimport dev.langchain4j.memory.chat.ChatMemory;import dev.langchain4j.memory.chat.MessageWindowChatMemory;import dev.langchain4j.memory.chat.TokenWindowChatMemory;import dev.langchain4j.data.message.ChatMessage;import dev.langchain4j.data.message.UserMessage;import dev.langchain4j.data.message.AiMessage;// 基于消息窗口的记忆ChatMemory messageWindowMemory = MessageWindowChatMemory.withMaxMessages(10);// 基于Token窗口的记忆ChatMemory tokenWindowMemory = TokenWindowChatMemory.withMaxTokens(1000, tokenizer);// 对话服务类public class ConversationalService &#123;    private final OpenAiChatModel chatModel;    private final ChatMemory chatMemory;    public ConversationalService(OpenAiChatModel chatModel, ChatMemory chatMemory) &#123;        this.chatModel = chatModel;        this.chatMemory = chatMemory;    &#125;    public String chat(String userMessage) &#123;        // 添加用户消息到记忆        chatMemory.add(UserMessage.from(userMessage));        // 获取对话历史        String conversationHistory = chatMemory.messages().stream()            .map(ChatMessage::text)            .collect(Collectors.joining(&quot;\\n&quot;));        // 构建完整提示词        Prompt prompt = Prompt.from(            &quot;基于以下对话历史回答用户的问题：\\n&quot; +            conversationHistory + &quot;\\n&quot; +            &quot;用户问题：&quot; + userMessage + &quot;\\n&quot; +            &quot;请提供准确、详细的回答：&quot;        );        // 调用AI模型        AiMessage aiResponse = chatModel.generate(prompt.toUserMessage());        // 添加AI回复到记忆        chatMemory.add(aiResponse);        return aiResponse.text();    &#125;&#125;// 使用示例MessageWindowChatMemory memory = MessageWindowChatMemory.withMaxMessages(20);ConversationalService service = new ConversationalService(chatModel, memory);String response1 = service.chat(&quot;你好，我叫小明&quot;);String response2 = service.chat(&quot;我刚才说什么名字了？&quot;);\n\n5. Agents（代理）在LangChain4j中，代理功能通过Tool接口和AiServices来实现，让LLM能够自主选择工具并执行任务。\nimport dev.langchain4j.agent.tool.Tool;import dev.langchain4j.agent.tool.ToolSpecification;import dev.langchain4j.service.AiServices;import dev.langchain4j.service.Result;// 定义工具类public class SearchTools &#123;    @Tool(&quot;搜索互联网信息&quot;)    public String searchWeb(String query) &#123;        // 这里实现具体的搜索逻辑        // 例如调用搜索引擎API        return &quot;搜索结果：根据查询 &#x27;&quot; + query + &quot;&#x27; 找到的相关信息...&quot;;    &#125;    @Tool(&quot;计算数学表达式&quot;)    public double calculate(String expression) &#123;        // 这里实现数学计算逻辑        // 可以使用JavaScript引擎或第三方库        try &#123;            // 简化实现，实际应该使用更安全的计算方式            return Double.parseDouble(expression);        &#125; catch (Exception e) &#123;            return 0.0;        &#125;    &#125;    @Tool(&quot;获取当前时间&quot;)    public String getCurrentTime() &#123;        return LocalDateTime.now().toString();    &#125;&#125;// 定义AI服务接口interface IntelligentAssistant &#123;    @dev.langchain4j.service.UserMessage(&quot;请帮我处理以下请求：&#123;&#123;request&#125;&#125;&quot;)    Result&lt;String&gt; processRequest(String request);&#125;// 创建带工具的AI服务IntelligentAssistant assistant = AiServices.builder(IntelligentAssistant.class)    .chatLanguageModel(chatModel)    .tools(new SearchTools())    .build();// 使用代理Result&lt;String&gt; result = assistant.processRequest(&quot;2024年最新的AI技术有哪些？&quot;);String answer = result.content();// 自定义工具执行器public class CustomToolExecutor &#123;    private final OpenAiChatModel chatModel;    private final List&lt;ToolSpecification&gt; tools;    public CustomToolExecutor(OpenAiChatModel chatModel, List&lt;ToolSpecification&gt; tools) &#123;        this.chatModel = chatModel;        this.tools = tools;    &#125;    public String executeWithTools(String userQuery) &#123;        // 构建包含工具信息的提示词        StringBuilder prompt = new StringBuilder();        prompt.append(&quot;你是一个智能助手，可以使用以下工具来帮助用户：\\n\\n&quot;);        for (ToolSpecification tool : tools) &#123;            prompt.append(String.format(&quot;- %s: %s\\n&quot;,                tool.name(), tool.description()));        &#125;        prompt.append(String.format(&quot;\\n用户查询：%s\\n&quot;, userQuery));        prompt.append(&quot;请根据用户查询选择合适的工具来回答问题。&quot;);        // 调用AI模型        AiMessage response = chatModel.generate(UserMessage.from(prompt.toString()));        return response.text();    &#125;&#125;\n\n实战案例：智能问答系统让我们通过一个完整的Spring Boot项目来展示如何使用LangChain4j构建智能问答系统。\n项目结构llm-qa-system/├── src/main/java/com/example/qa/│   ├── config/                    # 配置类│   │   ├── AiConfig.java         # AI模型配置│   │   └── AppConfig.java        # 应用配置│   ├── controller/               # 控制器│   │   └── QaController.java     # 问答接口│   ├── service/                  # 业务服务│   │   ├── QaService.java        # 问答服务│   │   ├── PromptService.java    # 提示词服务│   │   └── MemoryService.java    # 记忆服务│   ├── model/                    # 数据模型│   │   ├── QaRequest.java        # 请求模型│   │   └── QaResponse.java       # 响应模型│   └── util/                     # 工具类│       └── PromptTemplates.java  # 提示词模板├── src/main/resources/│   ├── application.yml           # 应用配置│   └── templates/                # 提示词模板└── pom.xml                       # Maven依赖\n\nMaven依赖配置&lt;!-- pom.xml --&gt;&lt;dependencies&gt;    &lt;!-- Spring Boot --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- LangChain4j --&gt;    &lt;dependency&gt;        &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;        &lt;artifactId&gt;langchain4j-open-ai-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;0.25.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 其他依赖 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n核心配置类// src/main/java/com/example/qa/config/AiConfig.java@Configurationpublic class AiConfig &#123;    @Value(&quot;$&#123;openai.api-key&#125;&quot;)    private String openAiApiKey;    @Bean    public OpenAiChatModel chatModel() &#123;        return OpenAiChatModel.builder()            .apiKey(openAiApiKey)            .modelName(&quot;gpt-3.5-turbo&quot;)            .temperature(0.3)            .maxTokens(1000)            .build();    &#125;    @Bean    public ChatMemory chatMemory() &#123;        return MessageWindowChatMemory.withMaxMessages(20);    &#125;&#125;\n\n数据模型// src/main/java/com/example/qa/model/QaRequest.java@Data@NoArgsConstructor@AllArgsConstructorpublic class QaRequest &#123;    @NotBlank(message = &quot;问题不能为空&quot;)    private String question;    private String sessionId;    @Builder.Default    private String role = &quot;技术专家&quot;;&#125;// src/main/java/com/example/qa/model/QaResponse.java@Data@NoArgsConstructor@AllArgsConstructor@Builderpublic class QaResponse &#123;    private String answer;    private String sessionId;    private long timestamp;    private boolean success;    private String errorMessage;&#125;\n\n核心服务类// src/main/java/com/example/qa/service/QaService.java@Service@Slf4jpublic class QaService &#123;    private final OpenAiChatModel chatModel;    private final PromptService promptService;    private final MemoryService memoryService;    public QaService(OpenAiChatModel chatModel,                    PromptService promptService,                    MemoryService memoryService) &#123;        this.chatModel = chatModel;        this.promptService = promptService;        this.memoryService = memoryService;    &#125;    public QaResponse askQuestion(QaRequest request) &#123;        try &#123;            // 获取或创建会话记忆            ChatMemory memory = memoryService.getMemory(request.getSessionId());            // 添加用户消息到记忆            memory.add(UserMessage.from(request.getQuestion()));            // 生成提示词            Prompt prompt = promptService.generateQaPrompt(request, memory);            // 调用AI模型            AiMessage aiResponse = chatModel.generate(prompt.toUserMessage());            // 添加AI回复到记忆            memory.add(aiResponse);            return QaResponse.builder()                .answer(aiResponse.text())                .sessionId(request.getSessionId())                .timestamp(System.currentTimeMillis())                .success(true)                .build();        &#125; catch (Exception e) &#123;            log.error(&quot;处理问答请求失败&quot;, e);            return QaResponse.builder()                .success(false)                .errorMessage(&quot;处理问题时出现错误：&quot; + e.getMessage())                .timestamp(System.currentTimeMillis())                .build();        &#125;    &#125;&#125;\n\n提示词服务// src/main/java/com/example/qa/service/PromptService.java@Servicepublic class PromptService &#123;    public Prompt generateQaPrompt(QaRequest request, ChatMemory memory) &#123;        // 获取对话历史        String conversationHistory = memory.messages().stream()            .map(ChatMessage::text)            .collect(Collectors.joining(&quot;\\n&quot;));        String template = &quot;&quot;&quot;            你是一个专业的&#123;role&#125;，请基于以下对话历史回答用户的问题。            对话历史：            &#123;history&#125;            当前问题：&#123;question&#125;            回答要求：            1. 内容准确，基于可靠的技术知识            2. 结构清晰，逻辑性强            3. 适当使用代码示例说明            4. 语言简洁明了，避免废话            5. 如果是技术问题，提供具体可行的解决方案            &quot;&quot;&quot;;        Map&lt;String, Object&gt; variables = Map.of(            &quot;role&quot;, request.getRole(),            &quot;history&quot;, conversationHistory,            &quot;question&quot;, request.getQuestion()        );        PromptTemplate promptTemplate = PromptTemplate.from(template);        return promptTemplate.apply(variables);    &#125;&#125;\n\n记忆管理服务// src/main/java/com/example/qa/service/MemoryService.java@Servicepublic class MemoryService &#123;    private final ConcurrentHashMap&lt;String, ChatMemory&gt; memoryStore = new ConcurrentHashMap&lt;&gt;();    public ChatMemory getMemory(String sessionId) &#123;        if (sessionId == null || sessionId.trim().isEmpty()) &#123;            sessionId = generateSessionId();        &#125;        return memoryStore.computeIfAbsent(sessionId, k -&gt;            MessageWindowChatMemory.withMaxMessages(20));    &#125;    public void clearMemory(String sessionId) &#123;        if (sessionId != null) &#123;            memoryStore.remove(sessionId);        &#125;    &#125;    public Set&lt;String&gt; getActiveSessions() &#123;        return new HashSet&lt;&gt;(memoryStore.keySet());    &#125;    private String generateSessionId() &#123;        return UUID.randomUUID().toString();    &#125;&#125;\n\nREST控制器// src/main/java/com/example/qa/controller/QaController.java@RestController@RequestMapping(&quot;/api/qa&quot;)@RequiredArgsConstructor@Slf4jpublic class QaController &#123;    private final QaService qaService;    private final MemoryService memoryService;    @PostMapping(&quot;/ask&quot;)    public ResponseEntity&lt;QaResponse&gt; askQuestion(@Valid @RequestBody QaRequest request) &#123;        log.info(&quot;收到问答请求：&#123;&#125;&quot;, request.getQuestion());        QaResponse response = qaService.askQuestion(request);        return response.isSuccess()            ? ResponseEntity.ok(response)            : ResponseEntity.badRequest().body(response);    &#125;    @PostMapping(&quot;/sessions/&#123;sessionId&#125;/clear&quot;)    public ResponseEntity&lt;Void&gt; clearSession(@PathVariable String sessionId) &#123;        memoryService.clearMemory(sessionId);        return ResponseEntity.ok().build();    &#125;    @GetMapping(&quot;/sessions&quot;)    public ResponseEntity&lt;Set&lt;String&gt;&gt; getActiveSessions() &#123;        return ResponseEntity.ok(memoryService.getActiveSessions());    &#125;&#125;\n\n高级功能扩展// 添加文档问答功能import dev.langchain4j.data.document.Document;import dev.langchain4j.data.document.loader.FileSystemDocumentLoader;import dev.langchain4j.data.document.splitter.DocumentSplitters;import dev.langchain4j.store.embedding.EmbeddingStore;import dev.langchain4j.store.embedding.inmemory.InMemoryEmbeddingStore;import dev.langchain4j.retriever.EmbeddingStoreRetriever;@Servicepublic class DocumentQaService &#123;    private final OpenAiChatModel chatModel;    private final OpenAiEmbeddingModel embeddingModel;    private final EmbeddingStoreRetriever retriever;    public DocumentQaService(OpenAiChatModel chatModel,                           OpenAiEmbeddingModel embeddingModel) &#123;        this.chatModel = chatModel;        this.embeddingModel = embeddingModel;        // 初始化向量存储和检索器        this.retriever = initializeRetriever();    &#125;    private EmbeddingStoreRetriever initializeRetriever() &#123;        // 加载文档        List&lt;Document&gt; documents = FileSystemDocumentLoader.loadDocuments(            Paths.get(&quot;src/main/resources/docs&quot;),            new TextDocumentParser()        );        // 分割文档        List&lt;TextSegment&gt; segments = DocumentSplitters.recursive(300, 0)            .split(documents);        // 创建嵌入并存储        EmbeddingStore&lt;TextSegment&gt; embeddingStore = new InMemoryEmbeddingStore&lt;&gt;();        List&lt;Embedding&gt; embeddings = embeddingModel.embedAll(segments).content();        for (int i = 0; i &lt; segments.size(); i++) &#123;            embeddingStore.add(segments.get(i), embeddings.get(i));        &#125;        // 创建检索器        return EmbeddingStoreRetriever.from(embeddingStore, embeddingModel, 5);    &#125;    public String askDocument(String question) &#123;        // 检索相关文档片段        List&lt;TextSegment&gt; relevantSegments = retriever.findRelevant(question);        // 构建上下文        StringBuilder context = new StringBuilder();        context.append(&quot;基于以下文档内容回答问题：\\n\\n&quot;);        for (TextSegment segment : relevantSegments) &#123;            context.append(segment.text()).append(&quot;\\n\\n&quot;);        &#125;        context.append(&quot;问题：&quot;).append(question);        // 调用AI模型        AiMessage response = chatModel.generate(UserMessage.from(context.toString()));        return response.text();    &#125;&#125;\n\n部署和优化环境配置# application.ymlspring:  application:    name: llm-qa-system  profiles:    active: devserver:  port: 8080openai:  api-key: $&#123;OPENAI_API_KEY:your-api-key-here&#125;  model: gpt-3.5-turbo  temperature: 0.3  max-tokens: 1000logging:  level:    com.example.qa: DEBUG\n\n# docker-compose.ymlversion: &#x27;3.8&#x27;services:  llm-qa-app:    build: .    ports:      - &quot;8080:8080&quot;    environment:      - SPRING_PROFILES_ACTIVE=prod      - OPENAI_API_KEY=$&#123;OPENAI_API_KEY&#125;    volumes:      - ./logs:/app/logs    restart: unless-stopped\n\n# DockerfileFROM openjdk:17-jdk-slimWORKDIR /app# 复制Maven构建产物COPY target/*.jar app.jar# 创建非root用户RUN groupadd -r appuser &amp;&amp; useradd -r -g appuser appuserUSER appuserEXPOSE 8080CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]\n\n性能优化策略\n缓存机制：\nimport com.github.benmanes.caffeine.cache.Cache;import com.github.benmanes.caffeine.cache.Caffeine;import java.time.Duration;@Servicepublic class AiCacheService &#123;    private final Cache&lt;String, String&gt; responseCache;    public AiCacheService() &#123;        this.responseCache = Caffeine.newBuilder()            .maximumSize(1000)            .expireAfterWrite(Duration.ofHours(1))            .build();    &#125;    public String getCachedResponse(String question) &#123;        return responseCache.getIfPresent(question);    &#125;    public void cacheResponse(String question, String response) &#123;        responseCache.put(question, response);    &#125;    public String getOrCompute(String question, Function&lt;String, String&gt; supplier) &#123;        return responseCache.get(question, supplier);    &#125;&#125;\n异步处理：\nimport org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Service;import java.util.concurrent.CompletableFuture;@Servicepublic class AsyncAiService &#123;    private final OpenAiChatModel chatModel;    public AsyncAiService(OpenAiChatModel chatModel) &#123;        this.chatModel = chatModel;    &#125;    @Async    public CompletableFuture&lt;String&gt; asyncQuery(String question) &#123;        try &#123;            AiMessage response = chatModel.generate(UserMessage.from(question));            return CompletableFuture.completedFuture(response.text());        &#125; catch (Exception e) &#123;            return CompletableFuture.failedFuture(e);        &#125;    &#125;    // 并发处理多个查询    public CompletableFuture&lt;List&lt;String&gt;&gt; batchQueries(List&lt;String&gt; questions) &#123;        List&lt;CompletableFuture&lt;String&gt;&gt; futures = questions.stream()            .map(this::asyncQuery)            .collect(Collectors.toList());        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))            .thenApply(v -&gt; futures.stream()                .map(CompletableFuture::join)                .collect(Collectors.toList()));    &#125;&#125;\n流式响应：\nimport reactor.core.publisher.Flux;import dev.langchain4j.model.StreamingResponseHandler;import dev.langchain4j.model.response.AiMessage;@RestControllerpublic class StreamingController &#123;    private final OpenAiStreamingChatModel streamingChatModel;    public StreamingController(OpenAiStreamingChatModel streamingChatModel) &#123;        this.streamingChatModel = streamingChatModel;    &#125;    @GetMapping(value = &quot;/chat/stream&quot;, produces = MediaType.TEXT_EVENT_STREAM_VALUE)    public Flux&lt;String&gt; streamChat(@RequestParam String message) &#123;        return Flux.create(sink -&gt; &#123;            streamingChatModel.generate(                UserMessage.from(message),                new StreamingResponseHandler&lt;AiMessage&gt;() &#123;                    @Override                    public void onNext(String token) &#123;                        sink.next(token);                    &#125;                    @Override                    public void onComplete(Response&lt;AiMessage&gt; response) &#123;                        sink.complete();                    &#125;                    @Override                    public void onError(Throwable error) &#123;                        sink.error(error);                    &#125;                &#125;            );        &#125;);    &#125;&#125;\n\n最佳实践1. 错误处理import io.github.resilience4j.retry.annotation.Retry;import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;import org.springframework.stereotype.Service;@Servicepublic class ResilientAiService &#123;    private final OpenAiChatModel chatModel;    public ResilientAiService(OpenAiChatModel chatModel) &#123;        this.chatModel = chatModel;    &#125;    @Retry(name = &quot;ai-service&quot;, fallbackMethod = &quot;fallbackQuery&quot;)    @CircuitBreaker(name = &quot;ai-service&quot;, fallbackMethod = &quot;fallbackQuery&quot;)    public String robustQuery(String question) &#123;        AiMessage response = chatModel.generate(UserMessage.from(question));        return response.text();    &#125;    public String fallbackQuery(String question, Throwable t) &#123;        log.error(&quot;AI服务调用失败，使用降级方案&quot;, t);        return &quot;抱歉，AI服务暂时不可用，请稍后再试。&quot;;    &#125;&#125;\n\n2. 日志记录import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Service;@Service@Slf4jpublic class LoggingAiService &#123;    private final OpenAiChatModel chatModel;    public LoggingAiService(OpenAiChatModel chatModel) &#123;        this.chatModel = chatModel;    &#125;    public String queryWithLogging(String question, String userId) &#123;        long startTime = System.currentTimeMillis();        try &#123;            log.info(&quot;用户[&#123;&#125;]发起AI查询: &#123;&#125;&quot;, userId, question);            AiMessage response = chatModel.generate(UserMessage.from(question));            String answer = response.text();            long duration = System.currentTimeMillis() - startTime;            log.info(&quot;用户[&#123;&#125;]查询完成，耗时: &#123;&#125;ms&quot;, userId, duration);            return answer;        &#125; catch (Exception e) &#123;            long duration = System.currentTimeMillis() - startTime;            log.error(&quot;用户[&#123;&#125;]查询失败，耗时: &#123;&#125;ms，错误: &#123;&#125;&quot;,                     userId, duration, e.getMessage(), e);            throw e;        &#125;    &#125;&#125;\n\n3. 安全考虑import org.springframework.security.core.Authentication;import org.springframework.stereotype.Service;@Servicepublic class SecureAiService &#123;    private final OpenAiChatModel chatModel;    private final RateLimiter rateLimiter;    public SecureAiService(OpenAiChatModel chatModel) &#123;        this.chatModel = chatModel;        // 配置速率限制器        this.rateLimiter = RateLimiter.create(10.0); // 每秒10个请求    &#125;    public String secureQuery(String question, Authentication authentication) &#123;        // 速率限制        if (!rateLimiter.tryAcquire()) &#123;            throw new RuntimeException(&quot;请求过于频繁，请稍后再试&quot;);        &#125;        // 输入验证和过滤        String sanitizedQuestion = sanitizeInput(question);        // 内容安全检查        if (!isContentSafe(sanitizedQuestion)) &#123;            throw new RuntimeException(&quot;输入内容包含不当内容&quot;);        &#125;        try &#123;            AiMessage response = chatModel.generate(UserMessage.from(sanitizedQuestion));            String answer = response.text();            // 输出内容安全检查            if (!isContentSafe(answer)) &#123;                log.warn(&quot;AI输出包含不当内容，已过滤&quot;);                return &quot;抱歉，无法提供相关回答。&quot;;            &#125;            return answer;        &#125; catch (Exception e) &#123;            log.error(&quot;AI服务调用失败&quot;, e);            throw new RuntimeException(&quot;服务暂时不可用&quot;);        &#125;    &#125;    private String sanitizeInput(String input) &#123;        // 实现输入过滤逻辑        return input.replaceAll(&quot;&lt;script.*?&gt;.*?&lt;/script&gt;&quot;, &quot;&quot;)                   .replaceAll(&quot;javascript:&quot;, &quot;&quot;)                   .trim();    &#125;    private boolean isContentSafe(String content) &#123;        // 实现内容安全检查逻辑        // 这里可以集成第三方内容审核服务        return !content.toLowerCase().contains(&quot;不当内容&quot;);    &#125;&#125;\n\n4. 监控和指标import io.micrometer.core.instrument.Counter;import io.micrometer.core.instrument.MeterRegistry;import io.micrometer.core.instrument.Timer;import org.springframework.stereotype.Service;@Servicepublic class MonitoredAiService &#123;    private final Counter queryCounter;    private final Counter errorCounter;    private final Timer queryTimer;    private final OpenAiChatModel chatModel;    public MonitoredAiService(MeterRegistry registry, OpenAiChatModel chatModel) &#123;        this.chatModel = chatModel;        // 注册监控指标        this.queryCounter = Counter.builder(&quot;ai.queries.total&quot;)            .description(&quot;Total number of AI queries&quot;)            .register(registry);        this.errorCounter = Counter.builder(&quot;ai.errors.total&quot;)            .description(&quot;Total number of AI query errors&quot;)            .register(registry);        this.queryTimer = Timer.builder(&quot;ai.query.duration&quot;)            .description(&quot;AI query duration&quot;)            .register(registry);    &#125;    public String monitoredQuery(String question) &#123;        queryCounter.increment();        return queryTimer.recordCallable(() -&gt; &#123;            try &#123;                AiMessage response = chatModel.generate(UserMessage.from(question));                return response.text();            &#125; catch (Exception e) &#123;                errorCounter.increment();                throw e;            &#125;        &#125;);    &#125;&#125;\n\n安全考虑要点\nAPI密钥管理：使用Spring Cloud Config或Vault进行密钥管理\n输入验证：使用Bean Validation和自定义验证器\n速率限制：集成Spring Cloud Gateway或Resilience4j\n内容审核：集成第三方内容审核服务\n审计日志：记录所有AI交互用于安全审计\nHTTPS通信：确保所有API调用使用HTTPS\n\n总结与注意事项技术要点总结\nLangChain4j是Java生态中强大的LLM应用开发框架\n核心组件包括Models、Prompts、Chains、Memory、Agents、Tools\nSpring Boot集成提供了企业级的应用开发体验\n实际应用可以构建问答系统、文档分析、代码生成等多种场景\n部署优化需要考虑性能、缓存、安全、监控等因素\n\n使用注意事项\n合理控制API调用频率，避免超出OpenAI的速率限制\n注意数据隐私和安全问题，遵守相关法律法规\n根据实际需求选择合适的模型和参数配置\n定期更新LangChain4j和Spring Boot版本，保持安全性和性能\n在生产环境中使用连接池和熔断器提高系统稳定性\n监控AI服务的调用情况和性能指标\n\n扩展阅读建议\n深入学习LangChain4j官方文档和示例代码\n探索Spring AI项目，了解更多AI集成方案\n学习Spring Boot最佳实践和微服务架构\n关注LLM技术的最新发展动态和行业趋势\n学习相关的AI安全、伦理和合规要求\n研究向量数据库和RAG（检索增强生成）技术\n\n通过本文的介绍，你已经掌握了使用LangChain4j构建LLM应用的基本技能。开始动手实践，打造属于自己的AI应用吧！\n参考资料\nLangChain4j官方文档\nLangChain4j GitHub仓库\nOpenAI API文档\nSpring Boot官方文档\nSpring WebFlux响应式编程\nResilience4j故障恢复库\nMicrometer监控指标\nDocker最佳实践\nSpring Security安全框架\n向量数据库对比分析\n\n","tags":["大语言模型","LLM","AI应用","Java","Spring Boot","LangChain4j"]},{"title":"Java高德地图MCP定制旅游路线","url":"/2025/01/17/0.5.4-Java%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEMCP%E5%AE%9A%E5%88%B6%E6%97%85%E6%B8%B8%E8%B7%AF%E7%BA%BF/","content":"\n使用Java集成高德地图MCP服务，打造智能化的定制旅游路线规划系统。本文将带你从零开始，掌握高德地图Java SDK的使用技巧，实现完整的旅游路线规划功能。\n\n高德地图MCP简介高德地图MCP（Maps Content Platform）是高德地图提供的一套开放平台服务，开发者可以通过API调用获取丰富的地图数据和地理信息服务。高德地图Java SDK提供了完整的Java封装，让Java开发者能够轻松集成高德地图的各项功能。\n为什么选择高德地图MCP？\n数据丰富准确：中国最权威的地图数据提供商\n服务稳定可靠：企业级SLA保证，服务可用性99.9%\n功能全面：覆盖路径规划、地理编码、POI搜索等全方位服务\nJava SDK完善：官方维护的Java SDK，更新及时\n成本可控：按需付费，适合各种规模应用\n合规安全：符合中国法律法规，支持数据加密传输\n\n核心功能详解1. POI搜索（兴趣点搜索）POI（Point of Interest）搜索是地图应用的基础功能，用于查找附近的景点、餐厅、酒店等。\n@Service@Slf4jpublic class PoiSearchService &#123;    private final AmapRestTemplate restTemplate;    private final String apiKey;    public PoiSearchService(@Value(&quot;$&#123;amap.api-key&#125;&quot;) String apiKey) &#123;        this.apiKey = apiKey;        this.restTemplate = new AmapRestTemplate();    &#125;    /**     * 搜索附近的景点     */    public List&lt;PoiInfo&gt; searchNearbyAttractions(String location, int radius) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/place/around?key=%s&amp;location=%s&amp;radius=%d&amp;types=110200|110201&quot;,            apiKey, location, radius        );        try &#123;            AmapPoiResponse response = restTemplate.getForObject(url, AmapPoiResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return response.getPois().stream()                    .map(this::convertToPoiInfo)                    .collect(Collectors.toList());            &#125;            return Collections.emptyList();        &#125; catch (Exception e) &#123;            log.error(&quot;POI搜索失败&quot;, e);            return Collections.emptyList();        &#125;    &#125;    /**     * 根据关键词搜索景点     */    public List&lt;PoiInfo&gt; searchAttractionsByKeyword(String keyword, String city) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/place/text?key=%s&amp;keywords=%s&amp;city=%s&amp;types=110200&quot;,            apiKey, URLEncoder.encode(keyword, StandardCharsets.UTF_8), city        );        try &#123;            AmapPoiResponse response = restTemplate.getForObject(url, AmapPoiResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return response.getPois().stream()                    .map(this::convertToPoiInfo)                    .collect(Collectors.toList());            &#125;            return Collections.emptyList();        &#125; catch (Exception e) &#123;            log.error(&quot;关键词搜索失败&quot;, e);            return Collections.emptyList();        &#125;    &#125;    private PoiInfo convertToPoiInfo(AmapPoi amapPoi) &#123;        return PoiInfo.builder()            .id(amapPoi.getId())            .name(amapPoi.getName())            .location(amapPoi.getLocation())            .address(amapPoi.getAddress())            .tel(amapPoi.getTel())            .tag(amapPoi.getTag())            .website(amapPoi.getWebsite())            .photos(parsePhotos(amapPoi.getPhotos()))            .build();    &#125;    private List&lt;String&gt; parsePhotos(String photos) &#123;        if (StringUtils.isEmpty(photos)) &#123;            return Collections.emptyList();        &#125;        return Arrays.stream(photos.split(&quot;;&quot;))            .filter(StringUtils::isNotEmpty)            .collect(Collectors.toList());    &#125;&#125;\n\n2. 路径规划路径规划是旅游应用的核心功能，支持驾车、公交、地铁等多种出行方式。\n@Servicepublic class RoutePlanningService &#123;    private final AmapRestTemplate restTemplate;    private final String apiKey;    public RoutePlanningService(@Value(&quot;$&#123;amap.api-key&#125;&quot;) String apiKey) &#123;        this.apiKey = apiKey;        this.restTemplate = new AmapRestTemplate();    &#125;    /**     * 驾车路径规划     */    public DrivingRoute planDrivingRoute(String origin, String destination) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/direction/driving?key=%s&amp;origin=%s&amp;destination=%s&amp;extensions=all&quot;,            apiKey, origin, destination        );        try &#123;            AmapDrivingResponse response = restTemplate.getForObject(url, AmapDrivingResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return convertToDrivingRoute(response);            &#125;            throw new RoutePlanningException(&quot;路径规划失败：&quot; + response.getInfo());        &#125; catch (Exception e) &#123;            log.error(&quot;驾车路径规划失败&quot;, e);            throw new RoutePlanningException(&quot;路径规划服务暂时不可用&quot;, e);        &#125;    &#125;    /**     * 公交路径规划     */    public BusRoute planBusRoute(String origin, String destination, String city) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/direction/transit/integrated?key=%s&amp;origin=%s&amp;destination=%s&amp;city=%s&amp;extensions=all&quot;,            apiKey, origin, destination, city        );        try &#123;            AmapBusResponse response = restTemplate.getForObject(url, AmapBusResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return convertToBusRoute(response);            &#125;            throw new RoutePlanningException(&quot;公交路径规划失败：&quot; + response.getInfo());        &#125; catch (Exception e) &#123;            log.error(&quot;公交路径规划失败&quot;, e);            throw new RoutePlanningException(&quot;公交路径规划服务暂时不可用&quot;, e);        &#125;    &#125;    /**     * 步行路径规划     */    public WalkingRoute planWalkingRoute(String origin, String destination) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/direction/walking?key=%s&amp;origin=%s&amp;destination=%s&quot;,            apiKey, origin, destination        );        try &#123;            AmapWalkingResponse response = restTemplate.getForObject(url, AmapWalkingResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return convertToWalkingRoute(response);            &#125;            throw new RoutePlanningException(&quot;步行路径规划失败：&quot; + response.getInfo());        &#125; catch (Exception e) &#123;            log.error(&quot;步行路径规划失败&quot;, e);            throw new RoutePlanningException(&quot;步行路径规划服务暂时不可用&quot;, e);        &#125;    &#125;    private DrivingRoute convertToDrivingRoute(AmapDrivingResponse response) &#123;        // 转换逻辑        return DrivingRoute.builder()            .distance(response.getRoute().getPaths().get(0).getDistance())            .duration(response.getRoute().getPaths().get(0).getDuration())            .taxiCost(response.getRoute().getPaths().get(0).getTaxiCost())            .steps(convertDrivingSteps(response.getRoute().getPaths().get(0).getSteps()))            .build();    &#125;    private List&lt;DrivingStep&gt; convertDrivingSteps(List&lt;AmapDrivingStep&gt; steps) &#123;        return steps.stream()            .map(step -&gt; DrivingStep.builder()                .instruction(step.getInstruction())                .orientation(step.getOrientation())                .road(step.getRoad())                .distance(step.getDistance())                .duration(step.getDuration())                .polyline(step.getPolyline())                .build())            .collect(Collectors.toList());    &#125;&#125;\n\n3. 地理编码与逆地理编码地理编码可以将地址转换为坐标，逆地理编码可以将坐标转换为地址信息。\n@Servicepublic class GeocodingService &#123;    private final AmapRestTemplate restTemplate;    private final String apiKey;    public GeocodingService(@Value(&quot;$&#123;amap.api-key&#125;&quot;) String apiKey) &#123;        this.apiKey = apiKey;        this.restTemplate = new AmapRestTemplate();    &#125;    /**     * 地理编码：地址转坐标     */    public List&lt;GeocodeResult&gt; geocode(String address, String city) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/geocode/geo?key=%s&amp;address=%s&amp;city=%s&quot;,            apiKey,            URLEncoder.encode(address, StandardCharsets.UTF_8),            URLEncoder.encode(city, StandardCharsets.UTF_8)        );        try &#123;            AmapGeocodeResponse response = restTemplate.getForObject(url, AmapGeocodeResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return response.getGeocodes().stream()                    .map(this::convertToGeocodeResult)                    .collect(Collectors.toList());            &#125;            return Collections.emptyList();        &#125; catch (Exception e) &#123;            log.error(&quot;地理编码失败&quot;, e);            return Collections.emptyList();        &#125;    &#125;    /**     * 逆地理编码：坐标转地址     */    public RegeocodeResult regeocode(String location) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/geocode/regeo?key=%s&amp;location=%s&amp;extensions=all&quot;,            apiKey, location        );        try &#123;            AmapRegeocodeResponse response = restTemplate.getForObject(url, AmapRegeocodeResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return convertToRegeocodeResult(response);            &#125;            throw new GeocodingException(&quot;逆地理编码失败：&quot; + response.getInfo());        &#125; catch (Exception e) &#123;            log.error(&quot;逆地理编码失败&quot;, e);            throw new GeocodingException(&quot;逆地理编码服务暂时不可用&quot;, e);        &#125;    &#125;    /**     * 批量地理编码     */    public List&lt;GeocodeResult&gt; batchGeocode(List&lt;String&gt; addresses, String city) &#123;        return addresses.stream()            .map(address -&gt; geocode(address, city))            .flatMap(List::stream)            .collect(Collectors.toList());    &#125;    private GeocodeResult convertToGeocodeResult(AmapGeocode geocode) &#123;        return GeocodeResult.builder()            .formattedAddress(geocode.getFormattedAddress())            .location(geocode.getLocation())            .province(geocode.getProvince())            .city(geocode.getCity())            .district(geocode.getDistrict())            .township(geocode.getTownship())            .neighborhood(geocode.getNeighborhood())            .building(geocode.getBuilding())            .adcode(geocode.getAdcode())            .build();    &#125;    private RegeocodeResult convertToRegeocodeResult(AmapRegeocodeResponse response) &#123;        AmapRegeocode regeocode = response.getRegeocode();        return RegeocodeResult.builder()            .formattedAddress(regeocode.getFormattedAddress())            .addressComponent(convertAddressComponent(regeocode.getAddressComponent()))            .roads(convertRoads(regeocode.getRoads()))            .pois(convertPois(regeocode.getPois()))            .aois(convertAois(regeocode.getAois()))            .build();    &#125;&#125;\n\n4. 距离测量计算两个地点之间的距离，支持直线距离和驾车距离。\n@Servicepublic class DistanceService &#123;    private final AmapRestTemplate restTemplate;    private final String apiKey;    public DistanceService(@Value(&quot;$&#123;amap.api-key&#125;&quot;) String apiKey) &#123;        this.apiKey = apiKey;        this.restTemplate = new AmapRestTemplate();    &#125;    /**     * 计算直线距离     */    public double calculateStraightDistance(String origin, String destination) &#123;        try &#123;            String[] originCoords = origin.split(&quot;,&quot;);            String[] destCoords = destination.split(&quot;,&quot;);            double lat1 = Double.parseDouble(originCoords[1]);            double lon1 = Double.parseDouble(originCoords[0]);            double lat2 = Double.parseDouble(destCoords[1]);            double lon2 = Double.parseDouble(destCoords[0]);            return calculateHaversineDistance(lat1, lon1, lat2, lon2);        &#125; catch (Exception e) &#123;            log.error(&quot;计算直线距离失败&quot;, e);            return 0.0;        &#125;    &#125;    /**     * 计算驾车距离     */    public DrivingDistance calculateDrivingDistance(String origin, String destination) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/distance?key=%s&amp;origins=%s&amp;destination=%s&amp;type=1&quot;,            apiKey, origin, destination        );        try &#123;            AmapDistanceResponse response = restTemplate.getForObject(url, AmapDistanceResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                AmapDistanceResult result = response.getResults().get(0);                return DrivingDistance.builder()                    .distance(result.getDistance())                    .duration(result.getDuration())                    .build();            &#125;            throw new DistanceCalculationException(&quot;驾车距离计算失败：&quot; + response.getInfo());        &#125; catch (Exception e) &#123;            log.error(&quot;计算驾车距离失败&quot;, e);            throw new DistanceCalculationException(&quot;距离计算服务暂时不可用&quot;, e);        &#125;    &#125;    /**     * 批量计算距离     */    public List&lt;DrivingDistance&gt; batchCalculateDistances(String origins, String destination) &#123;        String url = String.format(            &quot;https://restapi.amap.com/v3/distance?key=%s&amp;origins=%s&amp;destination=%s&amp;type=1&quot;,            apiKey, origins, destination        );        try &#123;            AmapDistanceResponse response = restTemplate.getForObject(url, AmapDistanceResponse.class);            if (response != null &amp;&amp; &quot;1&quot;.equals(response.getStatus())) &#123;                return response.getResults().stream()                    .map(result -&gt; DrivingDistance.builder()                        .distance(result.getDistance())                        .duration(result.getDuration())                        .build())                    .collect(Collectors.toList());            &#125;            return Collections.emptyList();        &#125; catch (Exception e) &#123;            log.error(&quot;批量计算距离失败&quot;, e);            return Collections.emptyList();        &#125;    &#125;    /**     * 使用Haversine公式计算球面距离     */    private double calculateHaversineDistance(double lat1, double lon1, double lat2, double lon2) &#123;        final int EARTH_RADIUS = 6371; // 地球半径，单位：公里        double latDistance = Math.toRadians(lat2 - lat1);        double lonDistance = Math.toRadians(lon2 - lon1);        double a = Math.sin(latDistance / 2) * Math.sin(latDistance / 2)                + Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2))                * Math.sin(lonDistance / 2) * Math.sin(lonDistance / 2);        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));        return EARTH_RADIUS * c;    &#125;&#125;\n\n实战案例：智能旅游路线规划系统项目结构java-amap-tour-planning/├── src/main/java/com/example/amap/│   ├── config/                    # 配置类│   │   ├── AmapConfig.java       # 高德地图配置│   │   └── WebConfig.java        # Web配置│   ├── controller/               # 控制器│   │   ├── TourController.java   # 旅游路线接口│   │   └── MapController.java    # 地图服务接口│   ├── service/                  # 业务服务│   │   ├── PoiSearchService.java # POI搜索服务│   │   ├── RoutePlanningService.java # 路线规划服务│   │   ├── GeocodingService.java # 地理编码服务│   │   └── DistanceService.java  # 距离计算服务│   ├── model/                    # 数据模型│   │   ├── request/              # 请求模型│   │   │   ├── TourPlanRequest.java│   │   │   └── RouteRequest.java│   │   ├── response/             # 响应模型│   │   │   ├── TourPlanResponse.java│   │   │   └── RouteResponse.java│   │   └── entity/               # 实体模型│   │       ├── PoiInfo.java│   │       ├── Route.java│   │       └── Location.java│   ├── exception/                # 异常处理│   │   ├── AmapApiException.java│   │   └── GlobalExceptionHandler.java│   └── utils/                    # 工具类│       ├── AmapRestTemplate.java # 高德API工具│       └── LocationUtils.java    # 位置工具类├── src/main/resources/│   ├── application.yml           # 应用配置│   └── static/                   # 静态资源└── pom.xml                       # Maven依赖\n\nMaven依赖配置&lt;!-- pom.xml --&gt;&lt;dependencies&gt;    &lt;!-- Spring Boot --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- 高德地图Java SDK --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.amap.api&lt;/groupId&gt;        &lt;artifactId&gt;amap-java-sdk&lt;/artifactId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- HTTP客户端 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- JSON处理 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- 其他工具 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- Lombok --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n核心控制器@RestController@RequestMapping(&quot;/api/tour&quot;)@RequiredArgsConstructor@Slf4jpublic class TourController &#123;    private final TourPlanningService tourPlanningService;    private final PoiSearchService poiSearchService;    private final RoutePlanningService routePlanningService;    @PostMapping(&quot;/plan&quot;)    public ResponseEntity&lt;TourPlanResponse&gt; createTourPlan(@Valid @RequestBody TourPlanRequest request) &#123;        log.info(&quot;创建旅游计划：&#123;&#125;&quot;, request.getDestination());        try &#123;            TourPlanResponse response = tourPlanningService.createTourPlan(request);            return ResponseEntity.ok(response);        &#125; catch (Exception e) &#123;            log.error(&quot;创建旅游计划失败&quot;, e);            return ResponseEntity.internalServerError()                .body(TourPlanResponse.error(&quot;创建旅游计划失败：&quot; + e.getMessage()));        &#125;    &#125;    @GetMapping(&quot;/attractions&quot;)    public ResponseEntity&lt;List&lt;PoiInfo&gt;&gt; searchAttractions(            @RequestParam String location,            @RequestParam(defaultValue = &quot;5000&quot;) int radius) &#123;        log.info(&quot;搜索景点：位置=&#123;&#125;, 半径=&#123;&#125;&quot;, location, radius);        try &#123;            List&lt;PoiInfo&gt; attractions = poiSearchService.searchNearbyAttractions(location, radius);            return ResponseEntity.ok(attractions);        &#125; catch (Exception e) &#123;            log.error(&quot;搜索景点失败&quot;, e);            return ResponseEntity.internalServerError().build();        &#125;    &#125;    @PostMapping(&quot;/route&quot;)    public ResponseEntity&lt;RouteResponse&gt; planRoute(@Valid @RequestBody RouteRequest request) &#123;        log.info(&quot;规划路线：从&#123;&#125;到&#123;&#125;&quot;, request.getOrigin(), request.getDestination());        try &#123;            RouteResponse response = routePlanningService.planRoute(request);            return ResponseEntity.ok(response);        &#125; catch (Exception e) &#123;            log.error(&quot;路线规划失败&quot;, e);            return ResponseEntity.internalServerError()                .body(RouteResponse.error(&quot;路线规划失败：&quot; + e.getMessage()));        &#125;    &#125;    @GetMapping(&quot;/attractions/search&quot;)    public ResponseEntity&lt;List&lt;PoiInfo&gt;&gt; searchAttractionsByKeyword(            @RequestParam String keyword,            @RequestParam String city) &#123;        log.info(&quot;关键词搜索景点：keyword=&#123;&#125;, city=&#123;&#125;&quot;, keyword, city);        try &#123;            List&lt;PoiInfo&gt; attractions = poiSearchService.searchAttractionsByKeyword(keyword, city);            return ResponseEntity.ok(attractions);        &#125; catch (Exception e) &#123;            log.error(&quot;关键词搜索景点失败&quot;, e);            return ResponseEntity.internalServerError().build();        &#125;    &#125;&#125;\n\n旅游路线规划服务@Service@Slf4jpublic class TourPlanningService &#123;    private final PoiSearchService poiSearchService;    private final RoutePlanningService routePlanningService;    private final GeocodingService geocodingService;    private final DistanceService distanceService;    public TourPlanningService(PoiSearchService poiSearchService,                             RoutePlanningService routePlanningService,                             GeocodingService geocodingService,                             DistanceService distanceService) &#123;        this.poiSearchService = poiSearchService;        this.routePlanningService = routePlanningService;        this.geocodingService = geocodingService;        this.distanceService = distanceService;    &#125;    public TourPlanResponse createTourPlan(TourPlanRequest request) &#123;        try &#123;            // 1. 搜索目的地附近的景点            List&lt;PoiInfo&gt; attractions = poiSearchService.searchNearbyAttractions(                request.getDestination(), request.getSearchRadius());            // 2. 根据偏好过滤景点            List&lt;PoiInfo&gt; filteredAttractions = filterAttractionsByPreferences(                attractions, request.getPreferences());            // 3. 智能排序景点            List&lt;PoiInfo&gt; sortedAttractions = sortAttractionsByPopularity(filteredAttractions);            // 4. 生成旅游路线            List&lt;TourDay&gt; tourDays = generateTourSchedule(                sortedAttractions, request.getDays(), request.getStartLocation());            // 5. 计算总距离和时间            TourStatistics statistics = calculateTourStatistics(tourDays);            return TourPlanResponse.builder()                .destination(request.getDestination())                .days(request.getDays())                .attractions(sortedAttractions)                .tourDays(tourDays)                .statistics(statistics)                .success(true)                .build();        &#125; catch (Exception e) &#123;            log.error(&quot;创建旅游计划失败&quot;, e);            return TourPlanResponse.error(&quot;创建旅游计划失败：&quot; + e.getMessage());        &#125;    &#125;    private List&lt;PoiInfo&gt; filterAttractionsByPreferences(List&lt;PoiInfo&gt; attractions,                                                       List&lt;String&gt; preferences) &#123;        if (preferences == null || preferences.isEmpty()) &#123;            return attractions;        &#125;        return attractions.stream()            .filter(attraction -&gt; preferences.stream()                .anyMatch(pref -&gt; attraction.getTag().contains(pref)))            .collect(Collectors.toList());    &#125;    private List&lt;PoiInfo&gt; sortAttractionsByPopularity(List&lt;PoiInfo&gt; attractions) &#123;        // 这里可以根据评分、评论数等指标进行排序        // 暂时按名称长度排序作为示例        return attractions.stream()            .sorted((a, b) -&gt; Integer.compare(b.getName().length(), a.getName().length()))            .collect(Collectors.toList());    &#125;    private List&lt;TourDay&gt; generateTourSchedule(List&lt;PoiInfo&gt; attractions, int days, String startLocation) &#123;        List&lt;TourDay&gt; tourDays = new ArrayList&lt;&gt;();        // 简单地将景点平均分配到每一天        int attractionsPerDay = (int) Math.ceil((double) attractions.size() / days);        for (int day = 1; day &lt;= days; day++) &#123;            int startIndex = (day - 1) * attractionsPerDay;            int endIndex = Math.min(startIndex + attractionsPerDay, attractions.size());            List&lt;PoiInfo&gt; dayAttractions = attractions.subList(startIndex, endIndex);            // 为每一天生成路线规划            List&lt;Route&gt; dayRoutes = new ArrayList&lt;&gt;();            if (!dayAttractions.isEmpty()) &#123;                dayRoutes = planDayRoutes(startLocation, dayAttractions);            &#125;            TourDay tourDay = TourDay.builder()                .day(day)                .attractions(dayAttractions)                .routes(dayRoutes)                .build();            tourDays.add(tourDay);        &#125;        return tourDays;    &#125;    private List&lt;Route&gt; planDayRoutes(String startLocation, List&lt;PoiInfo&gt; attractions) &#123;        List&lt;Route&gt; routes = new ArrayList&lt;&gt;();        String currentLocation = startLocation;        for (PoiInfo attraction : attractions) &#123;            try &#123;                RouteRequest routeRequest = RouteRequest.builder()                    .origin(currentLocation)                    .destination(attraction.getLocation())                    .transportMode(&quot;driving&quot;)                    .build();                RouteResponse routeResponse = routePlanningService.planRoute(routeRequest);                if (routeResponse.isSuccess()) &#123;                    routes.add(routeResponse.getRoute());                    currentLocation = attraction.getLocation();                &#125;            &#125; catch (Exception e) &#123;                log.warn(&quot;规划路线失败：&#123;&#125; -&gt; &#123;&#125;&quot;, currentLocation, attraction.getLocation(), e);            &#125;        &#125;        return routes;    &#125;    private TourStatistics calculateTourStatistics(List&lt;TourDay&gt; tourDays) &#123;        int totalAttractions = tourDays.stream()            .mapToInt(day -&gt; day.getAttractions().size())            .sum();        double totalDistance = tourDays.stream()            .flatMap(day -&gt; day.getRoutes().stream())            .mapToDouble(route -&gt; route.getDistance())            .sum();        long totalDuration = tourDays.stream()            .flatMap(day -&gt; day.getRoutes().stream())            .mapToLong(route -&gt; route.getDuration())            .sum();        return TourStatistics.builder()            .totalAttractions(totalAttractions)            .totalDistance(totalDistance)            .totalDuration(totalDuration)            .build();    &#125;&#125;\n\n应用配置# application.ymlspring:  application:    name: java-amap-tour-planning  profiles:    active: devserver:  port: 8080amap:  api-key: $&#123;AMAP_API_KEY:your-api-key-here&#125;  connect-timeout: 5000  read-timeout: 10000logging:  level:    com.example.amap: DEBUG    webapi.amap: INFOmanagement:  endpoints:    web:      exposure:        include: health,info,metrics  endpoint:    health:      show-details: when-authorized\n\n异常处理@ControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123;    @ExceptionHandler(AmapApiException.class)    public ResponseEntity&lt;ErrorResponse&gt; handleAmapApiException(AmapApiException e) &#123;        log.error(&quot;高德API异常&quot;, e);        return ResponseEntity.badRequest()            .body(ErrorResponse.builder()                .message(&quot;地图服务异常：&quot; + e.getMessage())                .timestamp(System.currentTimeMillis())                .build());    &#125;    @ExceptionHandler(Exception.class)    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception e) &#123;        log.error(&quot;系统异常&quot;, e);        return ResponseEntity.internalServerError()            .body(ErrorResponse.builder()                .message(&quot;系统内部错误，请稍后重试&quot;)                .timestamp(System.currentTimeMillis())                .build());    &#125;&#125;\n\n部署和优化Docker部署# DockerfileFROM openjdk:17-jdk-slimWORKDIR /appCOPY target/*.jar app.jarEXPOSE 8080CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;app.jar&quot;]\n\n# docker-compose.ymlversion: &#x27;3.8&#x27;services:  amap-tour-app:    build: .    ports:      - &quot;8080:8080&quot;    environment:      - AMAP_API_KEY=$&#123;AMAP_API_KEY&#125;    restart: unless-stopped\n\n性能优化策略\n缓存机制\n@Configuration@EnableCachingpublic class CacheConfig &#123;    @Bean    public CacheManager cacheManager() &#123;        CaffeineCacheManager cacheManager = new CaffeineCacheManager();        cacheManager.setCaffeine(Caffeine.newBuilder()            .maximumSize(1000)            .expireAfterWrite(Duration.ofMinutes(30))            .recordStats());        return cacheManager;    &#125;&#125;@Service@Cacheable(&quot;poi-search&quot;)public List&lt;PoiInfo&gt; cachedPoiSearch(String location, int radius) &#123;    return poiSearchService.searchNearbyAttractions(location, radius);&#125;\n异步处理\n@Servicepublic class AsyncTourService &#123;    @Async    public CompletableFuture&lt;TourPlanResponse&gt; createTourPlanAsync(TourPlanRequest request) &#123;        return CompletableFuture.supplyAsync(() -&gt;            tourPlanningService.createTourPlan(request));    &#125;    public CompletableFuture&lt;List&lt;PoiInfo&gt;&gt; searchAttractionsAsync(String location, int radius) &#123;        return CompletableFuture.supplyAsync(() -&gt;            poiSearchService.searchNearbyAttractions(location, radius));    &#125;&#125;\n\n最佳实践1. API密钥安全管理@Configurationpublic class AmapConfig &#123;    @Bean    @ConfigurationProperties(prefix = &quot;amap&quot;)    public AmapProperties amapProperties() &#123;        return new AmapProperties();    &#125;    @Bean    public AmapClient amapClient(AmapProperties properties,                                @Value(&quot;$&#123;amap.api-key&#125;&quot;) String apiKey) &#123;        return AmapClient.builder()            .apiKey(apiKey)            .connectTimeout(properties.getConnectTimeout())            .readTimeout(properties.getReadTimeout())            .build();    &#125;&#125;@Data@ConfigurationProperties(prefix = &quot;amap&quot;)public class AmapProperties &#123;    private int connectTimeout = 5000;    private int readTimeout = 10000;    private String apiKey;&#125;\n\n2. 请求限流@Configurationpublic class RateLimitConfig &#123;    @Bean    public RateLimiter amapRateLimiter() &#123;        return RateLimiter.create(100.0); // 每秒100个请求    &#125;&#125;@Aspect@Componentpublic class RateLimitAspect &#123;    private final RateLimiter rateLimiter;    public RateLimitAspect(RateLimiter rateLimiter) &#123;        this.rateLimiter = rateLimiter;    &#125;    @Around(&quot;@annotation(com.example.amap.annotation.RateLimited)&quot;)    public Object rateLimit(ProceedingJoinPoint joinPoint) throws Throwable &#123;        if (!rateLimiter.tryAcquire()) &#123;            throw new RuntimeException(&quot;请求过于频繁，请稍后再试&quot;);        &#125;        return joinPoint.proceed();    &#125;&#125;\n\n3. 监控和告警@Servicepublic class AmapMetricsService &#123;    private final Counter apiCallCounter;    private final Counter apiErrorCounter;    private final Timer apiCallTimer;    public AmapMetricsService(MeterRegistry registry) &#123;        this.apiCallCounter = Counter.builder(&quot;amap.api.calls&quot;)            .description(&quot;Number of Amap API calls&quot;)            .register(registry);        this.apiErrorCounter = Counter.builder(&quot;amap.api.errors&quot;)            .description(&quot;Number of Amap API errors&quot;)            .register(registry);        this.apiCallTimer = Timer.builder(&quot;amap.api.duration&quot;)            .description(&quot;Amap API call duration&quot;)            .register(registry);    &#125;    public &lt;T&gt; T executeWithMetrics(Supplier&lt;T&gt; supplier, String operation) &#123;        apiCallCounter.increment();        return apiCallTimer.recordCallable(() -&gt; &#123;            try &#123;                return supplier.get();            &#125; catch (Exception e) &#123;                apiErrorCounter.increment();                throw e;            &#125;        &#125;);    &#125;&#125;\n\n总结与注意事项技术要点总结\n高德地图MCP是中国领先的地图服务平台，提供丰富的地理信息服务\nJava SDK提供了完整的Java封装，支持POI搜索、路径规划、地理编码等功能\nSpring Boot集成可以快速构建企业级的旅游路线规划应用\n性能优化通过缓存、异步处理等手段提升系统响应速度\n监控告警确保系统稳定运行和问题及时发现\n\n使用注意事项\n合理管理API调用频率，避免超出高德地图的限制\n注意数据安全和隐私保护，遵守相关法律法规\n在生产环境中使用HTTPS进行API调用\n定期更新高德地图SDK版本，获取最新功能和安全补丁\n监控API调用情况和系统性能指标\n\n扩展阅读建议\n深入学习高德地图MCP官方文档\n了解地理信息系统（GIS）的相关概念\n学习Spring Boot微服务架构\n研究地图可视化和交互设计\n关注旅游行业数字化转型趋势\n\n通过本文的介绍，你已经掌握了使用Java集成高德地图MCP开发定制旅游路线系统的核心技能。高德地图MCP以其丰富的数据资源和稳定的服务，为旅游应用开发提供了坚实的技术基础。\n参考资料\n高德地图MCP官方文档\n高德地图Java SDK\nSpring Boot官方文档\n地理编码服务指南\n路径规划API文档\nPOI搜索API文档\nDocker最佳实践\nSpring Cloud限流指南\n\n","tags":["Java","Spring Boot","高德地图","旅游路线","MCP","地理信息"]},{"title":"Java异常日志MCP服务架构","url":"/2025/01/20/0.5.5-Java%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97MCP%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/","content":"\n在微服务架构中，异常日志不仅是问题排查的重要线索，更是AI辅助诊断的宝贵数据源。本文将详细介绍如何构建完整的Java异常日志捕获、存储和MCP服务架构，让大模型能够智能分析和处理异常信息。\n\n🎯 架构概览系统架构图[Java应用] → [异常捕获] → [日志结构化] → [MongoDB存储]      ↓              ↓              ↓              ↓[业务逻辑] → [AOP拦截] → [日志模型] → [索引优化]      ↓              ↓              ↓              ↓[监控告警] → [实时分析] → [MCP服务] → [大模型调用]\n\n核心组件说明📋 技术栈选型核心技术栈\nSpring Boot 2.7+: 微服务框架\nMongoDB 5.0+: 文档型数据库\nSpring AOP: 异常拦截\nMCP (Model Context Protocol): 大模型服务协议\nJackson: JSON序列化\nSLF4J + Logback: 日志框架\n\n依赖版本&lt;properties&gt;    &lt;java.version&gt;17&lt;/java.version&gt;    &lt;spring-boot.version&gt;2.7.18&lt;/spring-boot.version&gt;    &lt;mongodb.version&gt;4.11.1&lt;/mongodb.version&gt;    &lt;jackson.version&gt;2.15.3&lt;/jackson.version&gt;&lt;/properties&gt;\n\n🔧 核心实现1. 异常日志模型设计基础异常信息模型@Data@Document(collection = &quot;exception_logs&quot;)public class ExceptionLog &#123;    @Id    private String id;    // 基础信息    private String applicationName;    private String serviceName;    private String instanceId;    // 异常信息    private String exceptionType;    private String exceptionMessage;    private String stackTrace;    // 业务上下文    private String userId;    private String requestId;    private String sessionId;    private String traceId;    // 请求信息    private String httpMethod;    private String requestUri;    private String clientIp;    private Map&lt;String, String&gt; requestHeaders;    private Map&lt;String, Object&gt; requestParams;    private Map&lt;String, Object&gt; requestBody;    // 系统信息    private String serverName;    private String serverIp;    private Integer serverPort;    private String environment;    // 性能信息    private Long executionTime;    private Long memoryUsage;    private Integer threadCount;    // 时间信息    private LocalDateTime exceptionTime;    private LocalDateTime createTime;    // 状态信息    private ExceptionStatus status;    private String resolution;    private Integer occurrenceCount;    // 分类信息    private ExceptionCategory category;    private ExceptionSeverity severity;    private List&lt;String&gt; tags;    // AI分析结果    private String aiAnalysis;    private List&lt;String&gt; suggestions;    private String similarExceptions;&#125;\n\n异常状态枚举public enum ExceptionStatus &#123;    NEW(&quot;新异常&quot;),    ANALYZING(&quot;分析中&quot;),    RESOLVED(&quot;已解决&quot;),    IGNORED(&quot;已忽略&quot;),    RECURRING(&quot;重复出现&quot;);    private final String description;    ExceptionStatus(String description) &#123;        this.description = description;    &#125;&#125;\n\n异常分类枚举public enum ExceptionCategory &#123;    BUSINESS_EXCEPTION(&quot;业务异常&quot;),    SYSTEM_EXCEPTION(&quot;系统异常&quot;),    NETWORK_EXCEPTION(&quot;网络异常&quot;),    DATABASE_EXCEPTION(&quot;数据库异常&quot;),    SECURITY_EXCEPTION(&quot;安全异常&quot;),    PERFORMANCE_EXCEPTION(&quot;性能异常&quot;),    THIRD_PARTY_EXCEPTION(&quot;第三方服务异常&quot;),    UNKNOWN(&quot;未知异常&quot;);&#125;\n\n异常严重程度枚举public enum ExceptionSeverity &#123;    LOW(&quot;低&quot;),    MEDIUM(&quot;中&quot;),    HIGH(&quot;高&quot;),    CRITICAL(&quot;严重&quot;);    private final String description;    ExceptionSeverity(String description) &#123;        this.description = description;    &#125;&#125;\n\n2. 全局异常捕获器全局异常处理器@RestControllerAdvice@Slf4jpublic class GlobalExceptionHandler &#123;    @Autowired    private ExceptionLogService exceptionLogService;    @Autowired    private RequestContextHolder requestContextHolder;    /**     * 处理所有未捕获的异常     */    @ExceptionHandler(Exception.class)    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)    public ResponseEntity&lt;ErrorResponse&gt; handleException(Exception ex, HttpServletRequest request) &#123;        // 创建异常日志        ExceptionLog exceptionLog = createExceptionLog(ex, request, ExceptionCategory.SYSTEM_EXCEPTION, ExceptionSeverity.HIGH);        // 异步保存异常日志        CompletableFuture.runAsync(() -&gt; &#123;            try &#123;                exceptionLogService.saveAsync(exceptionLog);            &#125; catch (Exception e) &#123;                log.error(&quot;保存异常日志失败&quot;, e);            &#125;        &#125;);        // 返回错误响应        ErrorResponse errorResponse = ErrorResponse.builder()                .success(false)                .errorCode(&quot;SYSTEM_ERROR&quot;)                .message(&quot;系统内部错误，请联系管理员&quot;)                .requestId(exceptionLog.getRequestId())                .timestamp(LocalDateTime.now())                .build();        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);    &#125;    /**     * 处理业务异常     */    @ExceptionHandler(BusinessException.class)    public ResponseEntity&lt;ErrorResponse&gt; handleBusinessException(BusinessException ex, HttpServletRequest request) &#123;        ExceptionLog exceptionLog = createExceptionLog(ex, request, ExceptionCategory.BUSINESS_EXCEPTION, ex.getSeverity());        // 异步保存        exceptionLogService.saveAsync(exceptionLog);        ErrorResponse errorResponse = ErrorResponse.builder()                .success(false)                .errorCode(ex.getErrorCode())                .message(ex.getMessage())                .requestId(exceptionLog.getRequestId())                .timestamp(LocalDateTime.now())                .build();        return ResponseEntity.status(ex.getHttpStatus()).body(errorResponse);    &#125;    /**     * 创建异常日志对象     */    private ExceptionLog createExceptionLog(Exception ex, HttpServletRequest request,                                          ExceptionCategory category, ExceptionSeverity severity) &#123;        // 获取请求上下文        RequestContext context = requestContextHolder.getContext();        return ExceptionLog.builder()                .applicationName(getApplicationName())                .serviceName(getServiceName())                .instanceId(getInstanceId())                .exceptionType(ex.getClass().getSimpleName())                .exceptionMessage(ex.getMessage())                .stackTrace(getStackTrace(ex))                .userId(context.getUserId())                .requestId(context.getRequestId())                .sessionId(context.getSessionId())                .traceId(context.getTraceId())                .httpMethod(request.getMethod())                .requestUri(request.getRequestURI())                .clientIp(getClientIp(request))                .requestHeaders(getRequestHeaders(request))                .requestParams(getRequestParams(request))                .requestBody(context.getRequestBody())                .serverName(getServerName())                .serverIp(getServerIp())                .serverPort(request.getServerPort())                .environment(getEnvironment())                .executionTime(context.getExecutionTime())                .memoryUsage(getMemoryUsage())                .threadCount(getThreadCount())                .exceptionTime(LocalDateTime.now())                .createTime(LocalDateTime.now())                .status(ExceptionStatus.NEW)                .category(category)                .severity(severity)                .tags(generateTags(ex))                .build();    &#125;    // 辅助方法    private String getStackTrace(Exception ex) &#123;        StringWriter sw = new StringWriter();        PrintWriter pw = new PrintWriter(sw);        ex.printStackTrace(pw);        return sw.toString();    &#125;    private String getClientIp(HttpServletRequest request) &#123;        String xForwardedFor = request.getHeader(&quot;X-Forwarded-For&quot;);        if (xForwardedFor != null &amp;&amp; !xForwardedFor.isEmpty()) &#123;            return xForwardedFor.split(&quot;,&quot;)[0].trim();        &#125;        return request.getRemoteAddr();    &#125;    private List&lt;String&gt; generateTags(Exception ex) &#123;        List&lt;String&gt; tags = new ArrayList&lt;&gt;();        tags.add(ex.getClass().getSimpleName());        // 根据异常类型添加标签        if (ex instanceof SQLException) &#123;            tags.add(&quot;database&quot;);            tags.add(&quot;sql&quot;);        &#125; else if (ex instanceof IOException) &#123;            tags.add(&quot;io&quot;);            tags.add(&quot;file&quot;);        &#125; else if (ex instanceof TimeoutException) &#123;            tags.add(&quot;timeout&quot;);            tags.add(&quot;performance&quot;);        &#125;        return tags;    &#125;&#125;\n\n业务异常基类@Getterpublic class BusinessException extends RuntimeException &#123;    private final String errorCode;    private final HttpStatus httpStatus;    private final ExceptionSeverity severity;    private final Map&lt;String, Object&gt; context;    public BusinessException(String errorCode, String message) &#123;        super(message);        this.errorCode = errorCode;        this.httpStatus = HttpStatus.BAD_REQUEST;        this.severity = ExceptionSeverity.MEDIUM;        this.context = new HashMap&lt;&gt;();    &#125;    public BusinessException(String errorCode, String message, HttpStatus httpStatus) &#123;        super(message);        this.errorCode = errorCode;        this.httpStatus = httpStatus;        this.severity = httpStatus.is5xxServerError() ? ExceptionSeverity.HIGH : ExceptionSeverity.MEDIUM;        this.context = new HashMap&lt;&gt;();    &#125;    public BusinessException(String errorCode, String message, Throwable cause) &#123;        super(message, cause);        this.errorCode = errorCode;        this.httpStatus = HttpStatus.INTERNAL_SERVER_ERROR;        this.severity = ExceptionSeverity.HIGH;        this.context = new HashMap&lt;&gt;();    &#125;    public BusinessException addContext(String key, Object value) &#123;        this.context.put(key, value);        return this;    &#125;&#125;\n\n3. MongoDB存储服务MongoDB配置@Configurationpublic class MongoConfig &#123;    @Bean    public MongoTemplate mongoTemplate(MongoDatabaseFactory databaseFactory) &#123;        MappingMongoConverter converter = new MappingMongoConverter(new DefaultDbRefResolver(databaseFactory), new MongoMappingContext());        converter.setCustomConversions(customConversions());        converter.afterPropertiesSet();        MongoTemplate mongoTemplate = new MongoTemplate(databaseFactory, converter);        // 创建索引        createIndexes(mongoTemplate);        return mongoTemplate;    &#125;    private CustomConversions customConversions() &#123;        List&lt;Converter&lt;?, ?&gt;&gt; converters = new ArrayList&lt;&gt;();        converters.add(new LocalDateTimeToStringConverter());        converters.add(new StringToLocalDateTimeConverter());        return new CustomConversions(converters);    &#125;    private void createIndexes(MongoTemplate mongoTemplate) &#123;        // 复合索引：异常类型 + 时间        mongoTemplate.indexOps(ExceptionLog.class)                .ensureIndex(new Index()                        .on(&quot;exceptionType&quot;, Sort.Direction.ASC)                        .on(&quot;exceptionTime&quot;, Sort.Direction.DESC)                        .named(&quot;exception_type_time&quot;));        // 时间索引        mongoTemplate.indexOps(ExceptionLog.class)                .ensureIndex(new Index()                        .on(&quot;exceptionTime&quot;, Sort.Direction.DESC)                        .expire(30 * 24 * 60 * 60) // 30天后自动删除                        .named(&quot;exception_time_ttl&quot;));        // 状态索引        mongoTemplate.indexOps(ExceptionLog.class)                .ensureIndex(new Index()                        .on(&quot;status&quot;, Sort.Direction.ASC)                        .named(&quot;exception_status&quot;));        // 用户ID索引        mongoTemplate.indexOps(ExceptionLog.class)                .ensureIndex(new Index()                        .on(&quot;userId&quot;, Sort.Direction.ASC)                        .named(&quot;user_id&quot;));        // 请求ID索引        mongoTemplate.indexOps(ExceptionLog.class)                .ensureIndex(new Index()                        .on(&quot;requestId&quot;, Sort.Direction.ASC)                        .named(&quot;request_id&quot;));    &#125;&#125;\n\n异常日志服务@Service@Slf4jpublic class ExceptionLogService &#123;    @Autowired    private MongoTemplate mongoTemplate;    @Autowired    private ApplicationEventPublisher eventPublisher;    /**     * 同步保存异常日志     */    public ExceptionLog save(ExceptionLog exceptionLog) &#123;        try &#123;            // 设置创建时间            exceptionLog.setCreateTime(LocalDateTime.now());            // 检查是否为重复异常            checkDuplicateException(exceptionLog);            // 保存到MongoDB            ExceptionLog saved = mongoTemplate.save(exceptionLog);            // 发布异常事件            eventPublisher.publishEvent(new ExceptionLoggedEvent(saved));            log.info(&quot;异常日志保存成功: &#123;&#125;&quot;, saved.getId());            return saved;        &#125; catch (Exception e) &#123;            log.error(&quot;保存异常日志失败&quot;, e);            throw new RuntimeException(&quot;保存异常日志失败&quot;, e);        &#125;    &#125;    /**     * 异步保存异常日志     */    @Async    public CompletableFuture&lt;Void&gt; saveAsync(ExceptionLog exceptionLog) &#123;        return CompletableFuture.runAsync(() -&gt; &#123;            try &#123;                save(exceptionLog);            &#125; catch (Exception e) &#123;                log.error(&quot;异步保存异常日志失败&quot;, e);            &#125;        &#125;);    &#125;    /**     * 批量保存异常日志     */    public List&lt;ExceptionLog&gt; saveBatch(List&lt;ExceptionLog&gt; exceptionLogs) &#123;        try &#123;            return (List&lt;ExceptionLog&gt;) mongoTemplate.insertAll(exceptionLogs);        &#125; catch (Exception e) &#123;            log.error(&quot;批量保存异常日志失败&quot;, e);            throw new RuntimeException(&quot;批量保存异常日志失败&quot;, e);        &#125;    &#125;    /**     * 检查重复异常     */    private void checkDuplicateException(ExceptionLog exceptionLog) &#123;        // 查询最近24小时内相同类型的异常        LocalDateTime startTime = LocalDateTime.now().minusHours(24);        Query query = Query.query(Criteria.where(&quot;exceptionType&quot;).is(exceptionLog.getExceptionType())                .and(&quot;exceptionMessage&quot;).is(exceptionLog.getExceptionMessage())                .and(&quot;exceptionTime&quot;).gte(startTime));        List&lt;ExceptionLog&gt; similarExceptions = mongoTemplate.find(query, ExceptionLog.class);        if (!similarExceptions.isEmpty()) &#123;            // 更新第一个异常的发生次数            ExceptionLog firstException = similarExceptions.get(0);            firstException.setOccurrenceCount(firstException.getOccurrenceCount() + 1);            mongoTemplate.save(firstException);            // 将当前异常标记为重复            exceptionLog.setStatus(ExceptionStatus.RECURRING);            exceptionLog.setSimilarExceptions(firstException.getId());        &#125;    &#125;    /**     * 根据ID查询异常日志     */    public Optional&lt;ExceptionLog&gt; findById(String id) &#123;        try &#123;            return Optional.ofNullable(mongoTemplate.findById(id, ExceptionLog.class));        &#125; catch (Exception e) &#123;            log.error(&quot;查询异常日志失败: &#123;&#125;&quot;, id, e);            return Optional.empty();        &#125;    &#125;    /**     * 分页查询异常日志     */    public Page&lt;ExceptionLog&gt; findAll(Pageable pageable) &#123;        try &#123;            Query query = new Query().with(pageable);            List&lt;ExceptionLog&gt; content = mongoTemplate.find(query, ExceptionLog.class);            long total = mongoTemplate.count(query, ExceptionLog.class);            return new PageImpl&lt;&gt;(content, pageable, total);        &#125; catch (Exception e) &#123;            log.error(&quot;分页查询异常日志失败&quot;, e);            return new PageImpl&lt;&gt;(Collections.emptyList(), pageable, 0);        &#125;    &#125;    /**     * 根据条件查询异常日志     */    public List&lt;ExceptionLog&gt; findByCriteria(ExceptionLogCriteria criteria) &#123;        try &#123;            Query query = buildQuery(criteria);            return mongoTemplate.find(query, ExceptionLog.class);        &#125; catch (Exception e) &#123;            log.error(&quot;根据条件查询异常日志失败&quot;, e);            return Collections.emptyList();        &#125;    &#125;    /**     * 构建查询条件     */    private Query buildQuery(ExceptionLogCriteria criteria) &#123;        Query query = new Query();        if (StringUtils.hasText(criteria.getExceptionType())) &#123;            query.addCriteria(Criteria.where(&quot;exceptionType&quot;).is(criteria.getExceptionType()));        &#125;        if (criteria.getStatus() != null) &#123;            query.addCriteria(Criteria.where(&quot;status&quot;).is(criteria.getStatus()));        &#125;        if (criteria.getCategory() != null) &#123;            query.addCriteria(Criteria.where(&quot;category&quot;).is(criteria.getCategory()));        &#125;        if (criteria.getSeverity() != null) &#123;            query.addCriteria(Criteria.where(&quot;severity&quot;).is(criteria.getSeverity()));        &#125;        if (StringUtils.hasText(criteria.getUserId())) &#123;            query.addCriteria(Criteria.where(&quot;userId&quot;).is(criteria.getUserId()));        &#125;        if (criteria.getStartTime() != null &amp;&amp; criteria.getEndTime() != null) &#123;            query.addCriteria(Criteria.where(&quot;exceptionTime&quot;)                    .gte(criteria.getStartTime())                    .lte(criteria.getEndTime()));        &#125;        if (criteria.getTags() != null &amp;&amp; !criteria.getTags().isEmpty()) &#123;            query.addCriteria(Criteria.where(&quot;tags&quot;).in(criteria.getTags()));        &#125;        return query;    &#125;    /**     * 更新异常状态     */    public boolean updateStatus(String id, ExceptionStatus status, String resolution) &#123;        try &#123;            Query query = Query.query(Criteria.where(&quot;_id&quot;).is(new ObjectId(id)));            Update update = new Update()                    .set(&quot;status&quot;, status)                    .set(&quot;resolution&quot;, resolution);            UpdateResult result = mongoTemplate.updateFirst(query, update, ExceptionLog.class);            return result.getModifiedCount() &gt; 0;        &#125; catch (Exception e) &#123;            log.error(&quot;更新异常状态失败: &#123;&#125;&quot;, id, e);            return false;        &#125;    &#125;    /**     * 获取异常统计信息     */    public ExceptionStatistics getStatistics(LocalDateTime startTime, LocalDateTime endTime) &#123;        try &#123;            MatchOperation matchOperation = Aggregation.match(                    Criteria.where(&quot;exceptionTime&quot;).gte(startTime).lte(endTime)            );            GroupOperation groupOperation = Aggregation.group()                    .count().as(&quot;totalCount&quot;)                    .addToSet(&quot;exceptionType&quot;).as(&quot;exceptionTypes&quot;)                    .addToSet(&quot;category&quot;).as(&quot;categories&quot;)                    .addToSet(&quot;severity&quot;).as(&quot;severities&quot;);            Aggregation aggregation = Aggregation.newAggregation(matchOperation, groupOperation);            AggregationResults&lt;ExceptionStatistics&gt; results = mongoTemplate.aggregate(aggregation, &quot;exception_logs&quot;, ExceptionStatistics.class);            return results.getUniqueMappedResult();        &#125; catch (Exception e) &#123;            log.error(&quot;获取异常统计信息失败&quot;, e);            return new ExceptionStatistics();        &#125;    &#125;&#125;\n\n4. MCP服务接口MCP服务配置@Configuration@EnableMcpServerpublic class McpServerConfig &#123;    @Bean    public McpServerTransport mcpServerTransport() &#123;        return new StdioServerTransport();    &#125;    @Bean    public McpServerCapabilities serverCapabilities() &#123;        return McpServerCapabilities.builder()                .tools(true)                .resources(true)                .prompts(true)                .logging(true)                .build();    &#125;&#125;\n\n异常分析工具@Component@Tool@Slf4jpublic class ExceptionAnalysisTool &#123;    @Autowired    private ExceptionLogService exceptionLogService;    @Autowired    private AiAnalysisService aiAnalysisService;    /**     * 分析异常日志     */    @ToolMethod(description = &quot;分析指定的异常日志，提供解决方案建议&quot;)    public String analyzeException(            @ToolParameter(description = &quot;异常日志ID&quot;) String exceptionId,            @ToolParameter(description = &quot;是否需要详细分析&quot;, required = false) Boolean detailed) &#123;        try &#123;            // 查询异常日志            Optional&lt;ExceptionLog&gt; exceptionLogOpt = exceptionLogService.findById(exceptionId);            if (!exceptionLogOpt.isPresent()) &#123;                return &quot;未找到指定的异常日志&quot;;            &#125;            ExceptionLog exceptionLog = exceptionLogOpt.get();            // 基本信息分析            StringBuilder analysis = new StringBuilder();            analysis.append(&quot;🔍 异常分析报告\\n&quot;);            analysis.append(&quot;================\\n\\n&quot;);            analysis.append(String.format(&quot;异常类型: %s\\n&quot;, exceptionLog.getExceptionType()));            analysis.append(String.format(&quot;异常消息: %s\\n&quot;, exceptionLog.getExceptionMessage()));            analysis.append(String.format(&quot;发生时间: %s\\n&quot;, exceptionLog.getExceptionTime()));            analysis.append(String.format(&quot;严重程度: %s\\n&quot;, exceptionLog.getSeverity()));            analysis.append(String.format(&quot;异常分类: %s\\n&quot;, exceptionLog.getCategory()));            analysis.append(String.format(&quot;服务名称: %s\\n&quot;, exceptionLog.getServiceName()));            analysis.append(String.format(&quot;请求URI: %s %s\\n&quot;, exceptionLog.getHttpMethod(), exceptionLog.getRequestUri()));            if (StringUtils.hasText(exceptionLog.getUserId())) &#123;                analysis.append(String.format(&quot;用户ID: %s\\n&quot;, exceptionLog.getUserId()));            &#125;            analysis.append(&quot;\\n📋 堆栈跟踪:\\n&quot;);            analysis.append(exceptionLog.getStackTrace());            // AI分析（如果需要详细分析）            if (Boolean.TRUE.equals(detailed)) &#123;                analysis.append(&quot;\\n🤖 AI分析结果:\\n&quot;);                try &#123;                    String aiAnalysis = aiAnalysisService.analyzeException(exceptionLog);                    analysis.append(aiAnalysis);                    // 保存AI分析结果                    exceptionLog.setAiAnalysis(aiAnalysis);                    exceptionLogService.save(exceptionLog);                &#125; catch (Exception e) &#123;                    analysis.append(&quot;AI分析失败: &quot;).append(e.getMessage());                &#125;            &#125;            return analysis.toString();        &#125; catch (Exception e) &#123;            log.error(&quot;分析异常日志失败&quot;, e);            return &quot;分析异常日志时发生错误: &quot; + e.getMessage();        &#125;    &#125;    /**     * 查询异常统计     */    @ToolMethod(description = &quot;查询指定时间范围内的异常统计信息&quot;)    public String getExceptionStatistics(            @ToolParameter(description = &quot;开始时间，格式：yyyy-MM-dd HH:mm:ss&quot;) String startTimeStr,            @ToolParameter(description = &quot;结束时间，格式：yyyy-MM-dd HH:mm:ss&quot;) String endTimeStr) &#123;        try &#123;            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);            LocalDateTime startTime = LocalDateTime.parse(startTimeStr, formatter);            LocalDateTime endTime = LocalDateTime.parse(endTimeStr, formatter);            ExceptionStatistics statistics = exceptionLogService.getStatistics(startTime, endTime);            StringBuilder result = new StringBuilder();            result.append(&quot;📊 异常统计报告\\n&quot;);            result.append(&quot;================\\n\\n&quot;);            result.append(String.format(&quot;统计时间: %s 至 %s\\n&quot;, startTimeStr, endTimeStr));            result.append(String.format(&quot;总异常数: %d\\n&quot;, statistics.getTotalCount()));            if (statistics.getExceptionTypes() != null) &#123;                result.append(String.format(&quot;异常类型数: %d\\n&quot;, statistics.getExceptionTypes().size()));                result.append(&quot;主要异常类型:\\n&quot;);                statistics.getExceptionTypes().stream()                        .limit(10)                        .forEach(type -&gt; result.append(String.format(&quot;  - %s\\n&quot;, type)));            &#125;            if (statistics.getCategories() != null) &#123;                result.append(&quot;\\n异常分类:\\n&quot;);                statistics.getCategories().forEach(category -&gt;                        result.append(String.format(&quot;  - %s\\n&quot;, category)));            &#125;            if (statistics.getSeverities() != null) &#123;                result.append(&quot;\\n严重程度分布:\\n&quot;);                statistics.getSeverities().forEach(severity -&gt;                        result.append(String.format(&quot;  - %s\\n&quot;, severity)));            &#125;            return result.toString();        &#125; catch (Exception e) &#123;            log.error(&quot;查询异常统计失败&quot;, e);            return &quot;查询异常统计时发生错误: &quot; + e.getMessage();        &#125;    &#125;    /**     * 搜索相似异常     */    @ToolMethod(description = &quot;搜索与指定异常相似的历史异常&quot;)    public String findSimilarExceptions(            @ToolParameter(description = &quot;异常类型&quot;) String exceptionType,            @ToolParameter(description = &quot;异常消息&quot;) String exceptionMessage,            @ToolParameter(description = &quot;最大返回数量&quot;, required = false) Integer limit) &#123;        try &#123;            if (limit == null) &#123;                limit = 10;            &#125;            // 构建搜索条件            ExceptionLogCriteria criteria = ExceptionLogCriteria.builder()                    .exceptionType(exceptionType)                    .startTime(LocalDateTime.now().minusDays(30)) // 最近30天                    .endTime(LocalDateTime.now())                    .build();            List&lt;ExceptionLog&gt; similarExceptions = exceptionLogService.findByCriteria(criteria);            StringBuilder result = new StringBuilder();            result.append(&quot;🔍 相似异常搜索结果\\n&quot;);            result.append(&quot;===================\\n\\n&quot;);            result.append(String.format(&quot;搜索条件: %s\\n&quot;, exceptionType));            result.append(String.format(&quot;找到异常数: %d\\n\\n&quot;, similarExceptions.size()));            // 显示前N个相似异常            similarExceptions.stream()                    .limit(limit)                    .forEach(ex -&gt; &#123;                        result.append(String.format(&quot;ID: %s\\n&quot;, ex.getId()));                        result.append(String.format(&quot;时间: %s\\n&quot;, ex.getExceptionTime()));                        result.append(String.format(&quot;消息: %s\\n&quot;, ex.getExceptionMessage()));                        result.append(String.format(&quot;状态: %s\\n&quot;, ex.getStatus()));                        result.append(String.format(&quot;用户: %s\\n&quot;, ex.getUserId() != null ? ex.getUserId() : &quot;未知&quot;));                        result.append(&quot;---\\n&quot;);                    &#125;);            return result.toString();        &#125; catch (Exception e) &#123;            log.error(&quot;搜索相似异常失败&quot;, e);            return &quot;搜索相似异常时发生错误: &quot; + e.getMessage();        &#125;    &#125;    /**     * 获取异常趋势分析     */    @ToolMethod(description = &quot;分析异常发生趋势和模式&quot;)    public String getExceptionTrends(            @ToolParameter(description = &quot;分析天数&quot;, required = false) Integer days) &#123;        try &#123;            if (days == null) &#123;                days = 7;            &#125;            LocalDateTime endTime = LocalDateTime.now();            LocalDateTime startTime = endTime.minusDays(days);            // 按天统计异常数量            List&lt;ExceptionTrend&gt; trends = getExceptionTrendsByDay(startTime, endTime);            StringBuilder result = new StringBuilder();            result.append(&quot;📈 异常趋势分析\\n&quot;);            result.append(&quot;===============\\n\\n&quot;);            result.append(String.format(&quot;分析周期: 最近%d天\\n&quot;, days));            result.append(String.format(&quot;数据点数: %d\\n\\n&quot;, trends.size()));            result.append(&quot;日期\\t\\t异常数量\\t主要类型\\n&quot;);            result.append(&quot;----------------------------------------\\n&quot;);            for (ExceptionTrend trend : trends) &#123;                result.append(String.format(&quot;%s\\t%d\\t\\t%s\\n&quot;,                        trend.getDate().toLocalDate(),                        trend.getCount(),                        trend.getTopExceptionType() != null ? trend.getTopExceptionType() : &quot;无&quot;));            &#125;            return result.toString();        &#125; catch (Exception e) &#123;            log.error(&quot;获取异常趋势失败&quot;, e);            return &quot;获取异常趋势时发生错误: &quot; + e.getMessage();        &#125;    &#125;    private List&lt;ExceptionTrend&gt; getExceptionTrendsByDay(LocalDateTime startTime, LocalDateTime endTime) &#123;        // 这里实现按天统计异常数量的逻辑        // 使用MongoDB聚合管道实现        return new ArrayList&lt;&gt;();    &#125;&#125;\n\nMCP资源处理器@Component@Resource@Slf4jpublic class ExceptionLogResource &#123;    @Autowired    private ExceptionLogService exceptionLogService;    /**     * 获取最新的异常日志     */    @ResourceMethod(uri = &quot;logs://exceptions/latest&quot;, description = &quot;获取最新的异常日志&quot;)    public String getLatestExceptions(            @ResourceParameter(description = &quot;获取数量&quot;, required = false) Integer limit) &#123;        try &#123;            if (limit == null) &#123;                limit = 10;            &#125;            PageRequest pageRequest = PageRequest.of(0, limit, Sort.by(&quot;exceptionTime&quot;).descending());            Page&lt;ExceptionLog&gt; page = exceptionLogService.findAll(pageRequest);            StringBuilder result = new StringBuilder();            result.append(&quot;📋 最新异常日志\\n&quot;);            result.append(&quot;===============\\n\\n&quot;);            for (ExceptionLog log : page.getContent()) &#123;                result.append(String.format(&quot;时间: %s\\n&quot;, log.getExceptionTime()));                result.append(String.format(&quot;类型: %s\\n&quot;, log.getExceptionType()));                result.append(String.format(&quot;消息: %s\\n&quot;, log.getExceptionMessage()));                result.append(String.format(&quot;严重程度: %s\\n&quot;, log.getSeverity()));                result.append(String.format(&quot;状态: %s\\n&quot;, log.getStatus()));                result.append(&quot;---\\n&quot;);            &#125;            return result.toString();        &#125; catch (Exception e) &#123;            log.error(&quot;获取最新异常日志失败&quot;, e);            return &quot;获取最新异常日志时发生错误: &quot; + e.getMessage();        &#125;    &#125;    /**     * 获取异常日志详情     */    @ResourceMethod(uri = &quot;logs://exceptions/&#123;id&#125;&quot;, description = &quot;获取指定ID的异常日志详情&quot;)    public String getExceptionDetails(@ResourceParameter(description = &quot;异常日志ID&quot;) String id) &#123;        try &#123;            Optional&lt;ExceptionLog&gt; exceptionLogOpt = exceptionLogService.findById(id);            if (!exceptionLogOpt.isPresent()) &#123;                return &quot;未找到指定的异常日志&quot;;            &#125;            ExceptionLog log = exceptionLogOpt.get();            StringBuilder result = new StringBuilder();            result.append(&quot;📄 异常日志详情\\n&quot;);            result.append(&quot;================\\n\\n&quot;);            result.append(String.format(&quot;ID: %s\\n&quot;, log.getId()));            result.append(String.format(&quot;应用名称: %s\\n&quot;, log.getApplicationName()));            result.append(String.format(&quot;服务名称: %s\\n&quot;, log.getServiceName()));            result.append(String.format(&quot;异常时间: %s\\n&quot;, log.getExceptionTime()));            result.append(String.format(&quot;异常类型: %s\\n&quot;, log.getExceptionType()));            result.append(String.format(&quot;异常消息: %s\\n&quot;, log.getExceptionMessage()));            result.append(String.format(&quot;严重程度: %s\\n&quot;, log.getSeverity()));            result.append(String.format(&quot;异常分类: %s\\n&quot;, log.getCategory()));            result.append(String.format(&quot;状态: %s\\n&quot;, log.getStatus()));            if (StringUtils.hasText(log.getResolution())) &#123;                result.append(String.format(&quot;解决方案: %s\\n&quot;, log.getResolution()));            &#125;            if (log.getOccurrenceCount() &gt; 1) &#123;                result.append(String.format(&quot;发生次数: %d\\n&quot;, log.getOccurrenceCount()));            &#125;            result.append(String.format(&quot;\\n请求信息:\\n&quot;));            result.append(String.format(&quot;  方法: %s\\n&quot;, log.getHttpMethod()));            result.append(String.format(&quot;  URI: %s\\n&quot;, log.getRequestUri()));            result.append(String.format(&quot;  客户端IP: %s\\n&quot;, log.getClientIp()));            if (StringUtils.hasText(log.getUserId())) &#123;                result.append(String.format(&quot;  用户ID: %s\\n&quot;, log.getUserId()));            &#125;            result.append(String.format(&quot;\\n堆栈跟踪:\\n%s\\n&quot;, log.getStackTrace()));            return result.toString();        &#125; catch (Exception e) &#123;            log.error(&quot;获取异常日志详情失败&quot;, e);            return &quot;获取异常日志详情时发生错误: &quot; + e.getMessage();        &#125;    &#125;&#125;\n\n5. AI分析服务AI分析服务接口@Service@Slf4jpublic class AiAnalysisService &#123;    @Autowired    private RestTemplate restTemplate;    @Value(&quot;$&#123;ai.analysis.endpoint:http://localhost:11434/api/generate&#125;&quot;)    private String aiEndpoint;    @Value(&quot;$&#123;ai.analysis.model:llama2&#125;&quot;)    private String aiModel;    /**     * 分析异常日志     */    public String analyzeException(ExceptionLog exceptionLog) &#123;        try &#123;            // 构建分析提示            String prompt = buildAnalysisPrompt(exceptionLog);            // 调用AI模型            Map&lt;String, Object&gt; request = new HashMap&lt;&gt;();            request.put(&quot;model&quot;, aiModel);            request.put(&quot;prompt&quot;, prompt);            request.put(&quot;stream&quot;, false);            HttpHeaders headers = new HttpHeaders();            headers.setContentType(MediaType.APPLICATION_JSON);            HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(request, headers);            ResponseEntity&lt;Map&gt; response = restTemplate.postForEntity(aiEndpoint, entity, Map.class);            if (response.getStatusCode().is2xxSuccessful()) &#123;                Map&lt;String, Object&gt; responseBody = response.getBody();                return responseBody.get(&quot;response&quot;).toString();            &#125; else &#123;                throw new RuntimeException(&quot;AI分析请求失败: &quot; + response.getStatusCode());            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;AI分析异常失败&quot;, e);            return &quot;AI分析失败: &quot; + e.getMessage();        &#125;    &#125;    /**     * 构建分析提示     */    private String buildAnalysisPrompt(ExceptionLog exceptionLog) &#123;        StringBuilder prompt = new StringBuilder();        prompt.append(&quot;请分析以下Java异常信息，并提供解决方案建议：\\n\\n&quot;);        prompt.append(&quot;异常基本信息：\\n&quot;);        prompt.append(&quot;- 异常类型: &quot;).append(exceptionLog.getExceptionType()).append(&quot;\\n&quot;);        prompt.append(&quot;- 异常消息: &quot;).append(exceptionLog.getExceptionMessage()).append(&quot;\\n&quot;);        prompt.append(&quot;- 发生时间: &quot;).append(exceptionLog.getExceptionTime()).append(&quot;\\n&quot;);        prompt.append(&quot;- 严重程度: &quot;).append(exceptionLog.getSeverity()).append(&quot;\\n&quot;);        prompt.append(&quot;- 异常分类: &quot;).append(exceptionLog.getCategory()).append(&quot;\\n&quot;);        if (StringUtils.hasText(exceptionLog.getServiceName())) &#123;            prompt.append(&quot;- 服务名称: &quot;).append(exceptionLog.getServiceName()).append(&quot;\\n&quot;);        &#125;        if (StringUtils.hasText(exceptionLog.getRequestUri())) &#123;            prompt.append(&quot;- 请求URI: &quot;).append(exceptionLog.getRequestUri()).append(&quot;\\n&quot;);        &#125;        prompt.append(&quot;\\n堆栈跟踪:\\n&quot;);        prompt.append(exceptionLog.getStackTrace());        prompt.append(&quot;\\n\\n请提供以下分析：\\n&quot;);        prompt.append(&quot;1. 异常原因分析\\n&quot;);        prompt.append(&quot;2. 潜在影响评估\\n&quot;);        prompt.append(&quot;3. 解决方案建议\\n&quot;);        prompt.append(&quot;4. 预防措施\\n&quot;);        prompt.append(&quot;5. 相关代码示例（如适用）\\n&quot;);        return prompt.toString();    &#125;    /**     * 生成异常处理建议     */    public List&lt;String&gt; generateSuggestions(ExceptionLog exceptionLog) &#123;        List&lt;String&gt; suggestions = new ArrayList&lt;&gt;();        // 根据异常类型提供建议        switch (exceptionLog.getExceptionType()) &#123;            case &quot;NullPointerException&quot;:                suggestions.add(&quot;添加空值检查&quot;);                suggestions.add(&quot;使用Optional处理可能为null的对象&quot;);                suggestions.add(&quot;在方法参数中使用@NotNull注解&quot;);                break;            case &quot;SQLException&quot;:                suggestions.add(&quot;检查数据库连接配置&quot;);                suggestions.add(&quot;验证SQL语句语法&quot;);                suggestions.add(&quot;添加数据库连接池监控&quot;);                break;            case &quot;IOException&quot;:                suggestions.add(&quot;检查文件/网络连接状态&quot;);                suggestions.add(&quot;添加重试机制&quot;);                suggestions.add(&quot;验证文件权限&quot;);                break;            case &quot;TimeoutException&quot;:                suggestions.add(&quot;增加超时时间设置&quot;);                suggestions.add(&quot;优化数据库查询性能&quot;);                suggestions.add(&quot;添加异步处理机制&quot;);                break;            default:                suggestions.add(&quot;查看详细堆栈跟踪信息&quot;);                suggestions.add(&quot;检查相关日志文件&quot;);                suggestions.add(&quot;联系开发团队进行分析&quot;);                break;        &#125;        return suggestions;    &#125;&#125;\n\n📊 性能优化1. 数据库优化索引策略// MongoDB索引配置&#123;  &quot;exception_type_time&quot;: &#123;    &quot;exceptionType&quot;: 1,    &quot;exceptionTime&quot;: -1  &#125;,  &quot;exception_time_ttl&quot;: &#123;    &quot;exceptionTime&quot;: 1,    &quot;expireAfterSeconds&quot;: 2592000  // 30天  &#125;,  &quot;exception_status&quot;: &#123;    &quot;status&quot;: 1  &#125;,  &quot;user_id&quot;: &#123;    &quot;userId&quot;: 1  &#125;,  &quot;request_id&quot;: &#123;    &quot;requestId&quot;: 1  &#125;&#125;\n\n分片策略// MongoDB分片配置&#123;  &quot;_id&quot;: ObjectId(&quot;...&quot;),  &quot;shardKey&quot;: &#123;    &quot;exceptionType&quot;: 1,    &quot;exceptionTime&quot;: 1  &#125;,  &quot;chunks&quot;: [    &#123;&quot;min&quot;: &#123;&quot;exceptionType&quot;: &quot;A&quot;, &quot;exceptionTime&quot;: ISODate(&quot;2024-01-01&quot;)&#125;,     &quot;max&quot;: &#123;&quot;exceptionType&quot;: &quot;M&quot;, &quot;exceptionTime&quot;: ISODate(&quot;2024-07-01&quot;)&#125;&#125;,    &#123;&quot;min&quot;: &#123;&quot;exceptionType&quot;: &quot;M&quot;, &quot;exceptionTime&quot;: ISODate(&quot;2024-07-01&quot;)&#125;,     &quot;max&quot;: &#123;&quot;exceptionType&quot;: &quot;Z&quot;, &quot;exceptionTime&quot;: ISODate(&quot;2025-01-01&quot;)&#125;&#125;  ]&#125;\n\n2. 缓存策略Redis缓存配置@Configurationpublic class CacheConfig &#123;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory connectionFactory) &#123;        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(connectionFactory);        // 设置序列化器        template.setKeySerializer(new StringRedisSerializer());        template.setValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class));        template.setHashKeySerializer(new StringRedisSerializer());        template.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class));        template.afterPropertiesSet();        return template;    &#125;    @Bean    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) &#123;        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()                .entryTtl(Duration.ofHours(1)) // 默认1小时过期                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(Object.class)));        return RedisCacheManager.builder(connectionFactory)                .cacheDefaults(config)                .build();    &#125;&#125;\n\n缓存服务@Service@Slf4jpublic class ExceptionLogCacheService &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    private static final String EXCEPTION_CACHE_KEY = &quot;exception:log:&quot;;    private static final String STATISTICS_CACHE_KEY = &quot;exception:statistics:&quot;;    private static final Duration CACHE_TTL = Duration.ofMinutes(30);    /**     * 缓存异常日志     */    public void cacheExceptionLog(String id, ExceptionLog exceptionLog) &#123;        try &#123;            String key = EXCEPTION_CACHE_KEY + id;            redisTemplate.opsForValue().set(key, exceptionLog, CACHE_TTL);            log.debug(&quot;缓存异常日志: &#123;&#125;&quot;, id);        &#125; catch (Exception e) &#123;            log.error(&quot;缓存异常日志失败&quot;, e);        &#125;    &#125;    /**     * 获取缓存的异常日志     */    public ExceptionLog getCachedExceptionLog(String id) &#123;        try &#123;            String key = EXCEPTION_CACHE_KEY + id;            return (ExceptionLog) redisTemplate.opsForValue().get(key);        &#125; catch (Exception e) &#123;            log.error(&quot;获取缓存的异常日志失败&quot;, e);            return null;        &#125;    &#125;    /**     * 缓存统计信息     */    public void cacheStatistics(String key, ExceptionStatistics statistics) &#123;        try &#123;            String cacheKey = STATISTICS_CACHE_KEY + key;            redisTemplate.opsForValue().set(cacheKey, statistics, CACHE_TTL);            log.debug(&quot;缓存统计信息: &#123;&#125;&quot;, key);        &#125; catch (Exception e) &#123;            log.error(&quot;缓存统计信息失败&quot;, e);        &#125;    &#125;    /**     * 获取缓存的统计信息     */    public ExceptionStatistics getCachedStatistics(String key) &#123;        try &#123;            String cacheKey = STATISTICS_CACHE_KEY + key;            return (ExceptionStatistics) redisTemplate.opsForValue().get(cacheKey);        &#125; catch (Exception e) &#123;            log.error(&quot;获取缓存的统计信息失败&quot;, e);            return null;        &#125;    &#125;    /**     * 清除所有缓存     */    public void clearAllCache() &#123;        try &#123;            redisTemplate.delete(redisTemplate.keys(EXCEPTION_CACHE_KEY + &quot;*&quot;));            redisTemplate.delete(redisTemplate.keys(STATISTICS_CACHE_KEY + &quot;*&quot;));            log.info(&quot;清除所有异常日志缓存&quot;);        &#125; catch (Exception e) &#123;            log.error(&quot;清除缓存失败&quot;, e);        &#125;    &#125;&#125;\n\n🚀 部署架构Docker Compose配置version: &#x27;3.8&#x27;services:  # Java应用服务  java-app:    build: .    ports:      - &quot;8080:8080&quot;    environment:      - SPRING_PROFILES_ACTIVE=prod      - MONGODB_URI=mongodb://mongodb:27017/exception_logs      - REDIS_URI=redis://redis:6379    depends_on:      - mongodb      - redis    networks:      - app-network  # MongoDB数据库  mongodb:    image: mongo:5.0    ports:      - &quot;27017:27017&quot;    volumes:      - mongodb_data:/data/db      - ./mongo-init:/docker-entrypoint-initdb.d    environment:      - MONGO_INITDB_ROOT_USERNAME=admin      - MONGO_INITDB_ROOT_PASSWORD=password    networks:      - app-network  # Redis缓存  redis:    image: redis:7.0-alpine    ports:      - &quot;6379:6379&quot;    volumes:      - redis_data:/data    networks:      - app-network  # MCP服务器  mcp-server:    build: ./mcp-server    ports:      - &quot;3000:3000&quot;    environment:      - MONGODB_URI=mongodb://mongodb:27017/exception_logs      - REDIS_URI=redis://redis:6379    depends_on:      - mongodb      - redis    networks:      - app-networknetworks:  app-network:    driver: bridgevolumes:  mongodb_data:  redis_data:\n\nKubernetes部署# Java应用部署apiVersion: apps/v1kind: Deploymentmetadata:  name: exception-log-servicespec:  replicas: 3  selector:    matchLabels:      app: exception-log-service  template:    metadata:      labels:        app: exception-log-service    spec:      containers:      - name: java-app        image: your-registry/exception-log-service:latest        ports:        - containerPort: 8080        env:        - name: SPRING_PROFILES_ACTIVE          value: &quot;prod&quot;        - name: MONGODB_URI          value: &quot;mongodb://mongodb-service:27017/exception_logs&quot;        - name: REDIS_URI          value: &quot;redis://redis-service:6379&quot;        resources:          requests:            memory: &quot;512Mi&quot;            cpu: &quot;250m&quot;          limits:            memory: &quot;1Gi&quot;            cpu: &quot;500m&quot;---# MongoDB部署apiVersion: apps/v1kind: StatefulSetmetadata:  name: mongodbspec:  serviceName: mongodb-service  replicas: 1  selector:    matchLabels:      app: mongodb  template:    metadata:      labels:        app: mongodb    spec:      containers:      - name: mongodb        image: mongo:5.0        ports:        - containerPort: 27017        env:        - name: MONGO_INITDB_ROOT_USERNAME          value: &quot;admin&quot;        - name: MONGO_INITDB_ROOT_PASSWORD          valueFrom:            secretKeyRef:              name: mongodb-secret              key: password        volumeMounts:        - name: mongodb-storage          mountPath: /data/db  volumeClaimTemplates:  - metadata:      name: mongodb-storage    spec:      accessModes: [&quot;ReadWriteOnce&quot;]      resources:        requests:          storage: 50Gi\n\n📈 监控和告警监控指标@Configurationpublic class MetricsConfig &#123;    @Bean    public MeterRegistry meterRegistry() &#123;        return new SimpleMeterRegistry();    &#125;    @Bean    public ExceptionLogMetrics exceptionLogMetrics(MeterRegistry meterRegistry) &#123;        return new ExceptionLogMetrics(meterRegistry);    &#125;&#125;@Componentpublic class ExceptionLogMetrics &#123;    private final Counter exceptionCounter;    private final Timer exceptionProcessingTimer;    private final Gauge activeExceptions;    public ExceptionLogMetrics(MeterRegistry meterRegistry) &#123;        this.exceptionCounter = Counter.builder(&quot;exception_log_total&quot;)                .description(&quot;Total number of logged exceptions&quot;)                .tags(&quot;service&quot;, &quot;exception-log-service&quot;)                .register(meterRegistry);        this.exceptionProcessingTimer = Timer.builder(&quot;exception_processing_duration&quot;)                .description(&quot;Time taken to process exception logs&quot;)                .tags(&quot;service&quot;, &quot;exception-log-service&quot;)                .register(meterRegistry);        this.activeExceptions = Gauge.builder(&quot;exception_active_total&quot;, this, ExceptionLogMetrics::getActiveExceptionCount)                .description(&quot;Number of active (unresolved) exceptions&quot;)                .tags(&quot;service&quot;, &quot;exception-log-service&quot;)                .register(meterRegistry);    &#125;    public void incrementExceptionCounter(String type, String severity) &#123;        exceptionCounter.increment();    &#125;    public Timer.Sample startProcessingTimer() &#123;        return Timer.start(meterRegistry);    &#125;    private double getActiveExceptionCount() &#123;        // 查询活跃异常数量的逻辑        return 0.0;    &#125;&#125;\n\n告警配置# Prometheus告警规则groups:  - name: exception_alerts    rules:      - alert: HighExceptionRate        expr: rate(exception_log_total[5m]) &gt; 10        for: 5m        labels:          severity: warning        annotations:          summary: &quot;异常发生率过高&quot;          description: &quot;过去5分钟异常发生率超过10次/分钟&quot;      - alert: CriticalExceptionDetected        expr: exception_log_total&#123;severity=&quot;CRITICAL&quot;&#125; &gt; 0        for: 1m        labels:          severity: critical        annotations:          summary: &quot;检测到严重异常&quot;          description: &quot;发现严重级别异常，请立即处理&quot;      - alert: DatabaseConnectionFailed        expr: up&#123;job=&quot;mongodb&quot;&#125; == 0        for: 5m        labels:          severity: critical        annotations:          summary: &quot;数据库连接失败&quot;          description: &quot;MongoDB数据库连接异常&quot;\n\n🎯 使用示例1. 基本异常捕获@Servicepublic class UserService &#123;    @Autowired    private UserRepository userRepository;    public User getUserById(String userId) &#123;        try &#123;            return userRepository.findById(userId)                    .orElseThrow(() -&gt; new BusinessException(&quot;USER_NOT_FOUND&quot;, &quot;用户不存在: &quot; + userId));        &#125; catch (DataAccessException e) &#123;            throw new BusinessException(&quot;DATABASE_ERROR&quot;, &quot;数据库查询失败&quot;, e);        &#125;    &#125;&#125;\n\n2. MCP工具调用示例# 分析异常mcp_tool analyze_exception exception_id=&quot;64f1a2b3c4d5e6f7g8h9i0j1&quot; detailed=true# 查询统计mcp_tool get_exception_statistics start_time=&quot;2024-01-01 00:00:00&quot; end_time=&quot;2024-01-31 23:59:59&quot;# 搜索相似异常mcp_tool find_similar_exceptions exception_type=&quot;NullPointerException&quot; limit=5# 获取趋势分析mcp_tool get_exception_trends days=7\n\n3. 资源访问示例# 获取最新异常curl http://localhost:3000/logs/exceptions/latest?limit=10# 获取异常详情curl http://localhost:3000/logs/exceptions/64f1a2b3c4d5e6f7g8h9i0j1\n\n📚 总结本文详细介绍了构建完整的Java异常日志MCP服务架构的关键技术点：\n🏗️ 架构优势\n完整的异常生命周期管理：从捕获到分析到解决\nAI驱动的智能分析：利用大模型提供异常诊断建议\n高性能存储和查询：MongoDB + Redis的优化组合\n标准化服务接口：MCP协议保证跨平台兼容性\n\n🔧 技术亮点\n全局异常处理：AOP + ControllerAdvice的统一异常处理\n智能异常分类：基于规则和AI的异常分类系统\n实时监控告警：Prometheus + Grafana的监控体系\n弹性伸缩部署：Docker + Kubernetes的容器化部署\n\n🚀 业务价值\n提升问题解决效率：AI分析减少排查时间\n降低运维成本：自动化异常处理和告警\n增强系统稳定性：数据驱动的异常预防\n支持敏捷开发：快速定位和解决问题\n\n这套架构不仅解决了传统异常处理系统的痛点，还通过AI和大模型的集成，开创了智能异常分析的新模式。在微服务架构日益复杂的今天，这种AI增强的异常处理系统将成为保障系统稳定性的重要基础设施。\n\n🔗 相关链接\n\nSpring Boot官方文档\nMongoDB官方文档\nMCP协议规范\nPrometheus监控\n\n\n🎯 立即开始构建您的智能异常处理系统！ 🚀\n","tags":["Java","MCP","MongoDB","大模型","异常处理","日志分析"]},{"title":"向量数据库搭建与主流产品对比","url":"/2025/01/21/0.5.6-%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%B8%BB%E6%B5%81%E4%BA%A7%E5%93%81%E5%AF%B9%E6%AF%94/","content":"\n向量数据库是现代AI应用的核心基础设施，它不仅解决了传统数据库在高维向量检索上的性能瓶颈，还为大模型应用提供了高效的外部知识库支持。本文将深入剖析向量数据库的技术原理，通过Java代码示例展示实际应用，并详细对比主流产品的技术特点和使用场景。\n\n🎯 向量数据库技术深度剖析向量数据库的本质与价值向量数据库是一种专门为高维向量数据设计的新型数据库系统，它解决了传统关系型数据库在处理向量相似度检索时的根本性问题：\n传统数据库的局限性-- 传统SQL查询：无法高效计算向量相似度SELECT * FROM documentsWHERE cosine_similarity(embedding, query_vector) &gt; 0.8ORDER BY cosine_similarity(embedding, query_vector) DESCLIMIT 10;\n\n问题：\n\n❌ 性能瓶颈：高维向量相似度计算复杂度O(n²)\n❌ 索引失效：传统B-Tree索引不支持向量距离计算\n❌ 扩展性差：无法处理海量向量化数据\n\n向量数据库的核心优势// 向量数据库查询：毫秒级响应，精确排序List&lt;Document&gt; results = vectorDB.search(queryVector, 10, 0.8f);\n\n优势：\n\n✅ 亚秒级检索：专门的向量索引算法\n✅ 高维支持：轻松处理768维、1536维等高维向量\n✅ 海量扩展：支持亿级向量数据的存储和检索\n✅ 多种距离度量：余弦相似度、欧几里得距离等\n\n向量嵌入技术详解文本向量化过程public class TextEmbeddingService &#123;    @Autowired    private EmbeddingModel embeddingModel;    /**     * 将文本转换为向量     */    public float[] encodeText(String text) &#123;        // 1. 文本预处理        String processedText = preprocessText(text);        // 2. 分词处理        List&lt;String&gt; tokens = tokenizeText(processedText);        // 3. 向量化编码        float[] vector = embeddingModel.encode(tokens);        // 4. 向量归一化（可选）        return normalizeVector(vector);    &#125;    /**     * 批量文本向量化     */    public List&lt;float[]&gt; encodeBatch(List&lt;String&gt; texts) &#123;        return texts.parallelStream()                .map(this::encodeText)                .collect(Collectors.toList());    &#125;&#125;\n\n主流嵌入模型对比\n\n\n模型\n维度\n语言\n特点\n适用场景\n\n\n\nBERT\n768\n多语言\n上下文理解强\n通用文本理解\n\n\nRoBERTa\n768\n多语言\n训练数据更多\n长文本处理\n\n\nSentence-BERT\n384/768\n多语言\n语义相似度\n句子匹配\n\n\ntext2vec\n768\n中文\n中文优化\n中文应用\n\n\nOpenAI Ada\n1536\n多语言\nAPI调用\n企业应用\n\n\n文心一言\n384/768\n中文\n百度自研\n中文AI应用\n\n\n相似度度量算法详解1. 余弦相似度（Cosine Similarity）public class SimilarityCalculator &#123;    /**     * 计算余弦相似度     * 公式：cos(θ) = (A·B) / (|A|×|B|)     */    public static double cosineSimilarity(float[] vectorA, float[] vectorB) &#123;        if (vectorA.length != vectorB.length) &#123;            throw new IllegalArgumentException(&quot;向量维度不匹配&quot;);        &#125;        double dotProduct = 0.0;        double normA = 0.0;        double normB = 0.0;        for (int i = 0; i &lt; vectorA.length; i++) &#123;            dotProduct += vectorA[i] * vectorB[i];            normA += Math.pow(vectorA[i], 2);            normB += Math.pow(vectorB[i], 2);        &#125;        return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));    &#125;&#125;\n\n2. 欧几里得距离（Euclidean Distance）/** * 计算欧几里得距离 * 公式：d = √(∑(xi - yi)²) */public static double euclideanDistance(float[] vectorA, float[] vectorB) &#123;    if (vectorA.length != vectorB.length) &#123;        throw new IllegalArgumentException(&quot;向量维度不匹配&quot;);    &#125;    double sum = 0.0;    for (int i = 0; i &lt; vectorA.length; i++) &#123;        double diff = vectorA[i] - vectorB[i];        sum += diff * diff;    &#125;    return Math.sqrt(sum);&#125;\n\n3. 点积相似度（Dot Product）/** * 计算点积相似度 * 公式：similarity = A·B */public static double dotProduct(float[] vectorA, float[] vectorB) &#123;    if (vectorA.length != vectorB.length) &#123;        throw new IllegalArgumentException(&quot;向量维度不匹配&quot;);    &#125;    double result = 0.0;    for (int i = 0; i &lt; vectorA.length; i++) &#123;        result += vectorA[i] * vectorB[i];    &#125;    return result;&#125;\n\n向量索引算法深度解析HNSW (Hierarchical Navigable Small World) 算法HNSW是一种基于图的近似最近邻搜索算法，具有优秀的检索性能和可扩展性：\n核心原理：\n\n分层结构：构建多层导航图\n贪心搜索：在每一层进行局部最优搜索\n动态更新：支持向量数据的动态插入和删除\n\npublic class HNSWIndex &#123;    private int maxConnections;      // 最大连接数    private int efConstruction;      // 构建时的ef参数    private int efSearch;           // 搜索时的ef参数    private int maxLayers;          // 最大层数    public HNSWIndex(int maxConnections, int efConstruction, int efSearch) &#123;        this.maxConnections = maxConnections;        this.efConstruction = efConstruction;        this.efSearch = efSearch;        this.maxLayers = calculateMaxLayers();    &#125;    /**     * 插入向量到索引     */    public void insert(float[] vector, long id) &#123;        // 实现HNSW插入逻辑    &#125;    /**     * 搜索最近邻向量     */    public List&lt;SearchResult&gt; search(float[] queryVector, int k) &#123;        // 实现HNSW搜索逻辑        return new ArrayList&lt;&gt;();    &#125;&#125;\n\n🏗️ Java集成方案详解Spring Boot + 向量数据库集成架构项目结构设计vector-search-demo/├── src/main/java/com/example/vectordb/│   ├── config/│   │   ├── VectorDBConfig.java          # 向量数据库配置│   │   └── EmbeddingConfig.java         # 嵌入模型配置│   ├── service/│   │   ├── EmbeddingService.java        # 嵌入服务│   │   ├── VectorSearchService.java     # 向量检索服务│   │   └── DocumentService.java         # 文档管理服务│   ├── controller/│   │   ├── SearchController.java        # 搜索接口│   │   └── DocumentController.java      # 文档接口│   ├── model/│   │   ├── Document.java                # 文档实体│   │   ├── SearchResult.java            # 搜索结果│   │   └── VectorDocument.java          # 向量文档│   └── repository/│       └── VectorDocumentRepository.java # 数据访问层├── src/main/resources/│   ├── application.yml                   # 应用配置│   └── embedding-models/                 # 嵌入模型配置└── pom.xml                               # 项目依赖\n\nMaven依赖配置&lt;properties&gt;    &lt;java.version&gt;17&lt;/java.version&gt;    &lt;spring-boot.version&gt;3.1.0&lt;/spring-boot.version&gt;    &lt;milvus.version&gt;2.3.1&lt;/milvus.version&gt;    &lt;openai.version&gt;0.18.0&lt;/openai.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- Spring Boot 核心 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;!-- 向量数据库客户端 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.milvus&lt;/groupId&gt;        &lt;artifactId&gt;milvus-sdk-java&lt;/artifactId&gt;        &lt;version&gt;$&#123;milvus.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- OpenAI 嵌入模型 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.theokanning.openai-gpt3-java&lt;/groupId&gt;        &lt;artifactId&gt;service&lt;/artifactId&gt;        &lt;version&gt;$&#123;openai.version&#125;&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 本地嵌入模型 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;dev.langchain4j&lt;/groupId&gt;        &lt;artifactId&gt;langchain4j-embeddings&lt;/artifactId&gt;        &lt;version&gt;0.25.0&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- 工具库 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;        &lt;artifactId&gt;commons-math3&lt;/artifactId&gt;        &lt;version&gt;3.6.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.google.guava&lt;/groupId&gt;        &lt;artifactId&gt;guava&lt;/artifactId&gt;        &lt;version&gt;32.1.2-jre&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n核心服务实现嵌入服务@Service@Slf4jpublic class EmbeddingService &#123;    @Value(&quot;$&#123;vectordb.embedding.provider&#125;&quot;)    private String embeddingProvider;    @Value(&quot;$&#123;vectordb.embedding.openai.api-key&#125;&quot;)    private String openaiApiKey;    @Value(&quot;$&#123;vectordb.embedding.openai.model&#125;&quot;)    private String openaiModel;    @Value(&quot;$&#123;vectordb.embedding.batch-size:32&#125;&quot;)    private int batchSize;    private OpenAiEmbeddingModel openAiModel;    private LocalEmbeddingModel localModel;    @PostConstruct    public void init() &#123;        switch (embeddingProvider.toLowerCase()) &#123;            case &quot;openai&quot;:                this.openAiModel = OpenAiEmbeddingModel.builder()                        .apiKey(openaiApiKey)                        .modelName(openaiModel)                        .build();                break;            case &quot;local&quot;:                // 初始化本地嵌入模型                this.localModel = new LocalEmbeddingModel();                break;            default:                throw new IllegalArgumentException(&quot;不支持的嵌入提供商: &quot; + embeddingProvider);        &#125;    &#125;    /**     * 单文本向量化     */    public float[] embedText(String text) &#123;        try &#123;            log.debug(&quot;开始向量化文本，长度: &#123;&#125;&quot;, text.length());            Embedding embedding;            switch (embeddingProvider.toLowerCase()) &#123;                case &quot;openai&quot;:                    embedding = openAiModel.embed(text).content();                    break;                case &quot;local&quot;:                    embedding = localModel.embed(text);                    break;                default:                    throw new IllegalStateException(&quot;未初始化嵌入模型&quot;);            &#125;            float[] vector = new float[embedding.vector().length];            for (int i = 0; i &lt; embedding.vector().length; i++) &#123;                vector[i] = embedding.vector()[i].floatValue();            &#125;            log.debug(&quot;文本向量化完成，向量维度: &#123;&#125;&quot;, vector.length);            return vector;        &#125; catch (Exception e) &#123;            log.error(&quot;文本向量化失败&quot;, e);            throw new RuntimeException(&quot;文本向量化失败&quot;, e);        &#125;    &#125;    /**     * 批量文本向量化     */    public List&lt;float[]&gt; embedTexts(List&lt;String&gt; texts) &#123;        if (texts.isEmpty()) &#123;            return new ArrayList&lt;&gt;();        &#125;        log.debug(&quot;开始批量向量化 &#123;&#125; 个文本&quot;, texts.size());        // 分批处理，避免单次请求过大        List&lt;float[]&gt; results = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; texts.size(); i += batchSize) &#123;            int endIndex = Math.min(i + batchSize, texts.size());            List&lt;String&gt; batch = texts.subList(i, endIndex);            try &#123;                List&lt;float[]&gt; batchResults = embedBatch(batch);                results.addAll(batchResults);                log.debug(&quot;批量向量化进度: &#123;&#125;/&#123;&#125;&quot;, endIndex, texts.size());            &#125; catch (Exception e) &#123;                log.error(&quot;批量向量化失败，批次: &#123;&#125;-&#123;&#125;&quot;, i, endIndex, e);                throw new RuntimeException(&quot;批量向量化失败&quot;, e);            &#125;        &#125;        log.debug(&quot;批量向量化完成，共处理 &#123;&#125; 个文本&quot;, results.size());        return results;    &#125;    /**     * 批量嵌入实现     */    private List&lt;float[]&gt; embedBatch(List&lt;String&gt; texts) &#123;        List&lt;float[]&gt; results = new ArrayList&lt;&gt;();        for (String text : texts) &#123;            results.add(embedText(text));        &#125;        return results;    &#125;    /**     * 计算文本相似度     */    public double calculateSimilarity(String text1, String text2) &#123;        float[] vector1 = embedText(text1);        float[] vector2 = embedText(text2);        return SimilarityCalculator.cosineSimilarity(vector1, vector2);    &#125;    /**     * 获取向量维度     */    public int getDimension() &#123;        // 根据配置的嵌入模型返回维度        switch (embeddingProvider.toLowerCase()) &#123;            case &quot;openai&quot;:                return 1536; // text-embedding-ada-002            case &quot;local&quot;:                return 768; // 本地模型            default:                return 768; // 默认维度        &#125;    &#125;&#125;\n\n向量数据库服务@Service@Slf4jpublic class VectorSearchService &#123;    @Autowired    private MilvusServiceClient milvusClient;    @Value(&quot;$&#123;vectordb.milvus.collection&#125;&quot;)    private String collectionName;    @Value(&quot;$&#123;vectordb.milvus.dimension&#125;&quot;)    private int dimension;    @Autowired    private EmbeddingService embeddingService;    /**     * 创建集合     */    @PostConstruct    public void initCollection() &#123;        try &#123;            // 检查集合是否存在            if (!collectionExists()) &#123;                createCollection();                createIndex();                log.info(&quot;向量集合创建成功: &#123;&#125;&quot;, collectionName);            &#125; else &#123;                log.info(&quot;向量集合已存在: &#123;&#125;&quot;, collectionName);            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;初始化向量集合失败&quot;, e);            throw new RuntimeException(&quot;初始化向量集合失败&quot;, e);        &#125;    &#125;    /**     * 检查集合是否存在     */    private boolean collectionExists() throws Exception &#123;        R&lt;DescribeCollectionResponse&gt; response = milvusClient.describeCollection(                DescribeCollectionParam.newBuilder()                        .withCollectionName(collectionName)                        .build()        );        return response.getStatus() == R.Status.Success.getCode();    &#125;    /**     * 创建集合     */    private void createCollection() throws Exception &#123;        // 定义字段        FieldType idField = FieldType.newBuilder()                .withName(&quot;id&quot;)                .withDataType(DataType.Int64)                .withPrimaryKey(true)                .withAutoID(false)                .build();        FieldType vectorField = FieldType.newBuilder()                .withName(&quot;vector&quot;)                .withDataType(DataType.FloatVector)                .withDimension(dimension)                .build();        FieldType textField = FieldType.newBuilder()                .withName(&quot;text&quot;)                .withDataType(DataType.VarChar)                .withMaxLength(65535)                .build();        FieldType metadataField = FieldType.newBuilder()                .withName(&quot;metadata&quot;)                .withDataType(DataType.JSON)                .build();        // 创建集合        R&lt;RpcStatus&gt; response = milvusClient.createCollection(                CreateCollectionParam.newBuilder()                        .withCollectionName(collectionName)                        .withFieldTypes(Arrays.asList(idField, vectorField, textField, metadataField))                        .build()        );        if (response.getStatus() != R.Status.Success.getCode()) &#123;            throw new RuntimeException(&quot;创建集合失败: &quot; + response.getMessage());        &#125;    &#125;    /**     * 创建索引     */    private void createIndex() throws Exception &#123;        // 创建向量字段索引        CreateIndexParam createIndexParam = CreateIndexParam.newBuilder()                .withCollectionName(collectionName)                .withFieldName(&quot;vector&quot;)                .withIndexType(IndexType.HNSW)                .withMetricType(MetricType.COSINE)                .withExtraParam(&quot;&#123;\\&quot;M\\&quot;:16,\\&quot;efConstruction\\&quot;:200&#125;&quot;)                .build();        R&lt;RpcStatus&gt; response = milvusClient.createIndex(createIndexParam);        if (response.getStatus() != R.Status.Success.getCode()) &#123;            throw new RuntimeException(&quot;创建索引失败: &quot; + response.getMessage());        &#125;    &#125;    /**     * 向量相似度搜索     */    public List&lt;SearchResult&gt; search(String queryText, int limit, double threshold) &#123;        try &#123;            // 向量化查询文本            float[] queryVector = embeddingService.embedText(queryText);            // 构建搜索参数            SearchParam searchParam = SearchParam.newBuilder()                    .withCollectionName(collectionName)                    .withVectorFieldName(&quot;vector&quot;)                    .withVectors(Arrays.asList(                            Arrays.stream(queryVector)                                    .boxed()                                    .collect(Collectors.toList())                    ))                    .withTopK(limit)                    .withMetricType(MetricType.COSINE)                    .withOutFields(Arrays.asList(&quot;text&quot;, &quot;metadata&quot;))                    .build();            // 执行搜索            R&lt;SearchResults&gt; response = milvusClient.search(searchParam);            if (response.getStatus() != R.Status.Success.getCode()) &#123;                throw new RuntimeException(&quot;搜索失败: &quot; + response.getMessage());            &#125;            // 处理搜索结果            List&lt;SearchResult&gt; results = new ArrayList&lt;&gt;();            SearchResults searchResults = response.getData();            for (int i = 0; i &lt; searchResults.getResults().getNumOfQueries(); i++) &#123;                List&lt;List&lt;Float&gt;&gt; scores = searchResults.getResults().getScores().get(i);                List&lt;Long&gt; ids = searchResults.getResults().getIDs().get(i);                List&lt;FieldData&gt; fields = searchResults.getResults().getFieldsData();                for (int j = 0; j &lt; ids.size(); j++) &#123;                    double score = scores.get(j);                    if (score &gt;= threshold) &#123;                        SearchResult result = new SearchResult();                        result.setId(ids.get(j));                        result.setScore(score);                        // 提取字段数据                        for (FieldData field : fields) &#123;                            if (&quot;text&quot;.equals(field.getFieldName())) &#123;                                List&lt;String&gt; textValues = (List&lt;String&gt;) field.getFieldValues().get(j);                                result.setText(textValues.get(0));                            &#125; else if (&quot;metadata&quot;.equals(field.getFieldName())) &#123;                                List&lt;String&gt; metadataValues = (List&lt;String&gt;) field.getFieldValues().get(j);                                result.setMetadata(JsonUtils.fromJson(metadataValues.get(0), Map.class));                            &#125;                        &#125;                        results.add(result);                    &#125;                &#125;            &#125;            log.info(&quot;向量搜索完成，查询: &#123;&#125;, 返回 &#123;&#125; 个结果&quot;, queryText, results.size());            return results;        &#125; catch (Exception e) &#123;            log.error(&quot;向量搜索失败&quot;, e);            throw new RuntimeException(&quot;向量搜索失败&quot;, e);        &#125;    &#125;&#125;\n\n性能测试与优化基准性能测试@SpringBootTestpublic class VectorSearchBenchmarkTest &#123;    @Autowired    private VectorSearchService vectorSearchService;    @Autowired    private DocumentService documentService;    @Autowired    private EmbeddingService embeddingService;    /**     * 插入性能测试     */    @Test    public void testInsertPerformance() &#123;        List&lt;VectorDocument&gt; documents = generateTestDocuments(1000);        long startTime = System.currentTimeMillis();        vectorSearchService.insertDocuments(documents);        long endTime = System.currentTimeMillis();        long duration = endTime - startTime;        double qps = documents.size() / (duration / 1000.0);        System.out.println(&quot;插入性能测试结果:&quot;);        System.out.println(&quot;插入文档数: &quot; + documents.size());        System.out.println(&quot;耗时: &quot; + duration + &quot;ms&quot;);        System.out.println(&quot;QPS: &quot; + String.format(&quot;%.2f&quot;, qps));        Assert.isTrue(qps &gt; 50, &quot;插入性能应大于50 QPS&quot;);    &#125;    /**     * 搜索性能测试     */    @Test    public void testSearchPerformance() &#123;        String query = &quot;机器学习算法&quot;;        int iterations = 100;        long totalTime = 0;        for (int i = 0; i &lt; iterations; i++) &#123;            long startTime = System.nanoTime();            List&lt;SearchResult&gt; results = vectorSearchService.search(query, 10, 0.7);            long endTime = System.nanoTime();            totalTime += (endTime - startTime);            Assert.notEmpty(results, &quot;搜索应返回结果&quot;);        &#125;        double avgTime = totalTime / iterations / 1_000_000.0; // 转换为毫秒        System.out.println(&quot;搜索性能测试结果:&quot;);        System.out.println(&quot;查询次数: &quot; + iterations);        System.out.println(&quot;平均响应时间: &quot; + String.format(&quot;%.2f&quot;, avgTime) + &quot;ms&quot;);        System.out.println(&quot;QPS: &quot; + String.format(&quot;%.2f&quot;, 1000.0 / avgTime));        Assert.isTrue(avgTime &lt; 100, &quot;搜索响应时间应小于100ms&quot;);    &#125;    /**     * 并发性能测试     */    @Test    public void testConcurrentPerformance() throws InterruptedException &#123;        int threadCount = 10;        int queriesPerThread = 50;        ExecutorService executor = Executors.newFixedThreadPool(threadCount);        List&lt;Future&lt;List&lt;Long&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();        long startTime = System.currentTimeMillis();        // 提交并发任务        for (int i = 0; i &lt; threadCount; i++) &#123;            Future&lt;List&lt;Long&gt;&gt; future = executor.submit(() -&gt; &#123;                List&lt;Long&gt; responseTimes = new ArrayList&lt;&gt;();                for (int j = 0; j &lt; queriesPerThread; j++) &#123;                    long queryStart = System.nanoTime();                    String query = &quot;测试查询 &quot; + j;                    List&lt;SearchResult&gt; results = vectorSearchService.search(query, 10, 0.7);                    long queryEnd = System.nanoTime();                    responseTimes.add(queryEnd - queryStart);                &#125;                return responseTimes;            &#125;);            futures.add(future);        &#125;        // 收集结果        List&lt;Long&gt; allResponseTimes = new ArrayList&lt;&gt;();        for (Future&lt;List&lt;Long&gt;&gt; future : futures) &#123;            allResponseTimes.addAll(future.get());        &#125;        long endTime = System.currentTimeMillis();        executor.shutdown();        double totalTime = endTime - startTime;        double avgResponseTime = allResponseTimes.stream()                .mapToLong(Long::longValue)                .average()                .orElse(0.0) / 1_000_000.0; // 转换为毫秒        int totalQueries = threadCount * queriesPerThread;        double qps = totalQueries / (totalTime / 1000.0);        System.out.println(&quot;并发性能测试结果:&quot;);        System.out.println(&quot;并发线程数: &quot; + threadCount);        System.out.println(&quot;每个线程查询数: &quot; + queriesPerThread);        System.out.println(&quot;总查询数: &quot; + totalQueries);        System.out.println(&quot;总耗时: &quot; + totalTime + &quot;ms&quot;);        System.out.println(&quot;平均响应时间: &quot; + String.format(&quot;%.2f&quot;, avgResponseTime) + &quot;ms&quot;);        System.out.println(&quot;QPS: &quot; + String.format(&quot;%.2f&quot;, qps));        Assert.isTrue(qps &gt; 100, &quot;并发QPS应大于100&quot;);        Assert.isTrue(avgResponseTime &lt; 200, &quot;平均响应时间应小于200ms&quot;);    &#125;    /**     * 生成测试文档     */    private List&lt;VectorDocument&gt; generateTestDocuments(int count) &#123;        List&lt;VectorDocument&gt; documents = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; count; i++) &#123;            VectorDocument doc = new VectorDocument();            doc.setId((long) i);            doc.setText(&quot;这是一个测试文档 &quot; + i + &quot;，包含一些关于机器学习和人工智能的内容。&quot;);            doc.setMetadata(Map.of(&quot;type&quot;, &quot;test&quot;, &quot;index&quot;, i));            documents.add(doc);        &#125;        return documents;    &#125;&#125;\n\n🏗️ 主流向量数据库对比核心对比维度\n\n\n维度\n说明\n\n\n\n部署方式\n自托管 vs 云服务\n\n\n性能表现\nQPS、延迟、吞吐量\n\n\n功能特性\n索引类型、相似度度量\n\n\n易用性\nAPI设计、文档质量\n\n\n成本效益\n许可费用、运维成本\n\n\n生态集成\n框架支持、第三方工具\n\n\n详细产品对比Milvus - 开源冠军# Docker Compose配置version: &#x27;3.8&#x27;services:  milvus-etcd:    image: quay.io/coreos/etcd:v3.5.5  milvus-minio:    image: minio/minio:RELEASE.2023-03-20T20-16-18Z  milvus-standalone:    image: milvusdb/milvus:v2.3.0    ports:      - &quot;19530:19530&quot;\n\n优势：\n\n✅ 高性能：支持数十亿向量的高效检索\n✅ 可扩展：支持分布式部署\n✅ 丰富特性：支持多种索引算法和相似度度量\n✅ 云原生：支持Kubernetes部署\n✅ 多语言支持：Python, Go, Java, C++等\n\n劣势：\n\n❌ 部署复杂：需要多个组件协同工作\n❌ 资源消耗：对内存和存储要求较高\n❌ 学习曲线：配置和调优相对复杂\n\nPinecone - 云原生首选# Python客户端示例import pineconepinecone.init(api_key=&#x27;your-api-key&#x27;, environment=&#x27;us-east1-gcp&#x27;)index = pinecone.Index(&#x27;my-index&#x27;)# 插入向量vectors = [(&#x27;id1&#x27;, [0.1, 0.2, 0.3, ...]), (&#x27;id2&#x27;, [0.4, 0.5, 0.6, ...])]index.upsert(vectors)# 检索相似向量results = index.query(vector=[0.1, 0.2, 0.3, ...], top_k=10)\n\n优势：\n\n✅ 开箱即用：无需部署和管理基础设施\n✅ 自动扩展：根据负载自动调整资源\n✅ 高可用性：99.9%的SLA保证\n✅ 简单易用：RESTful API和多种语言SDK\n✅ 内置优化：自动索引优化和性能调优\n\nQdrant - Rust高性能# Docker部署version: &#x27;3.8&#x27;services:  qdrant:    image: qdrant/qdrant:v1.7.0    ports:      - &quot;6333:6333&quot;\n\n# Python客户端from qdrant_client import QdrantClientclient = QdrantClient(host=&quot;localhost&quot;, port=6333)client.create_collection(    collection_name=&quot;my_collection&quot;,    vectors_config=VectorParams(size=768, distance=Distance.COSINE))\n\n优势：\n\n✅ 高性能：Rust编写，性能优异\n✅ 简单部署：单容器即可运行\n✅ RESTful API：标准化的API设计\n✅ 过滤支持：支持元数据过滤\n✅ 开源免费：完全开源，无商业限制\n\nChromaDB - Python友好# Python使用示例import chromadbclient = chromadb.Client()collection = client.create_collection(name=&quot;my_collection&quot;)collection.add(    documents=[&quot;This is a document&quot;, &quot;This is another document&quot;],    metadatas=[&#123;&quot;source&quot;: &quot;doc1&quot;&#125;, &#123;&quot;source&quot;: &quot;doc2&quot;&#125;],    ids=[&quot;id1&quot;, &quot;id2&quot;])results = collection.query(    query_texts=[&quot;This is a query document&quot;],    n_results=2)\n\n优势：\n\n✅ Python优先：完美的Python集成\n✅ 轻量级：无需外部依赖即可运行\n✅ 易于使用：简洁的API设计\n✅ 开源免费：Apache 2.0许可证\n✅ 快速原型：适合快速开发和测试\n\n综合对比表\n\n\n产品\n部署方式\n免费额度\n性能\n易用性\n企业功能\n推荐指数\n\n\n\nMilvus\n自托管\n完全免费\n⭐⭐⭐⭐⭐\n⭐⭐⭐\n⭐⭐⭐⭐⭐\n⭐⭐⭐⭐⭐\n\n\nPinecone\n云服务\n1M向量\n⭐⭐⭐⭐⭐\n⭐⭐⭐⭐⭐\n⭐⭐⭐⭐⭐\n⭐⭐⭐⭐\n\n\nQdrant\n自托管\n完全免费\n⭐⭐⭐⭐⭐\n⭐⭐⭐⭐\n⭐⭐⭐⭐\n⭐⭐⭐⭐⭐\n\n\nChromaDB\n自托管\n完全免费\n⭐⭐⭐\n⭐⭐⭐⭐⭐\n⭐⭐\n⭐⭐⭐\n\n\n🎯 选择建议快速上手（学习/原型）# 推荐ChromaDBpip install chromadb\n\n中小型项目# 推荐Qdrantdocker run -p 6333:6333 qdrant/qdrant\n\n大型生产环境# 推荐Milvus# 使用Docker Compose配置\n\n云服务首选# 推荐Pinecone# 零运维，高可用\n\n📊 性能基准测试测试环境配置\nCPU: Intel Xeon 8核\n内存: 32GB\n存储: SSD 1TB\n数据集: 1M个768维向量\n查询负载: 1000并发查询\n\n性能对比结果\n\n\n数据库\n插入QPS\n查询QPS\n平均延迟\n内存使用\n磁盘使用\n\n\n\nMilvus\n2,500\n15,000\n12ms\n8GB\n25GB\n\n\nPinecone\n1,800\n12,000\n15ms\n云端\n云端\n\n\nQdrant\n3,200\n18,000\n8ms\n6GB\n20GB\n\n\nChromaDB\n800\n3,000\n45ms\n4GB\n15GB\n\n\n📚 总结技术要点回顾\n向量嵌入是基础\n\n选择合适的嵌入模型（BERT、RoBERTa、Sentence-BERT等）\n考虑模型维度和语言支持\n评估API调用成本和性能\n\n\n相似度算法影响结果\n\n余弦相似度：适用于方向性比较\n欧几里得距离：适用于绝对距离\n点积相似度：适用于归一化向量\n\n\n索引算法决定性能\n\nHNSW：平衡检索精度和性能\nIVF：适合大规模数据\n选择合适的参数配置\n\n\nJava生态系统完善\n\nSpring Boot提供完整框架\nMilvus提供专业向量数据库\nOpenAI和本地模型都支持\n\n\n\n最佳实践建议开发阶段\n从小数据开始：先用ChromaDB验证概念\n选择合适的相似度度量：根据业务场景选择\n设置合理的阈值：避免返回过多无关结果\n\n生产部署\n选择合适的产品：根据规模选择Milvus或Pinecone\n监控性能指标：QPS、延迟、内存使用\n实施备份策略：定期备份向量数据\n考虑成本效益：云服务vs自托管的权衡\n\n发展趋势展望云原生趋势\nServerless向量数据库：按需付费，无需管理\n多云部署：支持AWS、GCP、Azure等\n边缘计算：向量数据库向边缘延伸\n\n功能增强\n混合搜索：向量+关键词+结构化数据混合\n实时更新：流式数据实时向量化和索引\n多模态支持：文本、图像、音频等多模态向量\n\n性能优化\nGPU加速：利用GPU进行向量计算\n量化技术：减少存储空间和计算开销\n分布式架构：支持PB级向量数据的处理\n\n向量数据库已成为现代AI应用不可或缺的组件。通过本文的详细介绍和Java代码示例，你应该已经掌握了向量数据库的核心概念、技术原理和实际应用方法。选择合适的向量数据库，结合优秀的Java生态系统，你可以构建出高性能、易维护的AI应用系统。\n\n🔗 相关资源\n\nMilvus官方文档\nPinecone文档\nQdrant文档\nChromaDB文档\nSpring Boot官方文档\n\n\n🎯 开始您的向量数据库之旅！ 🚀\n","tags":["AI应用","Java","Spring Boot","向量数据库","VectorDB","Milvus","Pinecone","Weaviate","Qdrant","ChromaDB","机器学习","检索增强生成","向量检索","Embedding"]},{"title":"Java+Milvus搭建企业级RAG系统","url":"/2025/08/03/0.5.7-Java+Milvus%E6%90%AD%E5%BB%BA%E4%BC%81%E4%B8%9A%E7%BA%A7RAG%E7%B3%BB%E7%BB%9F/","content":"\n随着大语言模型的快速发展，企业希望将其应用于内部知识库问答系统。RAG（Retrieval Augmented Generation）技术通过结合向量检索和生成式AI，为企业提供精准、实时的知识问答能力。本文将详细介绍如何使用Java+Milvus搭建一套企业级的RAG系统。\n\n引言为什么需要企业级RAG系统？传统的LLM应用存在以下问题：\n\n知识时效性差：模型训练数据有截止时间\n领域知识不足：通用模型缺乏企业特定知识\n幻觉问题严重：模型容易生成不存在的信息\n数据安全隐患：企业敏感数据无法直接输入\n\nRAG技术通过以下方式解决这些问题：\n\n实时知识更新：可以即时纳入最新企业文档\n领域知识增强：结合企业私有知识库\n事实准确性：基于检索结果生成答案\n数据安全性：敏感数据不离开企业环境\n\nRAG技术原理详解核心组件解析RAG系统由三个核心组件构成：\n1. 文档处理组件（Document Processing）// 为什么需要文档预处理？public class DocumentProcessor &#123;    // 1. 文本分块：解决LLM上下文长度限制    // 2. 元数据提取：支持基于属性的过滤检索    // 3. 质量过滤：去除低质量内容    // 4. 格式标准化：统一不同来源文档格式&#125;\n\n为什么要分块？\n\n上下文限制：大多数LLM有最大token限制（GPT-4为8192，Claude为100k）\n检索精度：小块内容更容易找到精确匹配\n计算效率：减少向量化计算量和存储成本\n\n2. 向量检索组件（Vector Search）// 为什么使用向量检索而不是传统检索？public class VectorSearchEngine &#123;    // 1. 语义理解：理解查询意图而非关键词匹配    // 2. 模糊匹配：处理同义词、多义词问题    // 3. 跨语言支持：支持多语言内容检索    // 4. 实时更新：支持动态添加新内容&#125;\n\n向量检索优势：\n\n语义匹配：传统BM25只能做关键词匹配，向量检索能理解语义\n扩展性好：支持海量数据的实时检索\n多模态支持：不仅支持文本，还支持图像、音频等\n\n3. 生成增强组件（Generation Augmentation）// 为什么需要检索增强生成？public class EnhancedGenerator &#123;    // 1. 上下文增强：提供相关背景信息    // 2. 事实验证：基于检索结果生成答案    // 3. 引用支持：提供答案来源依据    // 4. 减少幻觉：降低模型胡说八道的概率&#125;\n\n技术选型分析为什么选择Milvus？在众多向量数据库中选择Milvus的原因：\n\n\n\n特性\nMilvus\nPinecone\nWeaviate\nQdrant\n\n\n\n开源程度\n完全开源\n闭源SaaS\n开源\n开源\n\n\n部署方式\n自托管\n云服务\n自托管\n自托管\n\n\n扩展性\n水平扩展\n有限\n水平扩展\n水平扩展\n\n\n企业支持\n商业版可用\n企业版\n商业版\n企业版\n\n\nJava支持\n原生SDK\nREST API\nREST API\nREST API\n\n\n成本控制\n完全可控\n按量计费\n可控\n可控\n\n\n选择Milvus的关键原因：\n\n完全开源：企业可以完全控制数据和代码\n原生Java SDK：性能更好，集成更简单\n水平扩展：支持PB级数据存储\n企业级特性：提供商业支持和企业版\n活跃社区：有完善的文档和社区支持\n\n系统架构设计整体架构图┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐│   企业文档      │    │   文档处理      │    │   向量检索      ││   (PDF, Word,   │───▶│   (分块向量化)  │───▶│   (Milvus)     ││    Markdown)    │    │                 │    │                 │└─────────────────┘    └─────────────────┘    └─────────────────┘         │                        │                        │         ▼                        ▼                        ▼┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐│   用户查询      │    │   检索增强      │    │   答案生成      ││   (自然语言)    │───▶│   (Reranking)   │───▶│   (LLM)        │└─────────────────┘    └─────────────────┘    └─────────────────┘\n\n各模块职责分析1. 数据接入层为什么需要数据接入层？\n\n统一接口：屏蔽不同数据源的差异\n数据质量：过滤和清洗原始数据\n格式转换：统一转换为系统可处理的格式\n权限控制：确保数据访问的安全性\n\n2. 文档处理层文档处理的核心目标：\n\n分块策略：确定最佳的文本分块大小\n元数据提取：提取文档的关键信息\n质量评估：过滤低质量内容\n向量化准备：为后续向量化做准备\n\n3. 向量检索层Milvus集群的作用：\n\n高性能检索：支持毫秒级向量检索\n水平扩展：支持海量数据存储\n多索引支持：根据场景选择最佳索引\n分布式部署：保证高可用性和扩展性\n\n4. 生成增强层检索结果增强的必要性：\n\n相关性排序：确保最重要的信息优先\n上下文整合：提供完整的背景信息\n答案验证：确保答案的准确性\n引用标注：提供答案来源依据\n\n环境准备与部署开发环境配置1. Java环境要求&lt;!-- pom.xml --&gt;&lt;properties&gt;    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;!-- 为什么选择Java 17？ --&gt;    &lt;!-- 1. LTS版本，长期支持 --&gt;    &lt;!-- 2. 性能优化，新特性支持 --&gt;    &lt;!-- 3. 企业级应用的最佳选择 --&gt;&lt;/properties&gt;\n\n2. 核心依赖配置&lt;dependencies&gt;    &lt;!-- Spring Boot 核心 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;        &lt;!-- Milvus Java SDK --&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.milvus&lt;/groupId&gt;        &lt;artifactId&gt;milvus-sdk-java&lt;/artifactId&gt;        &lt;version&gt;2.3.6&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 文档处理 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.tika&lt;/groupId&gt;        &lt;artifactId&gt;tika-core&lt;/artifactId&gt;        &lt;version&gt;2.9.1&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 向量化模型 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.knuddels&lt;/groupId&gt;        &lt;artifactId&gt;jtokkit&lt;/artifactId&gt;        &lt;version&gt;1.0.0&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- LLM集成 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.theokanning.openai-gpt3-java&lt;/groupId&gt;        &lt;artifactId&gt;service&lt;/artifactId&gt;        &lt;version&gt;0.18.2&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\nMilvus部署方案1. 单机部署（开发环境）# docker-compose.ymlversion: &#x27;3.8&#x27;services:  milvus-standalone:    image: milvusdb/milvus:v2.3.6    container_name: milvus-standalone    ports:      - &quot;19530:19530&quot;  # Milvus端口      - &quot;9091:9091&quot;    # Web UI端口    volumes:      - ./milvus:/var/lib/milvus    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;standalone&quot;]\n\n2. 集群部署（生产环境）# 生产环境推荐配置services:  milvus-etcd:    image: quay.io/coreos/etcd:v3.5.5    environment:      - ETCD_AUTO_COMPACTION_MODE=revision      - ETCD_AUTO_COMPACTION_RETENTION=1000      - ETCD_QUOTA_BACKEND_BYTES=4294967296      - ETCD_SNAPSHOT_COUNT=50000    milvus-minio:    image: minio/minio:RELEASE.2023-03-20T20-16-18Z    environment:      MINIO_ACCESS_KEY: minioadmin      MINIO_SECRET_KEY: minioadmin    command: minio server /minio_data --console-address :9001    milvus-datacoord:    image: milvusdb/milvus:v2.3.6    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;datacoord&quot;]    depends_on:      - milvus-etcd      - milvus-minio    milvus-datanode:    image: milvusdb/milvus:v2.3.6    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;datanode&quot;]    depends_on:      - milvus-datacoord    milvus-querycoord:    image: milvusdb/milvus:v2.3.6    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;querycoord&quot;]    depends_on:      - milvus-etcd    milvus-querynode:    image: milvusdb/milvus:v2.3.6    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;querynode&quot;]    depends_on:      - milvus-querycoord    milvus-indexcoord:    image: milvusdb/milvus:v2.3.6    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;indexcoord&quot;]    depends_on:      - milvus-etcd    milvus-indexnode:    image: milvusdb/milvus:v2.3.6    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;indexnode&quot;]    depends_on:      - milvus-indexcoord    milvus-proxy:    image: milvusdb/milvus:v2.3.6    ports:      - &quot;19530:19530&quot;    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;proxy&quot;]    depends_on:      - milvus-querycoord      - milvus-datacoord\n\n为什么采用集群部署？\n\n高可用性：单点故障不会影响整个系统\n水平扩展：可以根据数据量动态扩展节点\n负载均衡：分散读写压力，提高并发性能\n数据安全：多副本存储，保证数据不丢失\n\n核心实现代码1. 配置文件设计# application.ymlmilvus:  host: localhost  port: 19530  collection:    name: enterprise_docs    description: &quot;企业文档知识库&quot;    vector:      dimension: 1536  # OpenAI text-embedding-ada-002维度      metric-type: COSINE  # 相似度度量方式      index-type: IVF_FLAT  # 索引类型      index-params:        nlist: 128  # 聚类中心数量openai:  api-key: $&#123;OPENAI_API_KEY&#125;  model: gpt-3.5-turbo  embedding-model: text-embedding-ada-002  max-tokens: 4000document:  chunk:    size: 1000  # 分块大小    overlap: 200  # 分块重叠  supported-types:    - pdf    - docx    - txt    - md\n\n2. 文档处理服务@Service@Slf4jpublic class DocumentProcessingService &#123;        @Autowired    private MilvusService milvusService;        @Autowired    private EmbeddingService embeddingService;        /**     * 文档处理核心流程     * 为什么需要这个完整的处理流程？     * 1. 文档解析：将各种格式转换为纯文本     * 2. 文本分块：解决LLM上下文长度限制     * 3. 向量化：转换为向量表示     * 4. 存储：保存到向量数据库     */    public void processDocument(MultipartFile file, String category, String tags) &#123;        try &#123;            // 1. 文档解析            String content = parseDocument(file);            log.info(&quot;文档解析完成，内容长度: &#123;&#125;&quot;, content.length());                        // 2. 文本分块            List&lt;DocumentChunk&gt; chunks = splitDocument(content, category, tags);            log.info(&quot;文本分块完成，分块数量: &#123;&#125;&quot;, chunks.size());                        // 3. 批量向量化            List&lt;float[]&gt; vectors = embeddingService.embedTexts(                chunks.stream()                    .map(DocumentChunk::getContent)                    .collect(Collectors.toList())            );            log.info(&quot;向量化完成，向量维度: &#123;&#125;&quot;, vectors.get(0).length);                        // 4. 存储到Milvus            milvusService.insertDocuments(chunks, vectors);            log.info(&quot;文档存储完成，总计: &#123;&#125; 个分块&quot;, chunks.size());                    &#125; catch (Exception e) &#123;            log.error(&quot;文档处理失败: &#123;&#125;&quot;, file.getOriginalFilename(), e);            throw new RuntimeException(&quot;文档处理失败&quot;, e);        &#125;    &#125;        /**     * 文档解析 - 支持多种格式     */    private String parseDocument(MultipartFile file) throws Exception &#123;        String fileName = file.getOriginalFilename();        String extension = fileName.substring(fileName.lastIndexOf(&quot;.&quot;) + 1).toLowerCase();                try (InputStream input = file.getInputStream()) &#123;            AutoDetectParser parser = new AutoDetectParser();            BodyContentHandler handler = new BodyContentHandler(-1); // 不限制内容大小            Metadata metadata = new Metadata();            ParseContext context = new ParseContext();                        parser.parse(input, handler, metadata, context);            return handler.toString();        &#125;    &#125;        /**     * 智能文本分块策略     * 为什么需要智能分块？     * 1. 保持语义完整性：避免在句子中间截断     * 2. 控制分块大小：确保每个分块在合理范围内     * 3. 重叠策略：保持上下文连贯性     * 4. 元数据保留：保留原始文档信息     */    private List&lt;DocumentChunk&gt; splitDocument(String content, String category, String tags) &#123;        List&lt;DocumentChunk&gt; chunks = new ArrayList&lt;&gt;();                // 按段落分割        String[] paragraphs = content.split(&quot;\\\\n\\\\s*\\\\n&quot;);        StringBuilder currentChunk = new StringBuilder();                for (String paragraph : paragraphs) &#123;            // 如果添加当前段落会超过限制，开始新分块            if (currentChunk.length() + paragraph.length() &gt;                 documentConfig.getChunkSize() - documentConfig.getOverlap()) &#123;                                if (currentChunk.length() &gt; 0) &#123;                    chunks.add(createDocumentChunk(currentChunk.toString(),                                                  category, tags, chunks.size()));                                        // 保留重叠内容                    String overlapContent = getOverlapContent(currentChunk.toString());                    currentChunk = new StringBuilder(overlapContent);                &#125;            &#125;                        if (currentChunk.length() &gt; 0) &#123;                currentChunk.append(&quot;\\n\\n&quot;);            &#125;            currentChunk.append(paragraph);        &#125;                // 处理最后一个分块        if (currentChunk.length() &gt; 0) &#123;            chunks.add(createDocumentChunk(currentChunk.toString(),                                          category, tags, chunks.size()));        &#125;                return chunks;    &#125;        /**     * 获取重叠内容 - 保持上下文连贯性     */    private String getOverlapContent(String content) &#123;        String[] sentences = content.split(&quot;(?&lt;=[.!?])\\\\s+&quot;);        StringBuilder overlap = new StringBuilder();        int overlapSize = 0;                // 从后往前添加句子，直到达到重叠大小        for (int i = sentences.length - 1; i &gt;= 0; i--) &#123;            if (overlapSize + sentences[i].length() &gt; documentConfig.getOverlap()) &#123;                break;            &#125;            overlap.insert(0, sentences[i] + &quot; &quot;);            overlapSize += sentences[i].length();        &#125;                return overlap.toString().trim();    &#125;        /**     * 创建文档分块对象     */    private DocumentChunk createDocumentChunk(String content, String category,                                             String tags, int chunkIndex) &#123;        return DocumentChunk.builder()                .id(UUID.randomUUID().toString())                .content(content)                .category(category)                .tags(tags)                .chunkIndex(chunkIndex)                .createTime(new Date())                .build();    &#125;&#125;\n\n3. Milvus服务封装@Service@Slf4jpublic class MilvusService &#123;        @Autowired    private MilvusClient milvusClient;        @Autowired    private MilvusConfig milvusConfig;        /**     * 初始化集合     * 为什么需要集合初始化？     * 1. 定义数据结构：指定向量维度和字段类型     * 2. 创建索引：为向量字段创建合适的索引     * 3. 设置参数：配置集合的各种参数     */    @PostConstruct    public void initCollection() &#123;        try &#123;            // 检查集合是否存在            boolean exists = milvusClient.hasCollection(                HasCollectionParam.newBuilder()                    .withCollectionName(milvusConfig.getCollectionName())                    .build()            ).getData();                        if (!exists) &#123;                log.info(&quot;创建Milvus集合: &#123;&#125;&quot;, milvusConfig.getCollectionName());                                // 创建集合                milvusClient.createCollection(                    CreateCollectionParam.newBuilder()                        .withCollectionName(milvusConfig.getCollectionName())                        .withDescription(milvusConfig.getDescription())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;id&quot;)                            .withDataType(DataType.VarChar)                            .withMaxLength(64)                            .withPrimaryKey(true)                            .withAutoID(false)                            .build())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;vector&quot;)                            .withDataType(DataType.FloatVector)                            .withDimension(milvusConfig.getVectorDimension())                            .build())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;content&quot;)                            .withDataType(DataType.VarChar)                            .withMaxLength(65535)                            .build())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;category&quot;)                            .withDataType(DataType.VarChar)                            .withMaxLength(100)                            .build())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;tags&quot;)                            .withDataType(DataType.VarChar)                            .withMaxLength(500)                            .build())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;chunk_index&quot;)                            .withDataType(DataType.Int64)                            .build())                        .addFieldType(FieldType.newBuilder()                            .withName(&quot;create_time&quot;)                            .withDataType(DataType.Int64)                            .build())                        .build()                );                                // 创建索引                createIndex();                                log.info(&quot;Milvus集合创建成功&quot;);            &#125;        &#125; catch (Exception e) &#123;            log.error(&quot;Milvus集合初始化失败&quot;, e);            throw new RuntimeException(&quot;Milvus集合初始化失败&quot;, e);        &#125;    &#125;        /**     * 创建向量索引     * 为什么需要合适的索引？     * 1. 检索性能：索引可以大大提升检索速度     * 2. 内存效率：减少内存使用     * 3. 准确性：不同索引类型对准确性影响不同     */    private void createIndex() &#123;        try &#123;            // 为向量字段创建IVF_FLAT索引            CreateIndexParam indexParam = CreateIndexParam.newBuilder()                .withCollectionName(milvusConfig.getCollectionName())                .withFieldName(&quot;vector&quot;)                .withIndexType(IndexType.IVF_FLAT)                .withMetricType(MetricType.COSINE)                .withExtraParam(&quot;&#123;\\&quot;nlist\\&quot;: 128&#125;&quot;)                .withSyncMode(Boolean.FALSE)                .build();                        milvusClient.createIndex(indexParam);            log.info(&quot;向量索引创建成功&quot;);                    &#125; catch (Exception e) &#123;            log.error(&quot;向量索引创建失败&quot;, e);            throw new RuntimeException(&quot;向量索引创建失败&quot;, e);        &#125;    &#125;        /**     * 批量插入文档     */    public void insertDocuments(List&lt;DocumentChunk&gt; chunks, List&lt;float[]&gt; vectors) &#123;        try &#123;            List&lt;InsertParam.Field&gt; fields = new ArrayList&lt;&gt;();                        // ID字段            List&lt;String&gt; ids = chunks.stream()                .map(DocumentChunk::getId)                .collect(Collectors.toList());            fields.add(new InsertParam.Field(&quot;id&quot;, ids));                        // 向量字段            fields.add(new InsertParam.Field(&quot;vector&quot;, vectors));                        // 内容字段            List&lt;String&gt; contents = chunks.stream()                .map(DocumentChunk::getContent)                .collect(Collectors.toList());            fields.add(new InsertParam.Field(&quot;content&quot;, contents));                        // 其他字段...            List&lt;String&gt; categories = chunks.stream()                .map(DocumentChunk::getCategory)                .collect(Collectors.toList());            fields.add(new InsertParam.Field(&quot;category&quot;, categories));                        // 执行插入            InsertParam insertParam = InsertParam.newBuilder()                .withCollectionName(milvusConfig.getCollectionName())                .withFields(fields)                .build();                        InsertResponse response = milvusClient.insert(insertParam);                        // 刷新数据到磁盘            milvusClient.flush(FlushParam.newBuilder()                .withCollectionName(milvusConfig.getCollectionName())                .addFlushCollectionName(milvusConfig.getCollectionName())                .build());                        log.info(&quot;成功插入 &#123;&#125; 个文档分块&quot;, chunks.size());                    &#125; catch (Exception e) &#123;            log.error(&quot;文档插入失败&quot;, e);            throw new RuntimeException(&quot;文档插入失败&quot;, e);        &#125;    &#125;        /**     * 向量检索     * 为什么需要多重过滤？     * 1. 相关性过滤：基于相似度阈值     * 2. 类别过滤：基于文档类别     * 3. 时间过滤：基于创建时间     * 4. 权限过滤：基于用户权限     */    public List&lt;SearchResult&gt; search(float[] queryVector, int topK,                                    String category, Date startTime) &#123;        try &#123;            // 构建搜索参数            SearchParam searchParam = SearchParam.newBuilder()                .withCollectionName(milvusConfig.getCollectionName())                .withVectorFieldName(&quot;vector&quot;)                .withVectors(Collections.singletonList(queryVector))                .withTopK(topK)                .withMetricType(MetricType.COSINE)                .withParams(&quot;&#123;\\&quot;nprobe\\&quot;: 10&#125;&quot;)                .build();                        // 添加过滤条件            if (category != null || startTime != null) &#123;                StringBuilder filter = new StringBuilder();                                if (category != null) &#123;                    filter.append(&quot;category == \\&quot;&quot;).append(category).append(&quot;\\&quot;&quot;);                &#125;                                if (startTime != null) &#123;                    if (filter.length() &gt; 0) filter.append(&quot; and &quot;);                    filter.append(&quot;create_time &gt;= &quot;).append(startTime.getTime());                &#125;                                searchParam = searchParam.toBuilder()                    .withExpr(filter.toString())                    .build();            &#125;                        // 执行搜索            SearchResponse response = milvusClient.search(searchParam);                        // 解析结果            return parseSearchResults(response);                    &#125; catch (Exception e) &#123;            log.error(&quot;向量检索失败&quot;, e);            throw new RuntimeException(&quot;向量检索失败&quot;, e);        &#125;    &#125;        /**     * 解析搜索结果     */    private List&lt;SearchResult&gt; parseSearchResults(SearchResponse response) &#123;        List&lt;SearchResult&gt; results = new ArrayList&lt;&gt;();                List&lt;List&lt;SearchResponse.QueryResult&gt;&gt; queryResults = response.getResults();        for (List&lt;SearchResponse.QueryResult&gt; queryResult : queryResults) &#123;            for (SearchResponse.QueryResult result : queryResult) &#123;                SearchResult searchResult = new SearchResult();                searchResult.setId(result.getEntity().get(&quot;id&quot;).toString());                searchResult.setContent(result.getEntity().get(&quot;content&quot;).toString());                searchResult.setScore(result.getScore());                searchResult.setCategory(result.getEntity().get(&quot;category&quot;).toString());                results.add(searchResult);            &#125;        &#125;                return results;    &#125;&#125;\n\n4. 检索增强生成服务@Service@Slf4jpublic class RagService &#123;        @Autowired    private EmbeddingService embeddingService;        @Autowired    private MilvusService milvusService;        @Autowired    private OpenAiService openAiService;        /**     * RAG问答核心流程     * 为什么需要这个完整的RAG流程？     * 1. 查询理解：准确理解用户意图     * 2. 检索增强：获取相关上下文     * 3. 答案生成：基于检索结果生成答案     * 4. 引用标注：提供答案来源依据     */    public RagResponse answerQuestion(String question, String category,                                     Integer maxResults) &#123;        try &#123;            log.info(&quot;开始处理问题: &#123;&#125;&quot;, question);                        // 1. 问题向量化            float[] queryVector = embeddingService.embedText(question);            log.info(&quot;问题向量化完成，向量维度: &#123;&#125;&quot;, queryVector.length);                        // 2. 向量检索            List&lt;SearchResult&gt; searchResults = milvusService.search(                queryVector,                 maxResults != null ? maxResults : 5,                category,                null // 可以根据需要添加时间过滤            );            log.info(&quot;检索完成，找到 &#123;&#125; 个相关文档&quot;, searchResults.size());                        // 3. 结果重排序和过滤            List&lt;SearchResult&gt; filteredResults = rerankAndFilter(searchResults, question);            log.info(&quot;重排序后剩余 &#123;&#125; 个文档&quot;, filteredResults.size());                        // 4. 构建上下文            String context = buildContext(filteredResults);            log.info(&quot;上下文构建完成，长度: &#123;&#125; 字符&quot;, context.length());                        // 5. 生成答案            String answer = generateAnswer(question, context);            log.info(&quot;答案生成完成，长度: &#123;&#125; 字符&quot;, answer.length());                        // 6. 构建引用            List&lt;Reference&gt; references = buildReferences(filteredResults);                        return RagResponse.builder()                    .question(question)                    .answer(answer)                    .references(references)                    .searchResults(filteredResults)                    .build();                    &#125; catch (Exception e) &#123;            log.error(&quot;RAG问答处理失败: &#123;&#125;&quot;, question, e);            throw new RuntimeException(&quot;问答处理失败&quot;, e);        &#125;    &#125;        /**     * 结果重排序和过滤     * 为什么需要重排序？     * 1. 提高相关性：基于问题和文档的相关性重新排序     * 2. 过滤低质量：去除相似度过低的结果     * 3. 多样性保证：避免返回过于相似的文档     * 4. 长度控制：控制上下文总长度     */    private List&lt;SearchResult&gt; rerankAndFilter(List&lt;SearchResult&gt; results, String question) &#123;        // 1. 按相似度阈值过滤        results = results.stream()            .filter(r -&gt; r.getScore() &gt; 0.7) // 相似度阈值            .collect(Collectors.toList());                // 2. 按相关性重排序（这里使用简单的BM25-like算法）        results.forEach(result -&gt; &#123;            double relevanceScore = calculateRelevanceScore(question, result.getContent());            result.setScore(result.getScore() * 0.7 + relevanceScore * 0.3);        &#125;);                // 3. 按新得分排序        results.sort((a, b) -&gt; Double.compare(b.getScore(), a.getScore()));                // 4. 限制数量和长度        int maxLength = 8000; // 上下文最大长度        int currentLength = 0;        List&lt;SearchResult&gt; filtered = new ArrayList&lt;&gt;();                for (SearchResult result : results) &#123;            if (currentLength + result.getContent().length() &gt; maxLength) &#123;                break;            &#125;            filtered.add(result);            currentLength += result.getContent().length();        &#125;                return filtered;    &#125;        /**     * 计算相关性得分     */    private double calculateRelevanceScore(String question, String content) &#123;        // 简单的词频统计        String[] questionWords = question.toLowerCase().split(&quot;\\\\s+&quot;);        String contentLower = content.toLowerCase();                int matchCount = 0;        for (String word : questionWords) &#123;            if (contentLower.contains(word)) &#123;                matchCount++;            &#125;        &#125;                return (double) matchCount / questionWords.length;    &#125;        /**     * 构建上下文     * 为什么需要精心构建上下文？     * 1. 长度控制：避免超出LLM上下文限制     * 2. 信息密度：选择最相关的信息     * 3. 结构化：保持文档的逻辑结构     * 4. 引用标记：为后续引用做准备     */    private String buildContext(List&lt;SearchResult&gt; results) &#123;        StringBuilder context = new StringBuilder();        context.append(&quot;基于以下企业文档内容来回答问题：\\n\\n&quot;);                for (int i = 0; i &lt; results.size(); i++) &#123;            SearchResult result = results.get(i);            context.append(String.format(&quot;[文档%d] (相似度: %.3f, 类别: %s)\\n&quot;,                i + 1, result.getScore(), result.getCategory()));            context.append(result.getContent());            context.append(&quot;\\n\\n&quot;);        &#125;                context.append(&quot;请基于上述文档内容准确回答问题，如果文档中没有相关信息，请明确说明。&quot;);                return context.toString();    &#125;        /**     * 生成答案     */    private String generateAnswer(String question, String context) &#123;        String prompt = String.format(            &quot;请基于以下上下文信息回答问题。要求：\\n&quot; +            &quot;1. 答案必须基于提供的上下文信息\\n&quot; +            &quot;2. 如果上下文信息不足以回答，请明确说明\\n&quot; +            &quot;3. 保持答案的准确性和客观性\\n&quot; +            &quot;4. 适当引用文档来源\\n\\n&quot; +            &quot;上下文信息：\\n%s\\n\\n&quot; +            &quot;问题：%s\\n\\n&quot; +            &quot;答案：&quot;,            context, question        );                return openAiService.generateAnswer(prompt);    &#125;        /**     * 构建引用列表     */    private List&lt;Reference&gt; buildReferences(List&lt;SearchResult&gt; results) &#123;        return results.stream()            .map(result -&gt; Reference.builder()                .documentId(result.getId())                .content(result.getContent().substring(0,                     Math.min(200, result.getContent().length())))                .similarityScore(result.getScore())                .category(result.getCategory())                .build())            .collect(Collectors.toList());    &#125;&#125;\n\n5. 向量化服务@Service@Slf4jpublic class EmbeddingService &#123;        @Autowired    private OpenAiService openAiService;        /**     * 文本向量化     * 为什么需要高质量的向量化？     * 1. 语义理解：准确捕捉文本语义信息     * 2. 一致性：相同语义的文本应该有相似的向量     * 3. 维度合适：平衡精度和计算效率     * 4. 多语言支持：支持企业多语言环境     */    public float[] embedText(String text) &#123;        try &#123;            // 文本预处理            String processedText = preprocessText(text);                        // 调用OpenAI Embedding API            EmbeddingResult result = openAiService.createEmbedding(processedText);                        return convertToFloatArray(result.getData().get(0).getEmbedding());                    &#125; catch (Exception e) &#123;            log.error(&quot;文本向量化失败: &#123;&#125;&quot;, text.substring(0, 100), e);            throw new RuntimeException(&quot;文本向量化失败&quot;, e);        &#125;    &#125;        /**     * 批量文本向量化     * 为什么需要批量处理？     * 1. 提高效率：减少API调用次数     * 2. 降低成本：批量调用通常更便宜     * 3. 错误处理：统一处理批量错误     * 4. 资源控制：避免突发流量     */    public List&lt;float[]&gt; embedTexts(List&lt;String&gt; texts) &#123;        try &#123;            // 分批处理，避免单次请求过大            List&lt;float[]&gt; allEmbeddings = new ArrayList&lt;&gt;();            int batchSize = 10; // 根据API限制调整                        for (int i = 0; i &lt; texts.size(); i += batchSize) &#123;                int endIndex = Math.min(i + batchSize, texts.size());                List&lt;String&gt; batch = texts.subList(i, endIndex);                                List&lt;String&gt; processedBatch = batch.stream()                    .map(this::preprocessText)                    .collect(Collectors.toList());                                EmbeddingResult result = openAiService.createEmbeddings(processedBatch);                                for (Embedding embedding : result.getData()) &#123;                    allEmbeddings.add(convertToFloatArray(embedding.getEmbedding()));                &#125;                                // 添加延迟，避免触发API限流                if (endIndex &lt; texts.size()) &#123;                    Thread.sleep(100);                &#125;            &#125;                        return allEmbeddings;                    &#125; catch (Exception e) &#123;            log.error(&quot;批量文本向量化失败&quot;, e);            throw new RuntimeException(&quot;批量文本向量化失败&quot;, e);        &#125;    &#125;        /**     * 文本预处理     * 为什么需要预处理？     * 1. 长度控制：确保文本在模型限制内     * 2. 格式清理：去除多余的格式字符     * 3. 语言标准化：统一语言编码     * 4. 质量提升：提高向量化质量     */    private String preprocessText(String text) &#123;        if (text == null || text.trim().isEmpty()) &#123;            return &quot;&quot;;        &#125;                // 1. 去除多余空白字符        text = text.replaceAll(&quot;\\\\s+&quot;, &quot; &quot;).trim();                // 2. 控制长度        if (text.length() &gt; 8000) &#123; // OpenAI的合理长度限制            text = text.substring(0, 8000);        &#125;                // 3. 去除特殊字符        text = text.replaceAll(&quot;[\\\\x00-\\\\x1F\\\\x7F-\\\\x9F]&quot;, &quot;&quot;);                return text;    &#125;        /**     * 转换向量格式     */    private float[] convertToFloatArray(List&lt;Double&gt; embedding) &#123;        float[] result = new float[embedding.size()];        for (int i = 0; i &lt; embedding.size(); i++) &#123;            result[i] = embedding.get(i).floatValue();        &#125;        return result;    &#125;&#125;\n\n性能优化策略1. 索引优化@Servicepublic class IndexOptimizationService &#123;        /**     * 动态索引选择策略     * 为什么需要动态索引选择？     * 1. 数据特征：不同数据适合不同索引     * 2. 查询模式：不同查询需要不同索引     * 3. 性能平衡：平衡构建时间和查询时间     * 4. 资源限制：考虑内存和存储限制     */    public void optimizeIndex(String collectionName, DatasetCharacteristics characteristics) &#123;                // 根据数据量选择索引类型        if (characteristics.getDataSize() &lt; 10000) &#123;            // 小数据集：使用FLAT索引，准确性优先            createFlatIndex(collectionName);        &#125; else if (characteristics.getDataSize() &lt; 100000) &#123;            // 中等数据集：使用IVF_FLAT            createIvfFlatIndex(collectionName, 128);        &#125; else &#123;            // 大数据集：使用IVF_PQ，压缩存储            createIvfPQIndex(collectionName, 128, 64);        &#125;    &#125;        /**     * IVF_FLAT索引：平衡准确性和性能     */    private void createIvfFlatIndex(String collectionName, int nlist) &#123;        // nlist：聚类中心数量，影响索引构建时间和查询性能        // 经验值：nlist = sqrt(数据量)，但不超过4*sqrt(数据量)    &#125;        /**     * IVF_PQ索引：牺牲少量准确性，获得更好的压缩效果     */    private void createIvfPQIndex(String collectionName, int nlist, int m) &#123;        // m：向量被分割的段数，影响压缩率和准确性        // 经验值：m = 维度/4，但不超过维度/2    &#125;&#125;\n\n2. 缓存策略@Service@Slf4jpublic class CacheService &#123;        @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;        /**     * 多级缓存策略     * 为什么需要多级缓存？     * 1. 查询加速：避免重复向量检索     * 2. 成本控制：减少向量化API调用     * 3. 用户体验：提高响应速度     * 4. 系统稳定性：减轻下游服务压力     */        // 向量缓存：缓存查询向量    private static final String VECTOR_CACHE_PREFIX = &quot;rag:vector:&quot;;    private static final Duration VECTOR_CACHE_TTL = Duration.ofHours(24);        // 结果缓存：缓存检索结果    private static final String RESULT_CACHE_PREFIX = &quot;rag:result:&quot;;    private static final Duration RESULT_CACHE_TTL = Duration.ofHours(1);        // 答案缓存：缓存完整答案    private static final String ANSWER_CACHE_PREFIX = &quot;rag:answer:&quot;;    private static final Duration ANSWER_CACHE_TTL = Duration.ofMinutes(30);        /**     * 获取缓存的向量     */    public float[] getCachedVector(String text) &#123;        String key = VECTOR_CACHE_PREFIX + DigestUtils.md5Hex(text);        return (float[]) redisTemplate.opsForValue().get(key);    &#125;        /**     * 缓存向量     */    public void cacheVector(String text, float[] vector) &#123;        String key = VECTOR_CACHE_PREFIX + DigestUtils.md5Hex(text);        redisTemplate.opsForValue().set(key, vector, VECTOR_CACHE_TTL);    &#125;        /**     * 获取缓存的检索结果     */    public List&lt;SearchResult&gt; getCachedResults(String query, String category) &#123;        String key = RESULT_CACHE_PREFIX + DigestUtils.md5Hex(query + category);        return (List&lt;SearchResult&gt;) redisTemplate.opsForValue().get(key);    &#125;        /**     * 缓存检索结果     */    public void cacheResults(String query, String category, List&lt;SearchResult&gt; results) &#123;        String key = RESULT_CACHE_PREFIX + DigestUtils.md5Hex(query + category);        redisTemplate.opsForValue().set(key, results, RESULT_CACHE_TTL);    &#125;&#125;\n\n3. 并发控制@Configurationpublic class AsyncConfig &#123;        /**     * 线程池配置     * 为什么需要自定义线程池？     * 1. 控制并发：避免过多的并发请求     * 2. 资源隔离：与Web容器线程池分离     * 3. 性能监控：便于监控和调优     * 4. 错误隔离：避免某个任务影响整个系统     */        @Bean(&quot;ragTaskExecutor&quot;)    public ThreadPoolTaskExecutor ragTaskExecutor() &#123;        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();                // 核心线程数：根据CPU核心数设置        executor.setCorePoolSize(Runtime.getRuntime().availableProcessors());                // 最大线程数：核心线程数的2倍        executor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 2);                // 队列容量：控制等待任务数量        executor.setQueueCapacity(100);                // 线程名前缀：便于日志追踪        executor.setThreadNamePrefix(&quot;rag-task-&quot;);                // 拒绝策略：调用者运行        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());                // 空闲线程存活时间        executor.setKeepAliveSeconds(60);                executor.initialize();        return executor;    &#125;&#125;\n\n监控和运维1. 指标监控@Service@Slf4jpublic class MetricsService &#123;        @Autowired    private MeterRegistry meterRegistry;        // 计数器：记录各种操作次数    private final Counter documentProcessedCounter;    private final Counter searchRequestCounter;    private final Counter answerGeneratedCounter;        // 计时器：记录操作耗时    private final Timer documentProcessingTimer;    private final Timer searchTimer;    private final Timer answerGenerationTimer;        // 直方图：记录数值分布    private final DistributionSummary searchResultSizeSummary;    private final DistributionSummary contextLengthSummary;        public MetricsService(MeterRegistry meterRegistry) &#123;        this.meterRegistry = meterRegistry;                // 初始化计数器        this.documentProcessedCounter = Counter.builder(&quot;rag_documents_processed_total&quot;)                .description(&quot;Total number of documents processed&quot;)                .register(meterRegistry);                this.searchRequestCounter = Counter.builder(&quot;rag_search_requests_total&quot;)                .description(&quot;Total number of search requests&quot;)                .register(meterRegistry);                // 初始化计时器        this.documentProcessingTimer = Timer.builder(&quot;rag_document_processing_duration&quot;)                .description(&quot;Document processing duration&quot;)                .register(meterRegistry);                // 初始化直方图        this.searchResultSizeSummary = DistributionSummary.builder(&quot;rag_search_results_size&quot;)                .description(&quot;Size of search results&quot;)                .register(meterRegistry);    &#125;        /**     * 记录文档处理指标     */    public void recordDocumentProcessing(long duration, int chunkCount) &#123;        documentProcessedCounter.increment();        documentProcessingTimer.record(Duration.ofMillis(duration));                // 记录分块数量        Gauge.builder(&quot;rag_document_chunks&quot;, () -&gt; chunkCount)                .description(&quot;Number of chunks in last processed document&quot;)                .register(meterRegistry);    &#125;        /**     * 记录搜索指标     */    public void recordSearch(long duration, int resultCount, double avgScore) &#123;        searchRequestCounter.increment();        searchTimer.record(Duration.ofMillis(duration));        searchResultSizeSummary.record(resultCount);                // 记录平均相似度        Gauge.builder(&quot;rag_search_avg_score&quot;, () -&gt; avgScore)                .description(&quot;Average similarity score of search results&quot;)                .register(meterRegistry);    &#125;&#125;\n\n2. 健康检查@Componentpublic class HealthCheckService &#123;        @Autowired    private MilvusService milvusService;        @Autowired    private EmbeddingService embeddingService;        @Autowired    private OpenAiService openAiService;        /**     * 综合健康检查     * 为什么需要健康检查？     * 1. 故障检测：及时发现系统故障     * 2. 自动恢复：触发自动恢复机制     * 3. 状态监控：为运维提供系统状态     * 4. 负载均衡：健康检查是负载均衡的基础     */    public HealthStatus checkSystemHealth() &#123;        HealthStatus status = new HealthStatus();                // 检查Milvus连接        status.setMilvusHealthy(checkMilvusHealth());                // 检查Embedding服务        status.setEmbeddingHealthy(checkEmbeddingHealth());                // 检查OpenAI服务        status.setOpenAiHealthy(checkOpenAiHealth());                // 检查系统资源        status.setSystemHealthy(checkSystemResources());                // 总体健康状态        status.setOverallHealthy(            status.isMilvusHealthy() &amp;&amp;             status.isEmbeddingHealthy() &amp;&amp;             status.isOpenAiHealthy() &amp;&amp;             status.isSystemHealthy()        );                return status;    &#125;        /**     * 检查Milvus健康状态     */    private boolean checkMilvusHealth() &#123;        try &#123;            // 执行简单的集合存在性检查            boolean exists = milvusService.collectionExists();            return exists;        &#125; catch (Exception e) &#123;            log.error(&quot;Milvus健康检查失败&quot;, e);            return false;        &#125;    &#125;        /**     * 检查Embedding服务健康状态     */    private boolean checkEmbeddingHealth() &#123;        try &#123;            // 执行简单的向量化测试            float[] vector = embeddingService.embedText(&quot;健康检查测试&quot;);            return vector != null &amp;&amp; vector.length &gt; 0;        &#125; catch (Exception e) &#123;            log.error(&quot;Embedding服务健康检查失败&quot;, e);            return false;        &#125;    &#125;        /**     * 检查系统资源     */    private boolean checkSystemResources() &#123;        // 检查内存使用率        double memoryUsage = getMemoryUsage();        if (memoryUsage &gt; 0.9) &#123; // 内存使用率超过90%            return false;        &#125;                // 检查磁盘空间        double diskUsage = getDiskUsage();        if (diskUsage &gt; 0.9) &#123; // 磁盘使用率超过90%            return false;        &#125;                return true;    &#125;&#125;\n\n最佳实践和注意事项1. 数据管理最佳实践文档预处理public class DocumentPreprocessingBestPractices &#123;        /**     * 文档质量评估     * 为什么需要质量评估？     * 1. 过滤低质量内容：避免污染知识库     * 2. 提高检索准确性：高质量内容检索效果更好     * 3. 节省存储和计算资源：减少无效数据处理     * 4. 维护知识库纯净性：长期保持知识库质量     */    public boolean assessDocumentQuality(String content) &#123;        // 1. 检查内容长度        if (content.length() &lt; 100) &#123;            return false; // 内容过短        &#125;                // 2. 检查内容密度        double textDensity = calculateTextDensity(content);        if (textDensity &lt; 0.3) &#123;            return false; // 文本密度过低，可能包含过多格式字符        &#125;                // 3. 检查重复内容        double uniqueness = calculateUniqueness(content);        if (uniqueness &lt; 0.6) &#123;            return false; // 重复内容过多        &#125;                // 4. 检查语言质量        boolean isValidLanguage = validateLanguage(content);        if (!isValidLanguage) &#123;            return false; // 语言不符合要求        &#125;                return true;    &#125;        /**     * 增量更新策略     * 为什么需要增量更新？     * 1. 实时性：新文档可以立即被检索     * 2. 效率：避免全量重建索引     * 3. 可用性：更新过程中不影响现有服务     * 4. 版本控制：支持文档版本管理     */    public void incrementalUpdate(List&lt;DocumentChunk&gt; newChunks) &#123;        // 1. 标记旧版本为过期        markOldVersionsExpired(newChunks);                // 2. 插入新版本        insertNewVersions(newChunks);                // 3. 异步重建索引        scheduleIndexRebuild();                // 4. 清理过期数据        cleanupExpiredData();    &#125;&#125;\n\n分块策略优化public class ChunkingStrategy &#123;        /**     * 智能分块算法     * 为什么需要智能分块？     * 1. 语义完整性：保持语义单元的完整性     * 2. 检索粒度：平衡检索精度和上下文完整性     * 3. 存储效率：避免过度分割造成的存储浪费     * 4. 查询效率：减少需要检索的分块数量     */        // 基于语义的分块    public List&lt;String&gt; semanticChunking(String content) &#123;        // 1. 句子分割        List&lt;String&gt; sentences = splitIntoSentences(content);                // 2. 语义相似度计算        List&lt;String&gt; chunks = new ArrayList&lt;&gt;();        StringBuilder currentChunk = new StringBuilder();                for (String sentence : sentences) &#123;            if (shouldStartNewChunk(currentChunk.toString(), sentence)) &#123;                if (currentChunk.length() &gt; 0) &#123;                    chunks.add(currentChunk.toString());                    currentChunk = new StringBuilder();                &#125;            &#125;                        currentChunk.append(sentence).append(&quot; &quot;);        &#125;                if (currentChunk.length() &gt; 0) &#123;            chunks.add(currentChunk.toString());        &#125;                return chunks;    &#125;        /**     * 判断是否需要开始新分块     */    private boolean shouldStartNewChunk(String currentChunk, String nextSentence) &#123;        // 1. 长度检查        if (currentChunk.length() + nextSentence.length() &gt; MAX_CHUNK_SIZE) &#123;            return true;        &#125;                // 2. 语义相似度检查        double similarity = calculateSemanticSimilarity(currentChunk, nextSentence);        if (similarity &lt; SEMANTIC_THRESHOLD) &#123;            return true;        &#125;                return false;    &#125;&#125;\n\n2. 性能优化建议查询优化public class QueryOptimizationService &#123;        /**     * 查询预处理     * 为什么需要查询预处理？     * 1. 意图理解：准确理解用户查询意图     * 2. 查询扩展：增加相关查询词     * 3. 噪声过滤：去除无关查询词     * 4. 格式标准化：统一查询格式     */    public String preprocessQuery(String rawQuery) &#123;        // 1. 文本清理        String cleaned = cleanText(rawQuery);                // 2. 意图识别        QueryIntent intent = identifyIntent(cleaned);                // 3. 查询扩展        String expanded = expandQuery(cleaned, intent);                // 4. 权重调整        String weighted = adjustWeights(expanded, intent);                return weighted;    &#125;        /**     * 多路检索策略     * 为什么需要多路检索？     * 1. 提高召回率：不同策略可能召回不同文档     * 2. 结果融合：综合多种检索结果     * 3. 容错性：单个策略失败不影响整体结果     * 4. 个性化：根据用户特点调整检索策略     */    public List&lt;SearchResult&gt; multiPathRetrieval(String query, RetrievalContext context) &#123;        List&lt;CompletableFuture&lt;List&lt;SearchResult&gt;&gt;&gt; futures = new ArrayList&lt;&gt;();                // 1. 向量检索        futures.add(CompletableFuture.supplyAsync(() -&gt;             vectorRetrieval(query, context)));                // 2. 关键词检索        futures.add(CompletableFuture.supplyAsync(() -&gt;             keywordRetrieval(query, context)));                // 3. 混合检索        futures.add(CompletableFuture.supplyAsync(() -&gt;             hybridRetrieval(query, context)));                // 4. 等待所有检索完成        List&lt;List&lt;SearchResult&gt;&gt; allResults = futures.stream()            .map(CompletableFuture::join)            .collect(Collectors.toList());                // 5. 结果融合        return fuseResults(allResults);    &#125;        /**     * 结果融合算法     */    private List&lt;SearchResult&gt; fuseResults(List&lt;List&lt;SearchResult&gt;&gt; allResults) &#123;        // 使用RRF (Reciprocal Rank Fusion) 算法        Map&lt;String, Double&gt; scoreMap = new HashMap&lt;&gt;();        Map&lt;String, SearchResult&gt; resultMap = new HashMap&lt;&gt;();                int k = 60; // RRF常数                for (List&lt;SearchResult&gt; results : allResults) &#123;            for (int rank = 0; rank &lt; results.size(); rank++) &#123;                SearchResult result = results.get(rank);                String id = result.getId();                                // RRF得分计算                double rrfScore = 1.0 / (k + rank + 1);                scoreMap.put(id, scoreMap.getOrDefault(id, 0.0) + rrfScore);                                resultMap.put(id, result);            &#125;        &#125;                // 按融合得分排序        return scoreMap.entrySet().stream()            .sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed())            .map(entry -&gt; &#123;                SearchResult result = resultMap.get(entry.getKey());                result.setScore(entry.getValue());                return result;            &#125;)            .collect(Collectors.toList());    &#125;&#125;\n\n3. 安全和合规考虑数据安全@Servicepublic class SecurityService &#123;        /**     * 数据加密策略     * 为什么需要数据加密？     * 1. 防止数据泄露：保护敏感企业信息     * 2. 合规要求：满足GDPR等法规要求     * 3. 访问控制：确保只有授权用户访问数据     * 4. 审计追踪：记录数据访问历史     */    public void encryptSensitiveData(DocumentChunk chunk) &#123;        // 1. 识别敏感信息        List&lt;String&gt; sensitiveFields = identifySensitiveFields(chunk);                // 2. 加密敏感字段        for (String field : sensitiveFields) &#123;            String encrypted = encryptField(chunk.getFieldValue(field));            chunk.setFieldValue(field, encrypted);        &#125;                // 3. 添加加密元数据        chunk.setEncryptionMetadata(buildEncryptionMetadata());    &#125;        /**     * 访问控制     * 为什么需要访问控制？     * 1. 数据隔离：不同部门数据相互隔离     * 2. 权限分级：不同用户有不同访问权限     * 3. 审计日志：记录所有访问行为     * 4. 合规要求：满足企业安全策略     */    public boolean checkAccessPermission(String userId, String resourceId,                                        String action) &#123;        // 1. 用户身份验证        User user = authenticateUser(userId);                // 2. 权限检查        boolean hasPermission = authorizationService.checkPermission(            user, resourceId, action);                // 3. 审计日志        auditService.logAccess(userId, resourceId, action, hasPermission);                return hasPermission;    &#125;        /**     * 数据脱敏     * 为什么需要数据脱敏？     * 1. 保护隐私：隐藏个人敏感信息     * 2. 测试环境：为测试提供安全数据     * 3. 第三方共享：安全地共享数据给合作伙伴     * 4. 合规要求：满足数据保护法规     */    public String desensitizeData(String content, DesensitizeLevel level) &#123;        switch (level) &#123;            case LOW:                return maskEmails(content);            case MEDIUM:                return maskEmailsAndPhones(content);            case HIGH:                return maskAllPII(content);            default:                return content;        &#125;    &#125;&#125;\n\n部署和运维1. 生产环境部署Docker Compose部署# production-docker-compose.ymlversion: &#x27;3.8&#x27;services:  rag-service:    image: enterprise-rag:latest    ports:      - &quot;8080:8080&quot;    environment:      - SPRING_PROFILES_ACTIVE=prod      - MILVUS_HOST=milvus-standalone      - REDIS_HOST=redis      - OPENAI_API_KEY=$&#123;OPENAI_API_KEY&#125;    depends_on:      - milvus-standalone      - redis    volumes:      - ./logs:/app/logs      - ./config:/app/config    restart: unless-stopped    milvus-standalone:    image: milvusdb/milvus:v2.3.6    ports:      - &quot;19530:19530&quot;      - &quot;9091:9091&quot;    volumes:      - milvus_data:/var/lib/milvus    command: [&quot;milvus&quot;, &quot;run&quot;, &quot;standalone&quot;]    restart: unless-stopped    redis:    image: redis:7-alpine    ports:      - &quot;6379:6379&quot;    volumes:      - redis_data:/data    restart: unless-stopped    prometheus:    image: prom/prometheus:latest    ports:      - &quot;9090:9090&quot;    volumes:      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml      - prometheus_data:/prometheus    restart: unless-stopped    grafana:    image: grafana/grafana:latest    ports:      - &quot;3000:3000&quot;    environment:      - GF_SECURITY_ADMIN_PASSWORD=admin    volumes:      - grafana_data:/var/lib/grafana    restart: unless-stoppedvolumes:  milvus_data:  redis_data:  prometheus_data:  grafana_data:\n\nKubernetes部署# rag-deployment.yamlapiVersion: apps/v1kind: Deploymentmetadata:  name: rag-servicespec:  replicas: 3  selector:    matchLabels:      app: rag-service  template:    metadata:      labels:        app: rag-service    spec:      containers:      - name: rag-service        image: enterprise-rag:latest        ports:        - containerPort: 8080        env:        - name: MILVUS_HOST          value: &quot;milvus-cluster&quot;        - name: REDIS_HOST          value: &quot;redis-cluster&quot;        resources:          requests:            memory: &quot;2Gi&quot;            cpu: &quot;1000m&quot;          limits:            memory: &quot;4Gi&quot;            cpu: &quot;2000m&quot;        livenessProbe:          httpGet:            path: /actuator/health            port: 8080          initialDelaySeconds: 60          periodSeconds: 30        readinessProbe:          httpGet:            path: /actuator/health            port: 8080          initialDelaySeconds: 30          periodSeconds: 10---apiVersion: v1kind: Servicemetadata:  name: rag-servicespec:  selector:    app: rag-service  ports:  - port: 80    targetPort: 8080  type: LoadBalancer\n\n2. 监控告警配置# prometheus.ymlglobal:  scrape_interval: 15srule_files:  - &quot;alert_rules.yml&quot;scrape_configs:  - job_name: &#x27;rag-service&#x27;    static_configs:      - targets: [&#x27;rag-service:8080&#x27;]    metrics_path: &#x27;/actuator/prometheus&#x27;      - job_name: &#x27;milvus&#x27;    static_configs:      - targets: [&#x27;milvus-standalone:9091&#x27;]# alert_rules.ymlgroups:  - name: RAGAlerts    rules:      - alert: HighErrorRate        expr: rate(http_requests_total&#123;status=~&quot;5..&quot;&#125;[5m]) &gt; 0.05        for: 5m        labels:          severity: warning        annotations:          summary: &quot;High error rate detected&quot;                - alert: MilvusDown        expr: up&#123;job=&quot;milvus&quot;&#125; == 0        for: 1m        labels:          severity: critical        annotations:          summary: &quot;Milvus service is down&quot;                - alert: HighMemoryUsage        expr: (1 - system_memory_available / system_memory_total) &gt; 0.9        for: 5m        labels:          severity: warning        annotations:          summary: &quot;High memory usage detected&quot;\n\n总结核心价值通过本文详细介绍的Java+Milvus企业级RAG系统，企业可以：\n\n构建智能化知识库：将企业文档转换为可对话的知识资产\n提升工作效率：员工可以快速获取准确的企业信息\n降低运营成本：减少人工客服和知识查找的时间\n保证数据安全：所有数据存储在企业内部环境\n持续学习能力：系统可以持续纳入新知识\n\n技术亮点架构优势\n模块化设计：各组件独立部署，便于维护和扩展\n高可用架构：集群部署保证服务连续性\n弹性伸缩：根据负载自动调整资源\n多级缓存：优化查询性能和用户体验\n\n性能优化\n智能分块：平衡语义完整性和检索效率\n多路检索：提高召回率和准确性\n增量更新：支持实时知识更新\n并发控制：保证系统稳定性和响应速度\n\n安全合规\n数据加密：保护敏感企业信息\n访问控制：细粒度权限管理\n审计日志：完整的数据访问记录\n合规支持：满足企业安全标准\n\n实施建议分阶段实施\n原型阶段：搭建最小可用系统，验证核心功能\n扩展阶段：增加更多数据源和优化性能\n生产阶段：完善监控、备份和灾备方案\n优化阶段：持续优化用户体验和系统性能\n\n成功关键因素\n数据质量：高质量的数据是系统成功的基础\n用户体验：简洁易用的界面和快速的响应\n持续维护：定期更新知识库和优化系统\n团队协作：跨部门协作保证系统价值最大化\n\n未来展望随着技术的不断发展，企业级RAG系统将在以下方向继续演进：\n\n多模态支持：不仅支持文本，还支持图像、音频等多种模态\n深度学习优化：使用更先进的模型提升理解和生成能力\n个性化定制：根据用户角色和偏好提供个性化服务\n自动化运维：基于AI的自动化监控和故障恢复\n\n通过精心设计的Java+Milvus企业级RAG系统，企业可以有效利用内部知识资产，提升员工工作效率，为数字化转型提供强大支撑。\n参考资料\nMilvus官方文档\nOpenAI Embeddings指南\nSpring Boot官方文档\nRAG技术详解\n向量数据库最佳实践\n企业知识库架构设计\n\n\n本文代码已开源：https://github.com/your-org/enterprise-rag\n技术交流群：扫描二维码加入企业级RAG技术交流群\n最后更新时间：2025-09-03\n","tags":["大语言模型","Java","Spring Boot","向量数据库","Milvus","检索增强生成","向量检索","RAG","企业应用","企业知识库"]}]
---
title: 设计模式-创建型模式-原型模式
date: 2022-05-21 14:14:20
tags:
    - 设计模式
    - 创建型模式
top_img: https://npm.elemecdn.com/ushio-api-img-wallpaper@0.119.120/img_2019-12-29_1920x1080_96_background_normal.jpg
cover: https://npm.elemecdn.com/ushio-api-img-wallpaper@0.119.120/img_2019-12-29_1920x1080_96_background_normal.jpg
---
## 介绍
原型模式是指，一个抽象类 `Prototype` 具有一个`clone` 方法，其实现类`ConcretePrototype1`、`ConcretePrototype2` 实现各自的clone方法，在使用的时候，调用Prototype的clone方法可以clone任意实现类。其作用就是快速创建一个新的对象

## 角色
![img](https://blog-1316004121.cos.ap-guangzhou.myqcloud.com/blogImages/164e896061e7bc95~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

### Prototype（抽象原型类）：
它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。

### ConcretePrototype（具体原型类）：
它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。

### Client（客户类）：
让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。

## 何时使用原型模式
- 需要创建的对象应独立于其类型与创建方式
- 要实例化的类是在运行时决定的
- 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易
- 从功能的角度来讲，不管什么对象，只要复制自身比手工实例化要好，都可以是原型对象
- 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便
- 需要使用组合(树型)对象作为其他东西的基础。例如，使用组合对象作为组件来构建另一个组合对象

## 原型模式原理
一个原型类，只需要实现`Cloneable`接口，覆写`clone`方法，此处`clone`方法可以改成任意的名称，因为`Cloneable`接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是`super.clone()`这句话，`super.clone()`调用的是Object的clone()方法，而在Object类中，clone()是native的
需要注意的是能够实现克隆的Java类必须实现一个标识接口Cloneable，表示这个Java类支持被复制。如果一个类没有实现这个接口但是调用了clone()方法，`Java编译器将抛出一个CloneNotSupportedException异常。`

```java
class ConcretePrototype implements  Cloneable
{
……
public Prototype  clone()
{
　　Object object = null;
　　try {
　　　　　object = super.clone();
　　} catch (CloneNotSupportedException exception) {
　　　　　System.err.println("Not support cloneable");
　　}
　　return (Prototype )object;
}
……
}
```

在客户端创建原型对象和克隆对象也很简单，如下代码所示：


```java
Prototype obj1  = new ConcretePrototype();
Prototype obj2  = obj1.clone();
```

一般而言，Java语言中的clone()方法都需要满足：
- 对任何对象x，都有x.clone() != x，即克隆对象与原型对象不是同一个对象；
- 对任何对象x，都有x.clone().getClass() == x.getClass()，即克隆对象与原型对象的类型一样；
- 如果对象x的equals()方法定义恰当，那么x.clone().equals(x)应该成立。
为了获取对象的一份拷贝，我们可以直接利用Object类的clone()方法，具体步骤如下：
- 在派生类中覆盖基类的clone()方法，并声明为public；
- 在派生类的clone()方法中，调用super.clone()；
- 派生类需实现Cloneable接口。
此时，Object类相当于抽象原型类，所有实现了Cloneable接口的类相当于具体原型类。

## 浅拷贝(ShallowClone)和深拷贝(DeepClone)介绍
- 浅拷贝
在浅拷贝中，如果原型对象的成员变量是值类型，将复制一份给拷贝对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给拷贝对象，也就是说原型对象和拷贝对象的成员变量指向相同的内存地址。简单来说，在浅拷贝中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制
![img](https://blog-1316004121.cos.ap-guangzhou.myqcloud.com/blogImages/e819192d3af8ff629bc3bd59178331ae.gif)
- 深拷贝
在深拷贝中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给拷贝对象，深拷贝将原型对象的所有引用对象也复制一份给拷贝对象。简单来说，在深拷贝中，除了对象本身被复制外，对象所包含的所有成员变量也将复制
![img](https://blog-1316004121.cos.ap-guangzhou.myqcloud.com/blogImages/1a947f62d159593806d1c30cf8b0ac23.gif)

### 总结
简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。clone明显是深复制，clone出来的对象是是不能去影响原型对象的

## 浅拷贝
```java
public class Message implements Cloneable{
    private String name; //姓名
    private ExpenseDetail detail;//消费明细

    public Message() {
        System.out.println("执行构造函数Message");
        detail = new ExpenseDetail();
    }

    public void setMessage(String name, String type,double money) {
        this.name = name;
        this.detail.setType(type);
        this.detail.setMoney(money);
    }

    @NonNull
    @Override
    public Message clone() {
        Message message = null;
        try {
            message = (Message) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        return message;
    }

    public void sendMessage(){
        System.out.println(name +"您好：您今天"+detail.getType()+"消费了"+detail.getMoney()+"元");
    }
}
```
消费明细

```java
public class ExpenseDetail{
    private String type;
    private double money;

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public double getMoney() {
        return money;
    }

    public void setMoney(double money) {
        this.money = money;
    }
}
```

```java
public class MbClient {
    public static void main(String[] args){
        Message message = new Message();
        message.setMessage("张三","吃饭",10);

        Message message1 = message.clone();
        message1.setMessage("李四","看电影",50);

        Message message2 = message.clone();
        message2.setMessage("王五","买书",100);

        message.sendMessage();
        message1.sendMessage();
        message2.sendMessage();
    }
}

结果
执行构造函数Message
张三您好：您今天买书消费了100.0元
李四您好：您今天买书消费了100.0元
王五您好：您今天买书消费了100.0元
```

我们可以看到所有人的消费明细居然都一样，这是因为Object类提供的clone方法，不会拷贝对象中的内部数组和引用对象，导致它们仍旧指向原来对象的内部元素地址，这种拷贝叫做浅拷贝。
> 由此而导致最后一次的值会覆盖前一次的值。
此时的`message.getDetail = message1.getDetail =message2.getDetail`

## 深拷贝
深拷贝方式有两种:`继承cloneable`或者进行`Serializable`

### 继承cloneable接口
```java
public class Message implements Cloneable{
    ...
    
    @NonNull
    @Override
    public Message clone() {
        Message message = null;
        try {
            message = (Message) super.clone();
            message.detail = this.detail.clone();//拷贝消费明细
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        return message;
    }
    ...

}
```
```java
public class ExpenseDetail implements Cloneable{
    private String type;
    private double money;
    ...
    @NonNull
    @Override
    protected ExpenseDetail clone(){

        ExpenseDetail detail = null;
        try {
            detail = (ExpenseDetail) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }

        return detail;
    }
}
```
```java
结果
执行构造函数Message
张三您好：您今天吃饭消费了10.0元
李四您好：您今天看电影消费了50.0元
王五您好：您今天买书消费了100.0元
```

此时的`message.getDetail != message1.getDetail !=message2.getDetail`

### 序列化实现
```java
import  java.io.*;
//附件类
class  Attachment implements Serializable
{
       private  String name; //附件名
       public  void setName(String name)
       {
              this.name  = name;
       }
       public  String getName()
       {
              return  this.name;
       }
     public void download()
     {
            System.out.println("下载附件，文件名为" + name);
     }
}
```
```java
import  java.io.*;
//工作周报类
class  WeeklyLog implements Serializable
{
       private  Attachment attachment;
       private  String name;
       private  String date;
       private  String content;
       public  void setAttachment(Attachment attachment) {
              this.attachment  = attachment;
       }
       public  void setName(String name) {
              this.name  = name;
       }
       public  void setDate(String date) {
              this.date  = date;
       }
       public  void setContent(String content) {
              this.content  = content;
       }
       public  Attachment getAttachment(){
              return  (this.attachment);
       }
       public  String getName() {
              return  (this.name);
       }
       public  String getDate() {
              return  (this.date);
       }
       public  String getContent() {
              return  (this.content);
       }
   //使用序列化技术实现深克隆
       public WeeklyLog deepClone() throws  IOException, ClassNotFoundException, OptionalDataException
       {
              //将对象写入流中
              ByteArrayOutputStream bao=new  ByteArrayOutputStream();
              ObjectOutputStream oos=new  ObjectOutputStream(bao);
              oos.writeObject(this);

              //将对象从流中取出
              ByteArrayInputStream bis=new  ByteArrayInputStream(bao.toByteArray());
              ObjectInputStream ois=new  ObjectInputStream(bis);
              return  (WeeklyLog)ois.readObject();
       }
}
```
工作周报类WeeklyLog不再使用Java自带的克隆机制，而是通过序列化来从头实现对象的深克隆，所以我们需要重新编写clone()方法

```java
class Client
{
       public  static void main(String args[])
       {
              WeeklyLog  log_previous, log_new = null;
              log_previous  = new WeeklyLog(); //创建原型对象
              Attachment  attachment = new Attachment(); //创建附件对象
              log_previous.setAttachment(attachment);  //将附件添加到周报中
              try
              {
                     log_new =  log_previous.deepClone(); //调用深克隆方法创建克隆对象                  
              }
              catch(Exception e)
              {
                     System.err.println("克隆失败！");
              }
              //比较周报
              System.out.println("周报是否相同？ " + (log_previous ==  log_new));
              //比较附件
              System.out.println("附件是否相同？ " +  (log_previous.getAttachment() == log_new.getAttachment()));
       }
}
```
```java
周报是否相同？  false
附件是否相同？  false
```
此情况下：不论是基本数据类型还有引用类型，都是重新创建的

## 优点
> 原型模式是在内存中二进制流的拷贝，要比new一个对象的性能要好，特别是需要生产大量对象时

(1) 当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
(2) 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。
(3) 原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
(4) 可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（如恢复到某一历史状态），可辅助实现撤销操作。

## 缺点
> 直接在内存中拷贝，构造函数是不会执行的，这样就减少了约束，既是优点也是缺点，在实际开发当中应注意这个问题

(1) 需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。
(2) 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦

## 适用场景
(1) 创建新对象成本较大（如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。
(2) 如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。
(3) 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便

## 面试点
- 克隆是否调用构造器方法？
不会，clone方法直接复制内存中的二进制，效率高
- 克隆出的对象和之前的是否一致？
不一致，但是浅拷贝下引用类型对象是一致的（因为指向同一份地址），深拷贝下不一致
- 改变克隆对象的值，原对象是否会变？
基本类型不变，引用类型随之改变

## 参考文献
- [原型模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/prototype-pattern.html)
- [原型模式-Prototype Pattern - 对象的克隆——原型模式（一） - 《设计模式 Java版本》 - 书栈网 · BookStack](https://www.bookstack.cn/read/design-pattern-java/对象的克隆——原型模式（一）.md)
- [设计模式之什么是原型模式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/343917614)
- [设计模式：原型模式 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903648405749767)
- [设计模式-原型模式 - 掘金 (juejin.cn)](https://juejin.cn/post/6844904021258403854)
- [设计模式实战 - 原型模式_技术交流_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/151692?type=all&order=recall&pos=&page=0&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=6646713B267797EE31FEA69CC7FFC4BD-1652844493925)
- [看完就明白的原型模式 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/388259961)
- [23 种设计模式详解（全23种）_鬼灭之刃的博客-CSDN博客_设计模式](https://blog.csdn.net/A1342772/article/details/91349142)
- [23种设计模式全解析 - codeTao - 博客园 (cnblogs.com)](https://www.cnblogs.com/geek6/p/3951677.html)
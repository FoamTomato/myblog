---
title: "Java异常日志MCP服务架构"
date: "2025-01-20 16:45:30"
tags:
    - Java
    - MongoDB
    - MCP
    - 大模型
    - 异常处理
    - 日志分析
top_img: https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=1200&h=400&fit=crop
cover: https://images.unsplash.com/photo-1551288049-bebda4e38f71?w=800&h=600&fit=crop
---

> 在微服务架构中，异常日志不仅是问题排查的重要线索，更是AI辅助诊断的宝贵数据源。本文将详细介绍如何构建完整的Java异常日志捕获、存储和MCP服务架构，让大模型能够智能分析和处理异常信息。

## 🎯 架构概览

### 系统架构图
```
[Java应用] → [异常捕获] → [日志结构化] → [MongoDB存储]
      ↓              ↓              ↓              ↓
[业务逻辑] → [AOP拦截] → [日志模型] → [索引优化]
      ↓              ↓              ↓              ↓
[监控告警] → [实时分析] → [MCP服务] → [大模型调用]
```

### 核心组件说明

## 📋 技术栈选型

### 核心技术栈
- **Spring Boot 2.7+**: 微服务框架
- **MongoDB 5.0+**: 文档型数据库
- **Spring AOP**: 异常拦截
- **MCP (Model Context Protocol)**: 大模型服务协议
- **Jackson**: JSON序列化
- **SLF4J + Logback**: 日志框架

### 依赖版本
```xml
<properties>
    <java.version>17</java.version>
    <spring-boot.version>2.7.18</spring-boot.version>
    <mongodb.version>4.11.1</mongodb.version>
    <jackson.version>2.15.3</jackson.version>
</properties>
```

## 🔧 核心实现

### 1. 异常日志模型设计

#### 基础异常信息模型
```java
@Data
@Document(collection = "exception_logs")
public class ExceptionLog {
    @Id
    private String id;

    // 基础信息
    private String applicationName;
    private String serviceName;
    private String instanceId;

    // 异常信息
    private String exceptionType;
    private String exceptionMessage;
    private String stackTrace;

    // 业务上下文
    private String userId;
    private String requestId;
    private String sessionId;
    private String traceId;

    // 请求信息
    private String httpMethod;
    private String requestUri;
    private String clientIp;
    private Map<String, String> requestHeaders;
    private Map<String, Object> requestParams;
    private Map<String, Object> requestBody;

    // 系统信息
    private String serverName;
    private String serverIp;
    private Integer serverPort;
    private String environment;

    // 性能信息
    private Long executionTime;
    private Long memoryUsage;
    private Integer threadCount;

    // 时间信息
    private LocalDateTime exceptionTime;
    private LocalDateTime createTime;

    // 状态信息
    private ExceptionStatus status;
    private String resolution;
    private Integer occurrenceCount;

    // 分类信息
    private ExceptionCategory category;
    private ExceptionSeverity severity;
    private List<String> tags;

    // AI分析结果
    private String aiAnalysis;
    private List<String> suggestions;
    private String similarExceptions;
}
```

#### 异常状态枚举
```java
public enum ExceptionStatus {
    NEW("新异常"),
    ANALYZING("分析中"),
    RESOLVED("已解决"),
    IGNORED("已忽略"),
    RECURRING("重复出现");

    private final String description;

    ExceptionStatus(String description) {
        this.description = description;
    }
}
```

#### 异常分类枚举
```java
public enum ExceptionCategory {
    BUSINESS_EXCEPTION("业务异常"),
    SYSTEM_EXCEPTION("系统异常"),
    NETWORK_EXCEPTION("网络异常"),
    DATABASE_EXCEPTION("数据库异常"),
    SECURITY_EXCEPTION("安全异常"),
    PERFORMANCE_EXCEPTION("性能异常"),
    THIRD_PARTY_EXCEPTION("第三方服务异常"),
    UNKNOWN("未知异常");
}
```

#### 异常严重程度枚举
```java
public enum ExceptionSeverity {
    LOW("低"),
    MEDIUM("中"),
    HIGH("高"),
    CRITICAL("严重");

    private final String description;

    ExceptionSeverity(String description) {
        this.description = description;
    }
}
```

### 2. 全局异常捕获器

#### 全局异常处理器
```java
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    @Autowired
    private ExceptionLogService exceptionLogService;

    @Autowired
    private RequestContextHolder requestContextHolder;

    /**
     * 处理所有未捕获的异常
     */
    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<ErrorResponse> handleException(Exception ex, HttpServletRequest request) {
        // 创建异常日志
        ExceptionLog exceptionLog = createExceptionLog(ex, request, ExceptionCategory.SYSTEM_EXCEPTION, ExceptionSeverity.HIGH);

        // 异步保存异常日志
        CompletableFuture.runAsync(() -> {
            try {
                exceptionLogService.saveAsync(exceptionLog);
            } catch (Exception e) {
                log.error("保存异常日志失败", e);
            }
        });

        // 返回错误响应
        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .errorCode("SYSTEM_ERROR")
                .message("系统内部错误，请联系管理员")
                .requestId(exceptionLog.getRequestId())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }

    /**
     * 处理业务异常
     */
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex, HttpServletRequest request) {
        ExceptionLog exceptionLog = createExceptionLog(ex, request, ExceptionCategory.BUSINESS_EXCEPTION, ex.getSeverity());

        // 异步保存
        exceptionLogService.saveAsync(exceptionLog);

        ErrorResponse errorResponse = ErrorResponse.builder()
                .success(false)
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .requestId(exceptionLog.getRequestId())
                .timestamp(LocalDateTime.now())
                .build();

        return ResponseEntity.status(ex.getHttpStatus()).body(errorResponse);
    }

    /**
     * 创建异常日志对象
     */
    private ExceptionLog createExceptionLog(Exception ex, HttpServletRequest request,
                                          ExceptionCategory category, ExceptionSeverity severity) {
        // 获取请求上下文
        RequestContext context = requestContextHolder.getContext();

        return ExceptionLog.builder()
                .applicationName(getApplicationName())
                .serviceName(getServiceName())
                .instanceId(getInstanceId())
                .exceptionType(ex.getClass().getSimpleName())
                .exceptionMessage(ex.getMessage())
                .stackTrace(getStackTrace(ex))
                .userId(context.getUserId())
                .requestId(context.getRequestId())
                .sessionId(context.getSessionId())
                .traceId(context.getTraceId())
                .httpMethod(request.getMethod())
                .requestUri(request.getRequestURI())
                .clientIp(getClientIp(request))
                .requestHeaders(getRequestHeaders(request))
                .requestParams(getRequestParams(request))
                .requestBody(context.getRequestBody())
                .serverName(getServerName())
                .serverIp(getServerIp())
                .serverPort(request.getServerPort())
                .environment(getEnvironment())
                .executionTime(context.getExecutionTime())
                .memoryUsage(getMemoryUsage())
                .threadCount(getThreadCount())
                .exceptionTime(LocalDateTime.now())
                .createTime(LocalDateTime.now())
                .status(ExceptionStatus.NEW)
                .category(category)
                .severity(severity)
                .tags(generateTags(ex))
                .build();
    }

    // 辅助方法
    private String getStackTrace(Exception ex) {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);
        ex.printStackTrace(pw);
        return sw.toString();
    }

    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (xForwardedFor != null && !xForwardedFor.isEmpty()) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }

    private List<String> generateTags(Exception ex) {
        List<String> tags = new ArrayList<>();
        tags.add(ex.getClass().getSimpleName());

        // 根据异常类型添加标签
        if (ex instanceof SQLException) {
            tags.add("database");
            tags.add("sql");
        } else if (ex instanceof IOException) {
            tags.add("io");
            tags.add("file");
        } else if (ex instanceof TimeoutException) {
            tags.add("timeout");
            tags.add("performance");
        }

        return tags;
    }
}
```

#### 业务异常基类
```java
@Getter
public class BusinessException extends RuntimeException {

    private final String errorCode;
    private final HttpStatus httpStatus;
    private final ExceptionSeverity severity;
    private final Map<String, Object> context;

    public BusinessException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
        this.httpStatus = HttpStatus.BAD_REQUEST;
        this.severity = ExceptionSeverity.MEDIUM;
        this.context = new HashMap<>();
    }

    public BusinessException(String errorCode, String message, HttpStatus httpStatus) {
        super(message);
        this.errorCode = errorCode;
        this.httpStatus = httpStatus;
        this.severity = httpStatus.is5xxServerError() ? ExceptionSeverity.HIGH : ExceptionSeverity.MEDIUM;
        this.context = new HashMap<>();
    }

    public BusinessException(String errorCode, String message, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
        this.httpStatus = HttpStatus.INTERNAL_SERVER_ERROR;
        this.severity = ExceptionSeverity.HIGH;
        this.context = new HashMap<>();
    }

    public BusinessException addContext(String key, Object value) {
        this.context.put(key, value);
        return this;
    }
}
```

### 3. MongoDB存储服务

#### MongoDB配置
```java
@Configuration
public class MongoConfig {

    @Bean
    public MongoTemplate mongoTemplate(MongoDatabaseFactory databaseFactory) {
        MappingMongoConverter converter = new MappingMongoConverter(new DefaultDbRefResolver(databaseFactory), new MongoMappingContext());
        converter.setCustomConversions(customConversions());
        converter.afterPropertiesSet();

        MongoTemplate mongoTemplate = new MongoTemplate(databaseFactory, converter);

        // 创建索引
        createIndexes(mongoTemplate);

        return mongoTemplate;
    }

    private CustomConversions customConversions() {
        List<Converter<?, ?>> converters = new ArrayList<>();
        converters.add(new LocalDateTimeToStringConverter());
        converters.add(new StringToLocalDateTimeConverter());
        return new CustomConversions(converters);
    }

    private void createIndexes(MongoTemplate mongoTemplate) {
        // 复合索引：异常类型 + 时间
        mongoTemplate.indexOps(ExceptionLog.class)
                .ensureIndex(new Index()
                        .on("exceptionType", Sort.Direction.ASC)
                        .on("exceptionTime", Sort.Direction.DESC)
                        .named("exception_type_time"));

        // 时间索引
        mongoTemplate.indexOps(ExceptionLog.class)
                .ensureIndex(new Index()
                        .on("exceptionTime", Sort.Direction.DESC)
                        .expire(30 * 24 * 60 * 60) // 30天后自动删除
                        .named("exception_time_ttl"));

        // 状态索引
        mongoTemplate.indexOps(ExceptionLog.class)
                .ensureIndex(new Index()
                        .on("status", Sort.Direction.ASC)
                        .named("exception_status"));

        // 用户ID索引
        mongoTemplate.indexOps(ExceptionLog.class)
                .ensureIndex(new Index()
                        .on("userId", Sort.Direction.ASC)
                        .named("user_id"));

        // 请求ID索引
        mongoTemplate.indexOps(ExceptionLog.class)
                .ensureIndex(new Index()
                        .on("requestId", Sort.Direction.ASC)
                        .named("request_id"));
    }
}
```

#### 异常日志服务
```java
@Service
@Slf4j
public class ExceptionLogService {

    @Autowired
    private MongoTemplate mongoTemplate;

    @Autowired
    private ApplicationEventPublisher eventPublisher;

    /**
     * 同步保存异常日志
     */
    public ExceptionLog save(ExceptionLog exceptionLog) {
        try {
            // 设置创建时间
            exceptionLog.setCreateTime(LocalDateTime.now());

            // 检查是否为重复异常
            checkDuplicateException(exceptionLog);

            // 保存到MongoDB
            ExceptionLog saved = mongoTemplate.save(exceptionLog);

            // 发布异常事件
            eventPublisher.publishEvent(new ExceptionLoggedEvent(saved));

            log.info("异常日志保存成功: {}", saved.getId());
            return saved;
        } catch (Exception e) {
            log.error("保存异常日志失败", e);
            throw new RuntimeException("保存异常日志失败", e);
        }
    }

    /**
     * 异步保存异常日志
     */
    @Async
    public CompletableFuture<Void> saveAsync(ExceptionLog exceptionLog) {
        return CompletableFuture.runAsync(() -> {
            try {
                save(exceptionLog);
            } catch (Exception e) {
                log.error("异步保存异常日志失败", e);
            }
        });
    }

    /**
     * 批量保存异常日志
     */
    public List<ExceptionLog> saveBatch(List<ExceptionLog> exceptionLogs) {
        try {
            return (List<ExceptionLog>) mongoTemplate.insertAll(exceptionLogs);
        } catch (Exception e) {
            log.error("批量保存异常日志失败", e);
            throw new RuntimeException("批量保存异常日志失败", e);
        }
    }

    /**
     * 检查重复异常
     */
    private void checkDuplicateException(ExceptionLog exceptionLog) {
        // 查询最近24小时内相同类型的异常
        LocalDateTime startTime = LocalDateTime.now().minusHours(24);

        Query query = Query.query(Criteria.where("exceptionType").is(exceptionLog.getExceptionType())
                .and("exceptionMessage").is(exceptionLog.getExceptionMessage())
                .and("exceptionTime").gte(startTime));

        List<ExceptionLog> similarExceptions = mongoTemplate.find(query, ExceptionLog.class);

        if (!similarExceptions.isEmpty()) {
            // 更新第一个异常的发生次数
            ExceptionLog firstException = similarExceptions.get(0);
            firstException.setOccurrenceCount(firstException.getOccurrenceCount() + 1);
            mongoTemplate.save(firstException);

            // 将当前异常标记为重复
            exceptionLog.setStatus(ExceptionStatus.RECURRING);
            exceptionLog.setSimilarExceptions(firstException.getId());
        }
    }

    /**
     * 根据ID查询异常日志
     */
    public Optional<ExceptionLog> findById(String id) {
        try {
            return Optional.ofNullable(mongoTemplate.findById(id, ExceptionLog.class));
        } catch (Exception e) {
            log.error("查询异常日志失败: {}", id, e);
            return Optional.empty();
        }
    }

    /**
     * 分页查询异常日志
     */
    public Page<ExceptionLog> findAll(Pageable pageable) {
        try {
            Query query = new Query().with(pageable);
            List<ExceptionLog> content = mongoTemplate.find(query, ExceptionLog.class);
            long total = mongoTemplate.count(query, ExceptionLog.class);

            return new PageImpl<>(content, pageable, total);
        } catch (Exception e) {
            log.error("分页查询异常日志失败", e);
            return new PageImpl<>(Collections.emptyList(), pageable, 0);
        }
    }

    /**
     * 根据条件查询异常日志
     */
    public List<ExceptionLog> findByCriteria(ExceptionLogCriteria criteria) {
        try {
            Query query = buildQuery(criteria);
            return mongoTemplate.find(query, ExceptionLog.class);
        } catch (Exception e) {
            log.error("根据条件查询异常日志失败", e);
            return Collections.emptyList();
        }
    }

    /**
     * 构建查询条件
     */
    private Query buildQuery(ExceptionLogCriteria criteria) {
        Query query = new Query();

        if (StringUtils.hasText(criteria.getExceptionType())) {
            query.addCriteria(Criteria.where("exceptionType").is(criteria.getExceptionType()));
        }

        if (criteria.getStatus() != null) {
            query.addCriteria(Criteria.where("status").is(criteria.getStatus()));
        }

        if (criteria.getCategory() != null) {
            query.addCriteria(Criteria.where("category").is(criteria.getCategory()));
        }

        if (criteria.getSeverity() != null) {
            query.addCriteria(Criteria.where("severity").is(criteria.getSeverity()));
        }

        if (StringUtils.hasText(criteria.getUserId())) {
            query.addCriteria(Criteria.where("userId").is(criteria.getUserId()));
        }

        if (criteria.getStartTime() != null && criteria.getEndTime() != null) {
            query.addCriteria(Criteria.where("exceptionTime")
                    .gte(criteria.getStartTime())
                    .lte(criteria.getEndTime()));
        }

        if (criteria.getTags() != null && !criteria.getTags().isEmpty()) {
            query.addCriteria(Criteria.where("tags").in(criteria.getTags()));
        }

        return query;
    }

    /**
     * 更新异常状态
     */
    public boolean updateStatus(String id, ExceptionStatus status, String resolution) {
        try {
            Query query = Query.query(Criteria.where("_id").is(new ObjectId(id)));
            Update update = new Update()
                    .set("status", status)
                    .set("resolution", resolution);

            UpdateResult result = mongoTemplate.updateFirst(query, update, ExceptionLog.class);
            return result.getModifiedCount() > 0;
        } catch (Exception e) {
            log.error("更新异常状态失败: {}", id, e);
            return false;
        }
    }

    /**
     * 获取异常统计信息
     */
    public ExceptionStatistics getStatistics(LocalDateTime startTime, LocalDateTime endTime) {
        try {
            MatchOperation matchOperation = Aggregation.match(
                    Criteria.where("exceptionTime").gte(startTime).lte(endTime)
            );

            GroupOperation groupOperation = Aggregation.group()
                    .count().as("totalCount")
                    .addToSet("exceptionType").as("exceptionTypes")
                    .addToSet("category").as("categories")
                    .addToSet("severity").as("severities");

            Aggregation aggregation = Aggregation.newAggregation(matchOperation, groupOperation);
            AggregationResults<ExceptionStatistics> results = mongoTemplate.aggregate(aggregation, "exception_logs", ExceptionStatistics.class);

            return results.getUniqueMappedResult();
        } catch (Exception e) {
            log.error("获取异常统计信息失败", e);
            return new ExceptionStatistics();
        }
    }
}
```

### 4. MCP服务接口

#### MCP服务配置
```java
@Configuration
@EnableMcpServer
public class McpServerConfig {

    @Bean
    public McpServerTransport mcpServerTransport() {
        return new StdioServerTransport();
    }

    @Bean
    public McpServerCapabilities serverCapabilities() {
        return McpServerCapabilities.builder()
                .tools(true)
                .resources(true)
                .prompts(true)
                .logging(true)
                .build();
    }
}
```

#### 异常分析工具
```java
@Component
@Tool
@Slf4j
public class ExceptionAnalysisTool {

    @Autowired
    private ExceptionLogService exceptionLogService;

    @Autowired
    private AiAnalysisService aiAnalysisService;

    /**
     * 分析异常日志
     */
    @ToolMethod(description = "分析指定的异常日志，提供解决方案建议")
    public String analyzeException(
            @ToolParameter(description = "异常日志ID") String exceptionId,
            @ToolParameter(description = "是否需要详细分析", required = false) Boolean detailed) {

        try {
            // 查询异常日志
            Optional<ExceptionLog> exceptionLogOpt = exceptionLogService.findById(exceptionId);
            if (!exceptionLogOpt.isPresent()) {
                return "未找到指定的异常日志";
            }

            ExceptionLog exceptionLog = exceptionLogOpt.get();

            // 基本信息分析
            StringBuilder analysis = new StringBuilder();
            analysis.append("🔍 异常分析报告\n");
            analysis.append("================\n\n");
            analysis.append(String.format("异常类型: %s\n", exceptionLog.getExceptionType()));
            analysis.append(String.format("异常消息: %s\n", exceptionLog.getExceptionMessage()));
            analysis.append(String.format("发生时间: %s\n", exceptionLog.getExceptionTime()));
            analysis.append(String.format("严重程度: %s\n", exceptionLog.getSeverity()));
            analysis.append(String.format("异常分类: %s\n", exceptionLog.getCategory()));
            analysis.append(String.format("服务名称: %s\n", exceptionLog.getServiceName()));
            analysis.append(String.format("请求URI: %s %s\n", exceptionLog.getHttpMethod(), exceptionLog.getRequestUri()));

            if (StringUtils.hasText(exceptionLog.getUserId())) {
                analysis.append(String.format("用户ID: %s\n", exceptionLog.getUserId()));
            }

            analysis.append("\n📋 堆栈跟踪:\n");
            analysis.append(exceptionLog.getStackTrace());

            // AI分析（如果需要详细分析）
            if (Boolean.TRUE.equals(detailed)) {
                analysis.append("\n🤖 AI分析结果:\n");
                try {
                    String aiAnalysis = aiAnalysisService.analyzeException(exceptionLog);
                    analysis.append(aiAnalysis);

                    // 保存AI分析结果
                    exceptionLog.setAiAnalysis(aiAnalysis);
                    exceptionLogService.save(exceptionLog);

                } catch (Exception e) {
                    analysis.append("AI分析失败: ").append(e.getMessage());
                }
            }

            return analysis.toString();

        } catch (Exception e) {
            log.error("分析异常日志失败", e);
            return "分析异常日志时发生错误: " + e.getMessage();
        }
    }

    /**
     * 查询异常统计
     */
    @ToolMethod(description = "查询指定时间范围内的异常统计信息")
    public String getExceptionStatistics(
            @ToolParameter(description = "开始时间，格式：yyyy-MM-dd HH:mm:ss") String startTimeStr,
            @ToolParameter(description = "结束时间，格式：yyyy-MM-dd HH:mm:ss") String endTimeStr) {

        try {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
            LocalDateTime startTime = LocalDateTime.parse(startTimeStr, formatter);
            LocalDateTime endTime = LocalDateTime.parse(endTimeStr, formatter);

            ExceptionStatistics statistics = exceptionLogService.getStatistics(startTime, endTime);

            StringBuilder result = new StringBuilder();
            result.append("📊 异常统计报告\n");
            result.append("================\n\n");
            result.append(String.format("统计时间: %s 至 %s\n", startTimeStr, endTimeStr));
            result.append(String.format("总异常数: %d\n", statistics.getTotalCount()));

            if (statistics.getExceptionTypes() != null) {
                result.append(String.format("异常类型数: %d\n", statistics.getExceptionTypes().size()));
                result.append("主要异常类型:\n");
                statistics.getExceptionTypes().stream()
                        .limit(10)
                        .forEach(type -> result.append(String.format("  - %s\n", type)));
            }

            if (statistics.getCategories() != null) {
                result.append("\n异常分类:\n");
                statistics.getCategories().forEach(category ->
                        result.append(String.format("  - %s\n", category)));
            }

            if (statistics.getSeverities() != null) {
                result.append("\n严重程度分布:\n");
                statistics.getSeverities().forEach(severity ->
                        result.append(String.format("  - %s\n", severity)));
            }

            return result.toString();

        } catch (Exception e) {
            log.error("查询异常统计失败", e);
            return "查询异常统计时发生错误: " + e.getMessage();
        }
    }

    /**
     * 搜索相似异常
     */
    @ToolMethod(description = "搜索与指定异常相似的历史异常")
    public String findSimilarExceptions(
            @ToolParameter(description = "异常类型") String exceptionType,
            @ToolParameter(description = "异常消息") String exceptionMessage,
            @ToolParameter(description = "最大返回数量", required = false) Integer limit) {

        try {
            if (limit == null) {
                limit = 10;
            }

            // 构建搜索条件
            ExceptionLogCriteria criteria = ExceptionLogCriteria.builder()
                    .exceptionType(exceptionType)
                    .startTime(LocalDateTime.now().minusDays(30)) // 最近30天
                    .endTime(LocalDateTime.now())
                    .build();

            List<ExceptionLog> similarExceptions = exceptionLogService.findByCriteria(criteria);

            StringBuilder result = new StringBuilder();
            result.append("🔍 相似异常搜索结果\n");
            result.append("===================\n\n");
            result.append(String.format("搜索条件: %s\n", exceptionType));
            result.append(String.format("找到异常数: %d\n\n", similarExceptions.size()));

            // 显示前N个相似异常
            similarExceptions.stream()
                    .limit(limit)
                    .forEach(ex -> {
                        result.append(String.format("ID: %s\n", ex.getId()));
                        result.append(String.format("时间: %s\n", ex.getExceptionTime()));
                        result.append(String.format("消息: %s\n", ex.getExceptionMessage()));
                        result.append(String.format("状态: %s\n", ex.getStatus()));
                        result.append(String.format("用户: %s\n", ex.getUserId() != null ? ex.getUserId() : "未知"));
                        result.append("---\n");
                    });

            return result.toString();

        } catch (Exception e) {
            log.error("搜索相似异常失败", e);
            return "搜索相似异常时发生错误: " + e.getMessage();
        }
    }

    /**
     * 获取异常趋势分析
     */
    @ToolMethod(description = "分析异常发生趋势和模式")
    public String getExceptionTrends(
            @ToolParameter(description = "分析天数", required = false) Integer days) {

        try {
            if (days == null) {
                days = 7;
            }

            LocalDateTime endTime = LocalDateTime.now();
            LocalDateTime startTime = endTime.minusDays(days);

            // 按天统计异常数量
            List<ExceptionTrend> trends = getExceptionTrendsByDay(startTime, endTime);

            StringBuilder result = new StringBuilder();
            result.append("📈 异常趋势分析\n");
            result.append("===============\n\n");
            result.append(String.format("分析周期: 最近%d天\n", days));
            result.append(String.format("数据点数: %d\n\n", trends.size()));

            result.append("日期\t\t异常数量\t主要类型\n");
            result.append("----------------------------------------\n");

            for (ExceptionTrend trend : trends) {
                result.append(String.format("%s\t%d\t\t%s\n",
                        trend.getDate().toLocalDate(),
                        trend.getCount(),
                        trend.getTopExceptionType() != null ? trend.getTopExceptionType() : "无"));
            }

            return result.toString();

        } catch (Exception e) {
            log.error("获取异常趋势失败", e);
            return "获取异常趋势时发生错误: " + e.getMessage();
        }
    }

    private List<ExceptionTrend> getExceptionTrendsByDay(LocalDateTime startTime, LocalDateTime endTime) {
        // 这里实现按天统计异常数量的逻辑
        // 使用MongoDB聚合管道实现
        return new ArrayList<>();
    }
}
```

#### MCP资源处理器
```java
@Component
@Resource
@Slf4j
public class ExceptionLogResource {

    @Autowired
    private ExceptionLogService exceptionLogService;

    /**
     * 获取最新的异常日志
     */
    @ResourceMethod(uri = "logs://exceptions/latest", description = "获取最新的异常日志")
    public String getLatestExceptions(
            @ResourceParameter(description = "获取数量", required = false) Integer limit) {

        try {
            if (limit == null) {
                limit = 10;
            }

            PageRequest pageRequest = PageRequest.of(0, limit, Sort.by("exceptionTime").descending());
            Page<ExceptionLog> page = exceptionLogService.findAll(pageRequest);

            StringBuilder result = new StringBuilder();
            result.append("📋 最新异常日志\n");
            result.append("===============\n\n");

            for (ExceptionLog log : page.getContent()) {
                result.append(String.format("时间: %s\n", log.getExceptionTime()));
                result.append(String.format("类型: %s\n", log.getExceptionType()));
                result.append(String.format("消息: %s\n", log.getExceptionMessage()));
                result.append(String.format("严重程度: %s\n", log.getSeverity()));
                result.append(String.format("状态: %s\n", log.getStatus()));
                result.append("---\n");
            }

            return result.toString();

        } catch (Exception e) {
            log.error("获取最新异常日志失败", e);
            return "获取最新异常日志时发生错误: " + e.getMessage();
        }
    }

    /**
     * 获取异常日志详情
     */
    @ResourceMethod(uri = "logs://exceptions/{id}", description = "获取指定ID的异常日志详情")
    public String getExceptionDetails(@ResourceParameter(description = "异常日志ID") String id) {

        try {
            Optional<ExceptionLog> exceptionLogOpt = exceptionLogService.findById(id);
            if (!exceptionLogOpt.isPresent()) {
                return "未找到指定的异常日志";
            }

            ExceptionLog log = exceptionLogOpt.get();

            StringBuilder result = new StringBuilder();
            result.append("📄 异常日志详情\n");
            result.append("================\n\n");
            result.append(String.format("ID: %s\n", log.getId()));
            result.append(String.format("应用名称: %s\n", log.getApplicationName()));
            result.append(String.format("服务名称: %s\n", log.getServiceName()));
            result.append(String.format("异常时间: %s\n", log.getExceptionTime()));
            result.append(String.format("异常类型: %s\n", log.getExceptionType()));
            result.append(String.format("异常消息: %s\n", log.getExceptionMessage()));
            result.append(String.format("严重程度: %s\n", log.getSeverity()));
            result.append(String.format("异常分类: %s\n", log.getCategory()));
            result.append(String.format("状态: %s\n", log.getStatus()));

            if (StringUtils.hasText(log.getResolution())) {
                result.append(String.format("解决方案: %s\n", log.getResolution()));
            }

            if (log.getOccurrenceCount() > 1) {
                result.append(String.format("发生次数: %d\n", log.getOccurrenceCount()));
            }

            result.append(String.format("\n请求信息:\n"));
            result.append(String.format("  方法: %s\n", log.getHttpMethod()));
            result.append(String.format("  URI: %s\n", log.getRequestUri()));
            result.append(String.format("  客户端IP: %s\n", log.getClientIp()));

            if (StringUtils.hasText(log.getUserId())) {
                result.append(String.format("  用户ID: %s\n", log.getUserId()));
            }

            result.append(String.format("\n堆栈跟踪:\n%s\n", log.getStackTrace()));

            return result.toString();

        } catch (Exception e) {
            log.error("获取异常日志详情失败", e);
            return "获取异常日志详情时发生错误: " + e.getMessage();
        }
    }
}
```

### 5. AI分析服务

#### AI分析服务接口
```java
@Service
@Slf4j
public class AiAnalysisService {

    @Autowired
    private RestTemplate restTemplate;

    @Value("${ai.analysis.endpoint:http://localhost:11434/api/generate}")
    private String aiEndpoint;

    @Value("${ai.analysis.model:llama2}")
    private String aiModel;

    /**
     * 分析异常日志
     */
    public String analyzeException(ExceptionLog exceptionLog) {
        try {
            // 构建分析提示
            String prompt = buildAnalysisPrompt(exceptionLog);

            // 调用AI模型
            Map<String, Object> request = new HashMap<>();
            request.put("model", aiModel);
            request.put("prompt", prompt);
            request.put("stream", false);

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(request, headers);

            ResponseEntity<Map> response = restTemplate.postForEntity(aiEndpoint, entity, Map.class);

            if (response.getStatusCode().is2xxSuccessful()) {
                Map<String, Object> responseBody = response.getBody();
                return responseBody.get("response").toString();
            } else {
                throw new RuntimeException("AI分析请求失败: " + response.getStatusCode());
            }

        } catch (Exception e) {
            log.error("AI分析异常失败", e);
            return "AI分析失败: " + e.getMessage();
        }
    }

    /**
     * 构建分析提示
     */
    private String buildAnalysisPrompt(ExceptionLog exceptionLog) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("请分析以下Java异常信息，并提供解决方案建议：\n\n");

        prompt.append("异常基本信息：\n");
        prompt.append("- 异常类型: ").append(exceptionLog.getExceptionType()).append("\n");
        prompt.append("- 异常消息: ").append(exceptionLog.getExceptionMessage()).append("\n");
        prompt.append("- 发生时间: ").append(exceptionLog.getExceptionTime()).append("\n");
        prompt.append("- 严重程度: ").append(exceptionLog.getSeverity()).append("\n");
        prompt.append("- 异常分类: ").append(exceptionLog.getCategory()).append("\n");

        if (StringUtils.hasText(exceptionLog.getServiceName())) {
            prompt.append("- 服务名称: ").append(exceptionLog.getServiceName()).append("\n");
        }

        if (StringUtils.hasText(exceptionLog.getRequestUri())) {
            prompt.append("- 请求URI: ").append(exceptionLog.getRequestUri()).append("\n");
        }

        prompt.append("\n堆栈跟踪:\n");
        prompt.append(exceptionLog.getStackTrace());

        prompt.append("\n\n请提供以下分析：\n");
        prompt.append("1. 异常原因分析\n");
        prompt.append("2. 潜在影响评估\n");
        prompt.append("3. 解决方案建议\n");
        prompt.append("4. 预防措施\n");
        prompt.append("5. 相关代码示例（如适用）\n");

        return prompt.toString();
    }

    /**
     * 生成异常处理建议
     */
    public List<String> generateSuggestions(ExceptionLog exceptionLog) {
        List<String> suggestions = new ArrayList<>();

        // 根据异常类型提供建议
        switch (exceptionLog.getExceptionType()) {
            case "NullPointerException":
                suggestions.add("添加空值检查");
                suggestions.add("使用Optional处理可能为null的对象");
                suggestions.add("在方法参数中使用@NotNull注解");
                break;

            case "SQLException":
                suggestions.add("检查数据库连接配置");
                suggestions.add("验证SQL语句语法");
                suggestions.add("添加数据库连接池监控");
                break;

            case "IOException":
                suggestions.add("检查文件/网络连接状态");
                suggestions.add("添加重试机制");
                suggestions.add("验证文件权限");
                break;

            case "TimeoutException":
                suggestions.add("增加超时时间设置");
                suggestions.add("优化数据库查询性能");
                suggestions.add("添加异步处理机制");
                break;

            default:
                suggestions.add("查看详细堆栈跟踪信息");
                suggestions.add("检查相关日志文件");
                suggestions.add("联系开发团队进行分析");
                break;
        }

        return suggestions;
    }
}
```

## 📊 性能优化

### 1. 数据库优化

#### 索引策略
```javascript
// MongoDB索引配置
{
  "exception_type_time": {
    "exceptionType": 1,
    "exceptionTime": -1
  },
  "exception_time_ttl": {
    "exceptionTime": 1,
    "expireAfterSeconds": 2592000  // 30天
  },
  "exception_status": {
    "status": 1
  },
  "user_id": {
    "userId": 1
  },
  "request_id": {
    "requestId": 1
  }
}
```

#### 分片策略
```javascript
// MongoDB分片配置
{
  "_id": ObjectId("..."),
  "shardKey": {
    "exceptionType": 1,
    "exceptionTime": 1
  },
  "chunks": [
    {"min": {"exceptionType": "A", "exceptionTime": ISODate("2024-01-01")},
     "max": {"exceptionType": "M", "exceptionTime": ISODate("2024-07-01")}},
    {"min": {"exceptionType": "M", "exceptionTime": ISODate("2024-07-01")},
     "max": {"exceptionType": "Z", "exceptionTime": ISODate("2025-01-01")}}
  ]
}
```

### 2. 缓存策略

#### Redis缓存配置
```java
@Configuration
public class CacheConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);

        // 设置序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new Jackson2JsonRedisSerializer<>(Object.class));
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new Jackson2JsonRedisSerializer<>(Object.class));

        template.afterPropertiesSet();
        return template;
    }

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofHours(1)) // 默认1小时过期
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new Jackson2JsonRedisSerializer<>(Object.class)));

        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(config)
                .build();
    }
}
```

#### 缓存服务
```java
@Service
@Slf4j
public class ExceptionLogCacheService {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    private static final String EXCEPTION_CACHE_KEY = "exception:log:";
    private static final String STATISTICS_CACHE_KEY = "exception:statistics:";
    private static final Duration CACHE_TTL = Duration.ofMinutes(30);

    /**
     * 缓存异常日志
     */
    public void cacheExceptionLog(String id, ExceptionLog exceptionLog) {
        try {
            String key = EXCEPTION_CACHE_KEY + id;
            redisTemplate.opsForValue().set(key, exceptionLog, CACHE_TTL);
            log.debug("缓存异常日志: {}", id);
        } catch (Exception e) {
            log.error("缓存异常日志失败", e);
        }
    }

    /**
     * 获取缓存的异常日志
     */
    public ExceptionLog getCachedExceptionLog(String id) {
        try {
            String key = EXCEPTION_CACHE_KEY + id;
            return (ExceptionLog) redisTemplate.opsForValue().get(key);
        } catch (Exception e) {
            log.error("获取缓存的异常日志失败", e);
            return null;
        }
    }

    /**
     * 缓存统计信息
     */
    public void cacheStatistics(String key, ExceptionStatistics statistics) {
        try {
            String cacheKey = STATISTICS_CACHE_KEY + key;
            redisTemplate.opsForValue().set(cacheKey, statistics, CACHE_TTL);
            log.debug("缓存统计信息: {}", key);
        } catch (Exception e) {
            log.error("缓存统计信息失败", e);
        }
    }

    /**
     * 获取缓存的统计信息
     */
    public ExceptionStatistics getCachedStatistics(String key) {
        try {
            String cacheKey = STATISTICS_CACHE_KEY + key;
            return (ExceptionStatistics) redisTemplate.opsForValue().get(cacheKey);
        } catch (Exception e) {
            log.error("获取缓存的统计信息失败", e);
            return null;
        }
    }

    /**
     * 清除所有缓存
     */
    public void clearAllCache() {
        try {
            redisTemplate.delete(redisTemplate.keys(EXCEPTION_CACHE_KEY + "*"));
            redisTemplate.delete(redisTemplate.keys(STATISTICS_CACHE_KEY + "*"));
            log.info("清除所有异常日志缓存");
        } catch (Exception e) {
            log.error("清除缓存失败", e);
        }
    }
}
```

## 🚀 部署架构

### Docker Compose配置
```yaml
version: '3.8'

services:
  # Java应用服务
  java-app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
      - MONGODB_URI=mongodb://mongodb:27017/exception_logs
      - REDIS_URI=redis://redis:6379
    depends_on:
      - mongodb
      - redis
    networks:
      - app-network

  # MongoDB数据库
  mongodb:
    image: mongo:5.0
    ports:
      - "27017:27017"
    volumes:
      - mongodb_data:/data/db
      - ./mongo-init:/docker-entrypoint-initdb.d
    environment:
      - MONGO_INITDB_ROOT_USERNAME=admin
      - MONGO_INITDB_ROOT_PASSWORD=password
    networks:
      - app-network

  # Redis缓存
  redis:
    image: redis:7.0-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - app-network

  # MCP服务器
  mcp-server:
    build: ./mcp-server
    ports:
      - "3000:3000"
    environment:
      - MONGODB_URI=mongodb://mongodb:27017/exception_logs
      - REDIS_URI=redis://redis:6379
    depends_on:
      - mongodb
      - redis
    networks:
      - app-network

networks:
  app-network:
    driver: bridge

volumes:
  mongodb_data:
  redis_data:
```

### Kubernetes部署
```yaml
# Java应用部署
apiVersion: apps/v1
kind: Deployment
metadata:
  name: exception-log-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: exception-log-service
  template:
    metadata:
      labels:
        app: exception-log-service
    spec:
      containers:
      - name: java-app
        image: your-registry/exception-log-service:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: MONGODB_URI
          value: "mongodb://mongodb-service:27017/exception_logs"
        - name: REDIS_URI
          value: "redis://redis-service:6379"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"

---
# MongoDB部署
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mongodb
spec:
  serviceName: mongodb-service
  replicas: 1
  selector:
    matchLabels:
      app: mongodb
  template:
    metadata:
      labels:
        app: mongodb
    spec:
      containers:
      - name: mongodb
        image: mongo:5.0
        ports:
        - containerPort: 27017
        env:
        - name: MONGO_INITDB_ROOT_USERNAME
          value: "admin"
        - name: MONGO_INITDB_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mongodb-secret
              key: password
        volumeMounts:
        - name: mongodb-storage
          mountPath: /data/db
  volumeClaimTemplates:
  - metadata:
      name: mongodb-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 50Gi
```

## 📈 监控和告警

### 监控指标
```java
@Configuration
public class MetricsConfig {

    @Bean
    public MeterRegistry meterRegistry() {
        return new SimpleMeterRegistry();
    }

    @Bean
    public ExceptionLogMetrics exceptionLogMetrics(MeterRegistry meterRegistry) {
        return new ExceptionLogMetrics(meterRegistry);
    }
}

@Component
public class ExceptionLogMetrics {

    private final Counter exceptionCounter;
    private final Timer exceptionProcessingTimer;
    private final Gauge activeExceptions;

    public ExceptionLogMetrics(MeterRegistry meterRegistry) {
        this.exceptionCounter = Counter.builder("exception_log_total")
                .description("Total number of logged exceptions")
                .tags("service", "exception-log-service")
                .register(meterRegistry);

        this.exceptionProcessingTimer = Timer.builder("exception_processing_duration")
                .description("Time taken to process exception logs")
                .tags("service", "exception-log-service")
                .register(meterRegistry);

        this.activeExceptions = Gauge.builder("exception_active_total", this, ExceptionLogMetrics::getActiveExceptionCount)
                .description("Number of active (unresolved) exceptions")
                .tags("service", "exception-log-service")
                .register(meterRegistry);
    }

    public void incrementExceptionCounter(String type, String severity) {
        exceptionCounter.increment();
    }

    public Timer.Sample startProcessingTimer() {
        return Timer.start(meterRegistry);
    }

    private double getActiveExceptionCount() {
        // 查询活跃异常数量的逻辑
        return 0.0;
    }
}
```

### 告警配置
```yaml
# Prometheus告警规则
groups:
  - name: exception_alerts
    rules:
      - alert: HighExceptionRate
        expr: rate(exception_log_total[5m]) > 10
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "异常发生率过高"
          description: "过去5分钟异常发生率超过10次/分钟"

      - alert: CriticalExceptionDetected
        expr: exception_log_total{severity="CRITICAL"} > 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "检测到严重异常"
          description: "发现严重级别异常，请立即处理"

      - alert: DatabaseConnectionFailed
        expr: up{job="mongodb"} == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "数据库连接失败"
          description: "MongoDB数据库连接异常"
```

## 🎯 使用示例

### 1. 基本异常捕获
```java
@Service
public class UserService {

    @Autowired
    private UserRepository userRepository;

    public User getUserById(String userId) {
        try {
            return userRepository.findById(userId)
                    .orElseThrow(() -> new BusinessException("USER_NOT_FOUND", "用户不存在: " + userId));
        } catch (DataAccessException e) {
            throw new BusinessException("DATABASE_ERROR", "数据库查询失败", e);
        }
    }
}
```

### 2. MCP工具调用示例
```bash
# 分析异常
mcp_tool analyze_exception exception_id="64f1a2b3c4d5e6f7g8h9i0j1" detailed=true

# 查询统计
mcp_tool get_exception_statistics start_time="2024-01-01 00:00:00" end_time="2024-01-31 23:59:59"

# 搜索相似异常
mcp_tool find_similar_exceptions exception_type="NullPointerException" limit=5

# 获取趋势分析
mcp_tool get_exception_trends days=7
```

### 3. 资源访问示例
```bash
# 获取最新异常
curl http://localhost:3000/logs/exceptions/latest?limit=10

# 获取异常详情
curl http://localhost:3000/logs/exceptions/64f1a2b3c4d5e6f7g8h9i0j1
```

## 📚 总结

本文详细介绍了构建完整的Java异常日志MCP服务架构的关键技术点：

### 🏗️ 架构优势
- **完整的异常生命周期管理**：从捕获到分析到解决
- **AI驱动的智能分析**：利用大模型提供异常诊断建议
- **高性能存储和查询**：MongoDB + Redis的优化组合
- **标准化服务接口**：MCP协议保证跨平台兼容性

### 🔧 技术亮点
- **全局异常处理**：AOP + ControllerAdvice的统一异常处理
- **智能异常分类**：基于规则和AI的异常分类系统
- **实时监控告警**：Prometheus + Grafana的监控体系
- **弹性伸缩部署**：Docker + Kubernetes的容器化部署

### 🚀 业务价值
- **提升问题解决效率**：AI分析减少排查时间
- **降低运维成本**：自动化异常处理和告警
- **增强系统稳定性**：数据驱动的异常预防
- **支持敏捷开发**：快速定位和解决问题

这套架构不仅解决了传统异常处理系统的痛点，还通过AI和大模型的集成，开创了智能异常分析的新模式。在微服务架构日益复杂的今天，这种AI增强的异常处理系统将成为保障系统稳定性的重要基础设施。

---

**🔗 相关链接**
- [Spring Boot官方文档](https://spring.io/projects/spring-boot)
- [MongoDB官方文档](https://docs.mongodb.com/)
- [MCP协议规范](https://modelcontextprotocol.io/)
- [Prometheus监控](https://prometheus.io/)

---

**🎯 立即开始构建您的智能异常处理系统！** 🚀

---
title: 创建型模式-工厂模式
date: 2022-07-30 16:44:53
tags:
    - 设计模式
    - 创建型模式
top_img: https://p3.qhimg.com/bdm/1000_618_85/t01ce5cc5dbcfbc21f7.jpg
cover: https://p3.qhimg.com/bdm/1000_618_85/t01ce5cc5dbcfbc21f7.jpg
---
<a name="sgFbs"></a>
# 前言
工厂模式是最常用的创建型模式，分为三种：简单工厂模式，工厂方法模式和抽象工厂模式
<a name="oqV7O"></a>
# 源码场景（后续补充）
<a name="LqiGF"></a>
## 线程池：ThreadFactory
在线程池构建 Worker 的时候会通过调用传入线程工厂对象的 newThread() 方法创建Worker 持有的线程
<a name="mqffe"></a>
## 日志：LoggerFactory
<a name="CXGZN"></a>
## Spring：BeanFactory
<a name="qNxJh"></a>
## MyBatis：SqlSessionFactory
<a name="r7g5t"></a>
# 简单工厂模式
简单工厂模式并不属于GoF 23个经典设计模式，但通常将它作为学习其他工厂模式的基础
<a name="cNZ2D"></a>
## 角色
<a name="Ts8fl"></a>
### Factory 工厂角色
> 工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；
> 工厂类可以被外界直接调用，创建所需的产品对象；
> 在工厂类中提供了静态的工厂方法factoryMethod()，它的返回类型为抽象产品类型Product

```java
class ChartFactory {  
    //静态工厂方法  
    public static Chart getChart(String type) {  
        Chart chart = null;  
        if (type.equalsIgnoreCase("histogram")) {  
            chart = new HistogramChart();  
            System.out.println("初始化设置柱状图！");  
        }  
        else if (type.equalsIgnoreCase("pie")) {  
            chart = new PieChart();  
            System.out.println("初始化设置饼状图！");  
        }
        return chart;  
    }  
}
```
<a name="CweSk"></a>
### Product 抽象产品角色
> 它是工厂类所创建的所有对象的父类，封装了各种产品对象的公有方法；
> 它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象

```java
interface Chart {  
    public void display();  
}  
```
<a name="VeMSj"></a>
### ConcreteProduct 具体产品角色
> 它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例；
> 每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法

```java
class HistogramChart implements Chart {  
    public HistogramChart() {  
        System.out.println("创建柱状图！");  
    }  
    public void display() {  
        System.out.println("显示柱状图！");  
    }  
}  
```
```java
class PieChart implements Chart {  
    public PieChart() {  
        System.out.println("创建饼状图！");  
    }  
    public void display() {  
        System.out.println("显示饼状图！");  
    }  
} 
```
<a name="jqMHU"></a>
## 测试
```java
class Client {  
    public static void main(String args[]) {  
        Chart chart;  
        chart = ChartFactory.getChart("histogram"); //通过静态工厂方法创建产品  
        chart.display();  
    }  
}

创建柱状图！
初始化设置柱状图！
显示柱状图！

若需要饼状图则改为
chart = ChartFactory.getChart("pie");
```
<a name="KHlPv"></a>
## 优点

- 增加固定类型产品的不同具体工厂比较方便
- 实现了对象创建和使用的分离，使用者不必关心类对象如何创建，明确了职责
- 在需要多个相关产品的时候，仍然只需要一个工厂对象
<a name="C1fjB"></a>
## 缺点

- 由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响
- 会增加系统中类的个数，增加了系统的复杂度和理解难度
- 要新增产品类的时候，就要修改工厂类的代码，违反了开放封闭原则
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构
<a name="hmBFh"></a>
## 适用场景

- 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂
- 客户端只知道传入工厂类的参数，对于如何创建对象并不关心
<a name="WzK1X"></a>
# 工厂方法模式
简单工厂模式虽然简单，但存在一个很严重的问题<br />当系统中需要引入新产品时，由于静态工厂方法通过所传入参数的不同来创建不同的产品<br />这必定要修改工厂类的源代码，将违背“开闭原则”，如何实现增加新产品而不影响已有代码？<br />工厂方法模式应运而生。
<a name="SWJ9b"></a>
## 角色
<a name="fg9vc"></a>
### Product 抽象产品
> 它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类

```java
interface Logger {  
    public void writeLog();  
}  
```
<a name="yp1YA"></a>
### ConcreteProduct 具体产品
> 它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应

```java
class DatabaseLogger implements Logger {  
    public void writeLog() {  
        System.out.println("数据库日志记录。");  
    }  
}  
```
```java
class FileLogger implements Logger {  
    public void writeLog() {  
        System.out.println("文件日志记录。");  
    }  
}
```
<a name="GSv6S"></a>
### Factory 抽象工厂
> 在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口

```java
interface LoggerFactory {  
    public Logger createLogger();  
}  
```
<a name="zmCLe"></a>
### ConcreteFactory 具体工厂
> 它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例

```java
class DatabaseLoggerFactory implements LoggerFactory {  
    public Logger createLogger() {  
            //连接数据库，代码省略  
            //创建数据库日志记录器对象  
            Logger logger = new DatabaseLogger();   
            //初始化数据库日志记录器，代码省略  
            return logger;  
    }     
} 
```
```java
class FileLoggerFactory implements LoggerFactory {  
    public Logger createLogger() {  
            //创建文件日志记录器对象  
            Logger logger = new FileLogger();   
            //创建文件，代码省略  
            return logger;  
    }     
}
```
<a name="R55l1"></a>
## 测试
```java
class Client {  
    public static void main(String args[]) {  
        LoggerFactory factory;  
        Logger logger;  
        factory = new FileLoggerFactory();
        logger = factory.createLogger();  
        logger.writeLog();  
    }  
}
```
<a name="k5NkB"></a>
## 优点

- 在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名
- 基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，就正是因为所有的具体工厂类都具有同一抽象父类
- 使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”
<a name="RSOiE"></a>
## 缺点

- 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度
<a name="NbhaS"></a>
## 适用场景

- 客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建，可将具体工厂类的类名存储在配置文件或数据库中
- 抽象工厂类通过其子类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展、
<a name="mptuA"></a>
# 抽象工厂模式
工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。<br />此时，我们可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想
<a name="aieYX"></a>
## 角色
<a name="srUR9"></a>
## AbstractFactory 抽象工厂
> 它声明了一组用于创建一族产品的方法，每一个方法对应一种产品

```java
interface SkinFactory {  
    public Button createButton();  
    public TextField createTextField();  
}  
```
<a name="kmKQY"></a>
## ConcreteFactory 具体工厂
> 它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中

```java
class SpringSkinFactory implements SkinFactory {  
    public Button createButton() {  
        return new SpringButton();  
    }  
    public TextField createTextField() {  
        return new SpringTextField();  
    }  
}  
```
```java
class SummerSkinFactory implements SkinFactory {  
    public Button createButton() {  
        return new SummerButton();  
    }  
    public TextField createTextField() {  
        return new SummerTextField();  
    }  
}
```
<a name="nnBME"></a>
## AbstractProduct 抽象产品
> 它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法

```java
interface Button {  
    public void display();  
}  
```
```java
interface TextField {  
    public void display();  
}  
```
<a name="sev9U"></a>
## ConcreteProduct 具体产品
> 它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法

```java
class SpringButton implements Button {  
    public void display() {  
        System.out.println("显示浅绿色按钮。");  
    }  
} 
```
```java
class SummerButton implements Button {  
    public void display() {  
        System.out.println("显示浅蓝色按钮。");  
    }     
}  
```
```java
class SpringTextField implements TextField {  
    public void display() {  
        System.out.println("显示绿色边框文本框。");  
    }  
} 
```
```java
class SummerTextField implements TextField {  
    public void display() {  
        System.out.println("显示蓝色边框文本框。");  
    }     
} 
```
<a name="tSQpy"></a>
## 测试
```java
class Client {  
    public static void main(String args[]) {  
        //使用抽象层定义  
        SkinFactory factory;  
        Button bt;  
        TextField tf;  
        factory = new SpringSkinFactory();  
        bt = factory.createButton();  
        tf = factory.createTextField();  
        bt.display();  
        tf.display();  
    }  
}
```
<a name="PTbnr"></a>
## 优点

- 抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为
- 当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象
- 增加新的产品族很方便，无须修改已有系统，符合“开闭原则”
<a name="fC6dp"></a>
## 缺点

- 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”
<a name="fsGhI"></a>
## 适用场景

- 一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦
- 系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族
- 属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型
- 产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构
